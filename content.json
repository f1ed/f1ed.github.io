{"pages":[],"posts":[{"title":"Adagrag-demo","text":"实现这篇文章中前面两个tips。 实现了tip1 Adagrad + tip2 Stochastic Gradient Descent demo代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869################## 2020/03/06 ## Adagrad demo ##################import numpy as npimport matplotlib.pyplot as pltfrom sklearn import linear_model# datax_data = [[338.], [333.], [328.], [207.], [226.], [25.], [179.], [60.], [208.], [606.]]y_data = [640., 633., 619., 393., 428., 27., 193., 66., 226., 1591.]# coordinatex = np.arange(-200, -100, 1)y = np.arange(-5, 5, 0.1)Z = np.zeros((len(y), len(x)))# cal the Loss of every point(function)for i in range(len(x)): for j in range(len(y)): b = x[i] w = y[j] for k in range(len(x_data)): Z[j][i] += (y_data[k] - b - w * x_data[k][0])**2# initialb = -120w = -4lr = 1 # learning rateiteration = 100000# record the iterationb_his = [b]w_his = [w]# Adagradb_grad_sum2 = 0.0w_grad_sum2 = 0.0for i in range(iteration): for k in range(len(x_data)): b_grad = 2 * (y_data[k] - b - w * x_data[k][0]) * (-1) w_grad = 2 * (y_data[k] - b - w * x_data[k][0]) * (-x_data[k][0]) b_grad_sum2 += b_grad**2 w_grad_sum2 += w_grad**2 b = b - lr / np.sqrt(b_grad_sum2) * b_grad w = w - lr / np.sqrt(w_grad_sum2) * w_grad b_his.append(b) w_his.append(w)# sklearn linear modelreg = linear_model.LinearRegression()print(reg.fit(x_data, y_data))print(reg.coef_[0])print(reg.intercept_)# display the figureplt.contourf(x, y, Z, 50, alpha=0.5, cmap=plt.get_cmap('jet'))plt.plot(reg.intercept_, reg.coef_, 'x', ms=13, lw=1.5, color='orange')plt.plot(b_his, w_his, 'o-', ms=3, lw=1.5, color='black')plt.xlim(-200, -100)plt.ylim(-5, 5)plt.xlabel('$b$', fontsize=16)plt.ylabel('$w$', fontsize=16)# plt.show()plt.savefig(\"Loss.png\") Loss 迭代图画出的图片很直观","link":"/2020/03/09/Adagrad-demo/"},{"title":"「机器学习-李宏毅」：Backpropagation","text":"这篇文章中，讲解了Deep Learning中使用的一种高效Gradient Descent的算法：BackPropagation。BackPropagation通过正向传播和反向传播两个阶段，最后能一起算出损失函数对每一个参数的gradient。 Gradient Descent在Neural Network中，参数的更新也是通过Gradient Descent。 但是当Neural Network层数很深，结构很复杂的时候，会有millions of parapmeters。 Backpropagation：To compute the gradient efficiently. Chain RuleBP中需要用到的数学知识：微积分中的链式法则。 Backpropagation 在NN中，定义损失函数 $L(\\theta)=\\sum_{n=1}^{N} C^{n}(\\theta)$ （$\\theta$ 代指NN中所有的weight 和bias） 对某一参数的gradient为 $\\frac{\\partial L(\\theta)}{\\partial w}=\\sum_{n=1}^{N} \\frac{\\partial C^{n}(\\theta)}{\\partial w}$ 在上图NN中，我们先只研究红框部分，即是以下结构： z：每个activation function的输入。 根据链式法则， $\\frac{\\partial C}{\\partial w}= \\frac{\\partial z}{\\partial w} \\frac{\\partial C}{\\partial z}$ . 要计算每个参数的 $\\frac{\\partial C}{\\partial w}$ ，分为两部分。 Forward pass: compute $\\frac{\\partial z}{\\partial w} $ for all parameters. Backward pass: compute $\\frac{\\partial C}{\\partial z} $ for all activation function inputs z. BP：Forward passCompute $\\frac{\\partial z}{\\partial w} $ for all parameters. 还是只看上图这一部分，可以轻易得出： $\\partial{z}/\\partial{w_1}=x_1\\qquad \\partial{z}/\\partial{w_2}=x_2$ 得到结论： $\\frac{\\partial z}{\\partial w} $ 等于 the value of the input connected by the weight. 【$\\frac{\\partial z}{\\partial w} $ 等于 连接w的输入的值】 那么，如何计算出NN中全部的 $\\frac{\\partial z}{\\partial w} $ ？ ：Forward pass. 用当前参数（w,b) 从hidden layer的第一层开始，计算出第一层的输出，即第二层的输入。 依次相前计算，计算出每一层的输出，即下一层的输入，即输入所连接权重的 $\\frac{\\partial z}{\\partial w}$ 。 BP：Backward passCompute $\\frac{\\partial C}{\\partial z} $ for all activation function inputs z. z：activation function的 input a：activation function的 output 这里的activation function 是 sigmod函数 $a=\\sigma(z)=\\frac{1}{1+e^{-z}}$ 要求 $\\frac{\\partial C}{\\partial z}$ ， 再根据链式法则： $\\frac{\\partial C}{\\partial z}=\\frac{\\partial a}{\\partial z}\\frac{\\partial C}{\\partial a}$ 求 $\\frac{\\partial{a}}{\\partial{z}}$ : $\\frac{\\partial{a}}{\\partial{z}}=\\sigma'(z)=\\sigma(z)(1-\\sigma(z))$ （是其他activation function 也能轻易求出） 求 $\\frac{\\partial C}{\\partial a}$ ：根据链式法则： $\\frac{\\partial C}{\\partial a}=\\frac{\\partial z^{\\prime}}{\\partial a} \\frac{\\partial C}{\\partial z^{\\prime}}+\\frac{\\partial z^{\\prime \\prime}}{\\partial a} \\frac{\\partial C}{\\partial z^{\\prime \\prime}}$ $\\frac{\\partial z^{\\prime}}{\\partial a} =w_3$ ， $\\frac{\\partial z^{\\prime\\prime}}{\\partial a} =w_4$ $\\frac{\\partial C}{\\partial z^{\\prime}}$ 和 $\\frac{\\partial C}{\\partial z^{\\prime\\prime}}$ ？假设，已经通过某种方法算出这个值。 $\\frac{\\partial C}{\\partial z}=\\sigma^{\\prime}(z)\\left[w_{3} \\frac{\\partial C}{\\partial z^{\\prime}}+w_{4} \\frac{\\partial C}{\\partial z^{\\prime \\prime}}\\right]$ 这个式子，可以画成一个反向传播的NN，见下图。 $\\frac{\\partial C}{\\partial z^{\\prime}},\\frac{\\partial C}{\\partial z^{\\prime\\prime}}$ 是这个neuron的输入， $w_3,w_4$ 仍然是 neuron的 weight（无bias）。 $\\sigma’(z)$ 是一个常数，因为在forward pass中每一个activation的输入已经被算出来了。 和forward pass中的NN的区别是，forward 中是一个activation function，输入z作用于这个函数； 而在 backward pass中，这更像一个放缩器，将他的输入变小，即乘上一个 $\\sigma’(z)$ 。 问题还是如何计算 $\\frac{\\partial C}{\\partial z}=\\sigma^{\\prime}(z)\\left[w_{3} \\frac{\\partial C}{\\partial z^{\\prime}}+w_{4} \\frac{\\partial C}{\\partial z^{\\prime \\prime}}\\right]$ ？ 分为两种情况讨论， $z’,z’’$ 是否为输出层的输入？ Output Layer： z’,z’’：activation function的输入。 y1,y2：actiavtion function（也是NN）的输出。 C：NN输出和target的cross entropy。 根据链式法则： $\\frac{\\partial C}{\\partial z^{\\prime}}=\\frac{\\partial y_{1}}{\\partial z^{\\prime}} \\frac{\\partial C}{\\partial y_{1}} \\quad \\frac{\\partial C}{\\partial z^{\\prime \\prime}}=\\frac{\\partial y_{2}}{\\partial z^{\\prime \\prime}} \\frac{\\partial C}{\\partial y_{2}}$ 所以，已知activation function（simod或者其他），可以轻易求出 $\\frac{\\partial y_{1}}{\\partial z^{\\prime}}(=\\sigma'(z'))$ 和 $\\frac{\\partial y_{2}}{\\partial z^{\\prime\\prime}}(=\\sigma''(z''))$ 。 所以，已知损失函数，也可以轻易求出 $\\frac{\\partial C}{\\partial y_1}$ 和 $\\frac{\\partial C}{\\partial y_2}$ 。（ $C\\left(y, \\hat{y}\\right)=-\\left[\\hat{y} \\ln y+\\left(1-\\hat{y}\\right) \\ln \\left(1-y\\right)\\right]$ ) 所以，可以直接求出 $\\frac{\\partial C}{\\partial z}=\\sigma^{\\prime}(z)\\left[w_{3} \\frac{\\partial C}{\\partial z^{\\prime}}+w_{4} \\frac{\\partial C}{\\partial z^{\\prime \\prime}}\\right]$ 。 Not Output Layer: 上图中，如果我们要计算 $\\frac{\\partial C}{\\partial z’}$ ，必须要已知下一层的 $\\frac{\\partial C}{\\partial z_a}$ ，然后一直递归下去，直到到达最后的输出层，也就是上面一种情况，可以直接计算出，再递归回来，计算当前层的 $\\frac{\\partial C}{\\partial z’}$ 。 但是，这样计算每个参数的 $\\frac{\\partial{C}}{\\partial{z}}$ 都要一直递归到输出层，效率显然太低了。 计算方法如上图： 当我们已知输出层的 $\\frac{\\partial{C}}{\\partial{z'}},\\frac{\\partial{C}}{\\partial{z''}}$ 时，再通过上面的步骤3（且的确算出了 $\\frac{\\partial{C}}{\\partial{z'}},\\frac{\\partial{C}}{\\partial{z''}}$ ），画成反向的NN，计算$\\frac{\\partial{C}}{\\partial{z}}$. 再依次反向传播计算出每一个neuron的输出z （也是正向传播neuron的输入）的 $\\frac{\\partial{C}}{\\partial{z}}$ . Backforward pass 的做法： 先计算出输出层的 $\\frac{\\partial{C}}{\\partial{z}}$ （也就是上图的 $\\frac{\\partial{C}}{\\partial{z_5}}$ 和 $\\frac{\\partial{C}}{\\partial{z_6}}$ ） 用反向传播的NN，向后依次计算出每一层每一个neuron的 $\\frac{\\partial{C}}{\\partial{z}}$ 。 Summary 公式： $\\frac{\\partial z}{\\partial w} \\frac{\\partial C}{\\partial z}=\\frac{\\partial C}{\\partial w}$ 在正向传播NN中，z是neuron的activation function的输入。 在反向传播NN中，z是neuron的放缩器的输出。 通过Forward Pass计算出正向传播NN的每一个neuron的 $\\frac{\\partial z}{\\partial w}$ ，等于该层neuron的输入。 通过Backward Pass计算出反向传播NN的每一个neuron的 $\\frac{\\partial C}{\\partial z}$ 。 然后，通过相乘，计算出每个参数的 $\\frac{\\partial C}{\\partial w}$。 Reference","link":"/2020/04/18/Backpropagation/"},{"title":"「机器学习-李宏毅」：Convolution Neural Network（CNN）","text":"这篇文章中首先介绍了为什么要用CNN做图像识别，或者说图像识别问题的特点是什么？文章中也详细介绍了CNN的具体架构，主要包括Convolution、Max Pooling、Flatten。文章最后简要介绍了CNN在诸多领域的应用。 Why CNN for Image?图片本质都是pixels。 在做图像识别时，本质是对图片中的某些特征像素（properities)识别。 So Why CNN for image? Some patterns are much smaller than the whole image. A neuron does not have to see the whole image to discover the pattern. Connecting to small region with less parameters. 【很多特征图案的大小远小于整张图片的大小，因此一个neuron不需要为了识别某个pattern而看完整张图片。并且，如果只识别某个小的region，会减少大量参数的数目。】 如下图，用一个neuron识别红框中的beak，即能大概率认为图片中有bird。 The same patterns appear in different regions. They can use the same set of parameters. 【同样的pattern可能出现在图片的不同位置。pattern几乎相同，因此可以用同一组参数。】 如下图，两个neuron识别两个不同位置的beak。被识别的beak几乎无差别，因此neuron的参数可以是相同的。 Subsampling the pixels will not change the object. 【一张图片是由许多pixel组成的，如下图，如果去掉图片的所有奇数行偶数列的pixel，图片内容几乎无差别。并且，Subsample pixels，即减少了输入的size，也可以减少NN的参数数量。】 The whole CNNCNN的架构如下图。 一张图片经过多次Convolution、Max Pooling得到新的image，再将新的image Flatten（拉直）得到一组提取好的features，将这组features放入前馈神经网络。 Convolution满足图片识别的： Property 1 : Some patterns are much smaller than the whole image. Property 2 : The same patterns appear in different regions. Max Pooling满足图片识别的： Property 3 : Subsamplingthe pixels will not change the object. CNN-Convolution一张简单的黑白图片如下图，0为白色，1为黑色。 如果图片是彩色的，即用RGB三原色来表示，用三个matrix分别表示R、G、B的值，如下图： 下文中，以黑白图举例。 Property 1设计Filer matrix满足Property 1，如下图： 上图中，filter的大小是3*3，可以检测到小区域的某个pattern。 每个filter的参数都是NN中的参数，需要learned。 如果是彩色图片，filter应该是3张3*3matrix组成的，分别代表R、G、B的filter。 Property 2为了满足Property 2，filter可以在图片中移动。设置stride，即每次filter移动的步长。 filter与覆盖图片的位置做内积，需要走完整张图片，最后得到一张feature map。 下图为stride=1的convolution结果： Convolution layer（卷积层）有几个filter，就会得到几张feature maps。 Convolution v.s. Fully Connected*Fully Connected： * 如果用全连接的方式做图片识别，图片的每一个pixel都要都第一层layer的每个neuron，则需要大量参数连接。 如下图： *Convolution： * 而在Convolution中，把feature map中的每一个值作为neuron的输出，对于一个3*3的filter，一个neuron的连接如下： filter中的值是连接参数，则每一个neuron只需要与3*3个input连接，与全连接相比减少了大量参数。 shared weights filter在图中移动时，filter的参数不变，即第二个neuron的连接参数和第一个neuron的连接参数是相同的，连接图如下： 通过filter实现了shared weights（参数共享），更大幅度减少了参数数量。 CNN-Max PoolingMax Pooling：将convolution layer的neuron作为输入，neuron的activation function其实就是Maxout（Maxout介绍见 这篇 2.1.4的介绍）。 将convolution layer得到的feature map做Max pooling（池化），即取下图中每个框中的最大值。 如下图，6*6的image经过Convolution layer 和 Max Pooling layer后，得到了new but smaller image，新的image的由两层channel组成，每层channel都是2 * 2的image。 一个image每经过一次Convolution layer 和 Max Pooling layer，都会得到a new image。 This new image is smaller than the origin image. And the number of channel (of the new image) is the number of filters. 举个例子： Convolution layer有25个filters，再经过Max Pooling，得到的新的image有25 个channel。 再重复一次Convolution 和Max Pooling，新的Convolution layer也有25个filters，再经过Max Pooling，得到的新的image有多少个channel呢？ 答案是25个channel。 注意 ：在第二次Convolution中，image有depth，depth=25。因此在convolution中，filter其实是一个cubic，也有depth，depth=image-depth=25，再做内积。 因此，新的image的channel数是等于filter数的。 FlattenFlatten很好理解，将最后得到的新的image 拉直（Flatten）为一个vector。 拉直后的vector是一组提取好的features，作为 前馈神经网络的输入。 What dose CNN learn为什么CNN能够学习pattern，最终达到识别图像的目的？ Filter在下图CNN过程中，我们先分析能从Convolution layer的filter能够学到什么？ 每个filter本质上是一组shared weights 的neuron。 因此，定义这组filter的激活程度，即： Degree of the activation of the k-th filter: $a^k=\\sum_{i=1}^{11}\\sum_{j=1}^{11}a_{ij}^{k}$ . 目标是找到使k-th filter激活程度最大的输入image，即 $x^{*}=\\arg \\max _{x} a^{k}$ ，(method :gradient descent). 部分结果如下图： (每一张图都代表一个filter) 上图中，找到使filter激活程度最大的image，即上图中每个filter可以检测一定的条纹，只有当图像中有该条纹，filter（一组neuron）的激活程度（即输出）才能达到最大。 Neuron（Hidden layer）这里的neuron指前馈神经网络中的neuron，如下图的 $a_j$ : 目标：找到使neuron的输出最大的输入image，即： $x^{*}=\\arg \\max _{x} a^{j}$ . 部分结果如下： （每一张图代表一个neuron) 在上图中，感觉输入像一个什么东西吧emmmm。 但和filter学到的相比，neuron学到的不仅是图中的小小的pattern（比如条纹、鸟喙等），neuron学的是看整张图像什么。 Output（Output layer）再用同样的方法，看看输出层的neuron学到了什么，如下图的 $y_i$ ： 在手写数字辨识中 $y_i$ 是数字为 $i$ 的概率，因此目标是：找到一个使输出是数字 $i$ 概率最大的输入image，即： $x^{*}=\\arg \\max _{x} y^{i}$ . 结果如下图： 结果和我们期望相差甚远，根本不能辨别以上图片是某个数字。 这其实也是DNN的一个特点: Deep Neural Networks are Easily Fooled [1]，即NN学到的东西往往和人类学到的东西是不一样的。 CNN所以CNN到底学到了什么？ 上文中，output 学到的都是一团密密麻麻杂乱的像素点，根本不像数字。 但是，再考虑手写数字image的特点：图片中应该有少量模式，大片空白部分。 因此目标改进为： $x^{*}=\\arg \\max {x}\\left(y^{i}+\\sum{i, j}\\left|x_{i j}\\right|\\right)$ 结果如下： （注：图中白色为墨水，黑色为空白） ApplicationDeep DreamCNN exaggerates what it sees. CNN可以夸大图片中他所看到的东西。 比如： 可以把下图 变成下图（emmmm看着有点难受） 附上生成deep dream image的网站[2] . Deep Style[3]Given a photo, make its style like famous paintings. 上图中，用一个CNN学习图中的content，用另一个CNN学习风格图中的style。 再用一个CNN使得输入的图像content像原图，风格像另一张图。 Playing GoCNN 还可以用在下围棋中，如下图，输入是19 * 19的围棋局势（matrix/image），通过CNN，学出下一步应该走哪？ Why CNN playing Go?下围棋满足以下两个property： Some patterns are much smaller than the whole image. （围棋新手，博主只下赢过几次hhh) 如果白棋棋手，看到上图的pattern，上图的白子只有一口气了，被堵住就会被吃掉，那白棋棋手大概率会救那个白子，下在白棋的下方。 Alpha Go uese 5 * 5 for first layer. The same patterns appear in different regions. 但如何解释CNN的另一结构——Max Pooling？ 因为围棋的棋谱matrix不像image的pixel，subsample后，围棋的棋谱就和原棋谱完全不像了。 Alpha Go的论文中：Alpha Go并没有用Max Pooling。 所以，可以根据要训练的东西调整CNN模型。 Speech可以用CNN学习Spectrogram ，即识别出这一时段说的是什么话。 TextCNN还可以用在文本的情感分析中，对句子中每个word embedding后，通过CNN，学习sentence表达的是negative 还是positive还是neutral的情绪。 More（挖坑…生命很漫长，学无止境QAQ） The methods of visualization in these slides： https://blog.keras.io/how-convolutional-neural-networks-see-the-world.html More about visualization： http://cs231n.github.io/understanding-cnn/ Very cool CNN visualization toolkit http://yosinski.com/deepvis http://scs.ryerson.ca/~aharley/vis/conv/ The 9 Deep Learning Papers You Need To Know About https://adeshpande3.github.io/adeshpande3.github.io/The-9-Deep-Learning-Papers-You-Need-To-Know-About.html How to let machine draw an image PixelRNN https://arxiv.org/abs/1601.06759 Variation Autoencoder (VAE) https://arxiv.org/abs/1312.6114 Generative Adversarial Network (GAN) http://arxiv.org/abs/1406.2661 Reference Deep Neural Networks are Easily Fooled： https://www.youtube.com/watch?v=M2IebCN9Ht4 deep dream generator: http://deepdreamgenerator.com/ A Neural Algorithm of Artistic Style: https://arxiv.org/abs/1508.06576","link":"/2020/04/25/CNN/"},{"title":"「机器学习-李宏毅」:Classification-Generative Model","text":"Classification 有Generative Model和Discriminative Model。这篇文章主要讲述了用生成模型来做分类的原理及过程。 What is Classification?分类是什么呢？分类可以应用到哪些场景呢？ Credit Scoring【贷款评估】 Input: income, savings, profession, age, past financial history …… Output: accept or refuse Medical Diagnosis【医疗诊断】 Input: current symptoms, age, gender, past medical history …… Output: which kind of diseases Handwritten character recognition【手写数字辨别】 Input： Output：金 Face recognition 【人脸识别】 Input: image of a face output: person Classification：Example Application【图】 如上图，Pokemon又来啦！ Pokemon有很多属性，比如皮卡丘是电属性，杰尼龟是水属性之类。 关于Pokemon的Classification：Predict the “type” of Pokemon based on the information Input：Information of Pokemon (数值化） Output：the type Training Data: ID在前400的Pokemon Testing Data: ID在400后的Pokemon Classification as Regression?1. 简化问题，只考虑二分类：Class 1 ， Class2。 如果把分类问题当作回归问题，把类别数值化。 在Training中： Class 1 means the target is 1; Class 2 means the target is -1. 在Testing中：如果Regression的函数值接近1，说明是class 1；如果函数值接近-1，说明是class 2. Regression：输入信息只考虑两个特征。 Model：$y=w_1x_1+w_2x_2+b$ 当Training data的分布如上图所示时，得到的（最优函数）分界线感觉很合理。 但当Training data在右下角也有分布时（如右图），训练中为了减少error，训练得到的分界线会变成紫色的那一条。 所以，如果用Regression来做Classification：Penalize to the examples that are “too correct” .[1] 训练中会因为惩罚一些“过于正确”（即和我们假定的target离太远）的example，得到的最优函数反而have bad performance. 2. 此外，如果用Regression来考虑多分类。 Multiple class: Class 1 means the target is 1; Class 2 means the target is 2; Class 3 means the target is 3…… 如果用上面这种假设，可以认为Class 3和Class 2 的关系更近，和Class 1的关系更远一些。但实际中，可能这些类别have no relation。 Classification: Ideal Alternatives在上面，我们假设二元分类每一个类别都有一个target，结果不尽人意。 如上图所示，将模型改为以上形式，也可以解决分类问题。（挖坑）[2] Generative Model(生层模型)Estimate the Probabilities用概率的知识来考虑分类这个问题，如下图所示，有两个两个类别，C1和C2。 在Testing中，如果任给一个x，属于C1的概率是（贝叶斯公式） $$ P\\left(C_{1} | x\\right)=\\frac{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)}{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)+P\\left(x | C_{2}\\right) P\\left(C_{2}\\right)} $$ 所以在Training中知道这些： $P(C_1),P(x|C_1),P(C_2),P(x|C_2)$ P(C1)和P(C2)很容易得知。 而P(x|C1)和P(x|C2)的概率应该如何得知呢？ 如果能假设：类别是C1中的变量x服从某种分布，如高斯分布等，即可以得到任意P(x|C1)的值。 所以Generative Model：是对examples假设一个分布模型，在training中调节分布模型的参数，使得examples出现的概率最大。（极大似然的思想） Prior Probabilities（先验概率）先只考虑Water和Normal两个类别。 先验概率：即通过过去资料分析得到的概率。 在Pokemon的例子中，Training Data是ID&lt;400的水属性和一般属性的Pokemon信息。 Training Data：79 Water，61 Normal。 得到的先验概率 P(C1)=79/(79+61)=0.56, P(C2)=61/(79+61)=0.44。 Probability from Class先只考虑Defense和SP Defense这两个feature。 如果不考虑生成分布模型，在testing中直接计算P(x|Water)的概率，如下图右下角的那只龟龟，在training data中没有出现过，那值为0吗？显然不对。 假设：上图中water type的examples是从Gaussian distribution（高斯分布）中取样出来的。 因此在training中通过training data得到最优的Gaussian distribution的参数，计算样本中没有出现过的P(x|Water)也就迎刃而解了。 Gaussian Distribution多维的高斯分布（高斯分布就是正态分布啦）的联合概率密度： $$ f_{\\mu, \\Sigma}(x)=\\frac{1}{(2 \\pi)^{D / 2}} \\frac{1}{|\\Sigma|^{1 / 2}} \\exp \\left\\{-\\frac{1}{2}(x-\\mu)^{T} \\Sigma^{-1}(x-\\mu)\\right\\} $$ D: 维数 $\\mu$ : mean $\\Sigma$ :covariance matrix(协方差矩阵) 协方差： $ cov(X,Y)=E[[X-E(X)][Y-E(Y)]]=E(XY)-E(X)E(Y)$ 具体协方差性质，查阅概率论课本吧。 x: vector,n维随机变量 高斯分布的性质只和 $\\mu$ 和 $\\Sigma$ 有关。 $\\Sigma$ 一定时，$\\mu$ 不同，如下图： $\\mu$ 一定， $\\Sigma$ 不同时，如下图： Maximum Likelihood（极大似然）样本分布如下图所示，假设这些样本是从Gaussian distribution中取样，那如何在训练中得到高斯分布的 $\\mu$ 和 $\\Sigma$ 呢？ 极大似然估计。 考虑Water，有79个样本，估计函数 $L(\\mu, \\Sigma)=f_{\\mu, \\Sigma}\\left(x^{1}\\right) f_{\\mu, \\Sigma}\\left(x^{2}\\right) f_{\\mu, \\Sigma}\\left(x^{3}\\right) \\ldots \\ldots f_{\\mu, \\Sigma}\\left(x^{79}\\right)$ 极大似然估计，即找到 $f_{\\mu, \\Sigma}(x)=\\frac{1}{(2 \\pi)^{D / 2}} \\frac{1}{|\\Sigma|^{1 / 2}} \\exp \\left\\{-\\frac{1}{2}(x-\\mu)^{T} \\Sigma^{-1}(x-\\mu)\\right\\}$ 中的 $\\mu$ 和$\\Sigma$ 使得估计函数最大（使得取出这些样本的概率最大化）。 $\\mu^{*}, \\Sigma^{*}=\\arg \\max _{\\mu, \\Sigma} L(\\mu, \\Sigma)$ 求导计算（过于复杂，但也不是不能做是吧） 背公式[3] $\\mu^{*}=\\frac{1}{79} \\sum_{n=1}^{79} x^{n} \\qquad \\Sigma^{*}=\\frac{1}{79} \\sum_{n=1}^{79}\\left(x^{n}-\\mu^{*}\\right)\\left(x^{n}-\\mu^{*}\\right)^{T}$ 得到Water和Normal的高斯分布，如下图: Do Classification: different $\\Sigma$TestingTesting： $P\\left(C_{1} | x\\right)=\\frac{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)}{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)+P\\left(x | C_{2}\\right) P\\left(C_{2}\\right)}$ P(x|C1)由训练得出的Water的高斯分布计算出，P(x|C2)由Normal的高斯分布计算出。（如下图，过于难打） 如果P(C1|x)&gt;0.5，说明x 属于Water(Class 1)。 Results如果只考虑两个feature（Defense和SP Defense），下图是testing data的样本图，蓝色属于Water，红色属于Normal。 用训练得出的模型，Testing Data: 47% accuracy。（结果如下图） 如果考虑全部features(7个)，重新训练出的模型，结果：Testing Data：54% accuracy。（结果如下图） 结果并不好。参数过多，模型过于复杂，有些过拟合了。 Modifying Model：same $\\Sigma$模型中的参数有两个的Gaussian Distribution中的 $\\mu^$ 和 $\\Sigma^$ ，其中协方差矩阵的大小等于feature的平方，所以让不同的class share 同一个 $\\Sigma$ ，以此来减少参数，简化模型。 极大似然估计的估计函数： $$ L\\left(\\mu^{1}, \\mu^{2}, \\Sigma\\right)=f_{\\mu^{1}, \\Sigma}\\left(x^{1}\\right) f_{\\mu^{1}, \\Sigma}\\left(x^{2}\\right) \\cdots f_{\\mu^{1}, \\Sigma}\\left(x^{79}\\right)\\times f_{\\mu^{2}, \\Sigma}\\left(x^{80}\\right) f_{\\mu^{2}, \\Sigma}\\left(x^{81}\\right) \\cdots f_{\\mu^{2}, \\Sigma}\\left(x^{140}\\right) $$ 公式推导:[3] $\\mu$ 的公式不变。 $\\Sigma=\\frac{79}{140} \\Sigma^{1}+\\frac{61}{140} \\Sigma^{2}$ ,即是原 $\\Sigma^1\\ \\Sigma^2$的加权平均。 Results当只考虑两个features，用同样的协方差参数，结果如下图： 可以发现，用了同样的协方差矩阵参数后，边界变成了线性的，所以这也是一个线性模型。 再考虑7个features，用同样的协方差矩阵参数，模型也是线性模型，但由于在高维空间，人无法直接画出其boundary，这也是机器学习的魅力所在，能解决一些人无法解决的问题。 结果：从之前的54% accuracy增加到 73% accurancy. 结果明显变好了。 SummaryThree Steps： Function Set（Model）： Goodness of a function: The mean µ and convariance $\\Sigma$ that maximizing the likelihood(the probability of generating data) Find the best function:easy(公式) Appendix为什么要选择Gaussian DistributionYou can always use the distribution you like. 可以选择你喜欢的任意分布，t分布，开方分布等。 （老师说：如果我选择其他分布，你也会问这个问题，哈哈哈） Naive Bayes ClassifierIf you assume all the dimensions are independent, then you are using Naive Bayes Classifier. 如果假设features之间互相独立， $P\\left(x | C_{1}\\right)=P\\left(x_{1} | C_{1}\\right) P\\left(x_{2} | C_{1}\\right) \\quad \\ldots \\ldots \\quad P\\left(x_{k} | C_{1}\\right) $ 。 xi是x第i维度的feature。 对于每一个 P(xi|C1)，可以假设其服从一维高斯分布。如果是binary features（即feature取值只有两个），也可以假设它服从Bernoulli distribution(贝努利分布)。 Posterior Probability（后验概率）Posterior Probability后验概率，即使用贝叶斯公式，已知结果，寻找最优可能导致它发生的原因。 对 $P\\left(C_{1} | x\\right)=\\frac{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)}{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)+P\\left(x | C_{2}\\right) P\\left(C_{2}\\right)}$ 进行处理。 得到： $$ \\begin{equation} \\begin{aligned} P\\left(C_{1} | x\\right)&=\\frac{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)}{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)+P\\left(x | C_{2}\\right) P\\left(C_{2}\\right)}\\\\ &=\\frac{1}{1+\\frac{P\\left(x | C_{2}\\right) P\\left(C_{2}\\right)}{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)}}\\\\&=\\frac{1}{1+\\exp (-z)} =\\sigma(z) \\qquad(z=\\ln \\frac{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)}{P\\left(x | C_{2}\\right) P\\left(C_{2}\\right)} \\end{aligned} \\end{equation} $$ Worning of Math $z=\\ln \\frac{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)}{P\\left(x | C_{2}\\right) P\\left(C_{2}\\right)}=\\ln \\frac{P\\left(x | C_{1}\\right)}{P\\left(x | C_{2}\\right)}+\\ln \\frac{P\\left(C_{1}\\right)}{P\\left(C_{2}\\right)}$ $\\ln \\frac{P\\left(C_{1}\\right)}{P\\left(C_{2}\\right)}=\\frac{\\frac{N_{1}}{N_{1}+N_{2}}}{\\frac{N_{2}}{N_{1}+N_{2}}}=\\frac{N_{1}}{N_{2}}$ $P\\left(x | C_{1}\\right)=\\frac{1}{(2 \\pi)^{D / 2}} \\frac{1}{|\\Sigma 1|^{1 / 2}} \\exp \\left\\{-\\frac{1}{2}\\left(x-\\mu^{1}\\right)^{T}\\left(\\Sigma^{1}\\right)^{-1}\\left(x-\\mu^{1}\\right)\\right\\}$ $P\\left(x | C_{2}\\right)=\\frac{1}{(2 \\pi)^{D / 2}} \\frac{1}{\\left|\\Sigma^{2}\\right| 1 / 2} \\exp \\left\\{-\\frac{1}{2}\\left(x-\\mu^{2}\\right)^{T}\\left(\\Sigma^{2}\\right)^{-1}\\left(x-\\mu^{2}\\right)\\right\\}$ $\\ln \\frac{\\left|\\Sigma^{2}\\right|^{1 / 2}}{\\left|\\Sigma^{1}\\right|^{1 / 2}}-\\frac{1}{2}\\left[\\left(x-\\mu^{1}\\right)^{T}\\left(\\Sigma^{1}\\right)^{-1}\\left(x-\\mu^{1}\\right)-\\left(x-\\mu^{2}\\right)^{T}\\left(\\Sigma^{2}\\right)^{-1}\\left(x-\\mu^{2}\\right)\\right]$ $\\left(x-\\mu^{1}\\right)^{T}\\left(\\Sigma^{1}\\right)^{-1}\\left(x-\\mu^{1}\\right)=x^{T}\\left(\\Sigma^{1}\\right)^{-1} x-2\\left(\\mu^{1}\\right)^{T}\\left(\\Sigma^{1}\\right)^{-1} x+\\left(\\mu^{1}\\right)^{T}\\left(\\Sigma^{1}\\right)^{-1} \\mu^{1}$ $\\left(x-\\mu^{2}\\right)^{T}\\left(\\Sigma^{2}\\right)^{-1}\\left(x-\\mu^{2}\\right)=x^{T}\\left(\\Sigma^{2}\\right)^{-1} x-2\\left(\\mu^{2}\\right)^{T}\\left(\\Sigma^{2}\\right)^{-1} x+\\left(\\mu^{2}\\right)^{T}\\left(\\Sigma^{2}\\right)^{-1} \\mu^{2}$ $\\begin{aligned} z=& \\ln \\frac{\\left|\\Sigma^{2}\\right|^{1 / 2}}{\\left|\\Sigma^{1}\\right|^{1 / 2}}-\\frac{1}{2} x^{T}\\left(\\Sigma^{1}\\right)^{-1} x+\\left(\\mu^{1}\\right)^{T}\\left(\\Sigma^{1}\\right)^{-1} x-\\frac{1}{2}\\left(\\mu^{1}\\right)^{T}\\left(\\Sigma^{1}\\right)^{-1} \\mu^{1} \\\\ &+\\frac{1}{2} x^{T}\\left(\\Sigma^{2}\\right)^{-1} x-\\left(\\mu^{2}\\right)^{T}\\left(\\Sigma^{2}\\right)^{-1} x+\\frac{1}{2}\\left(\\mu^{2}\\right)^{T}\\left(\\Sigma^{2}\\right)^{-1} \\mu^{2}+\\ln \\frac{N_{1}}{N_{2}} \\end{aligned}$ 简化模型后， $\\Sigma^1=\\Sigma^2=\\Sigma$ : $$ z=\\left(\\mu^{1}-\\mu^{2}\\right)^{T} \\Sigma^{-1} x-\\frac{1}{2}\\left(\\mu^{1}\\right)^{T} \\Sigma^{-1} \\mu^{1}+\\frac{1}{2}\\left(\\mu^{2}\\right)^{T} \\Sigma^{-1} \\mu^{2}+\\ln \\frac{N_{1}}{N_{2}} $$ 令 $w^T=\\left(\\mu^{1}-\\mu^{2}\\right)^{T} \\Sigma^{-1} \\qquad b=-\\frac{1}{2}\\left(\\mu^{1}\\right)^{T} \\Sigma^{-1} \\mu^{1}+\\frac{1}{2}\\left(\\mu^{2}\\right)^{T} \\Sigma^{-1} \\mu^{2}+\\ln \\frac{N_{1}}{N_{2}}$ 当简化模型后，z是线性的，这也是为什么在之前的结果中边界是线性的原因。 最后模型变成这样： $P\\left(C_{1} | x\\right)=\\sigma(w \\cdot x+b)$ . 在生成模型中，我们先估计出 $\\mu_1\\ \\mu_2\\ N_1\\ N_2\\ \\Sigma$ 的值，也就得到了 $w\\ b$ 的值。 那，我们能不能跳过 $\\mu_1\\ \\mu_2\\ N_1\\ N_2\\ \\Sigma$ ，直接估计 $w\\ b$ 呢？ 在下一篇博客[4]中会继续Classification。 Reference Classification as Regression: Bishop, P186. 挖坑：Classification：Perceptron，SVM. Maximum likelihood solution：Bishop chapter4.2.2","link":"/2020/03/21/Classification1/"},{"title":"「机器学习-李宏毅」:Classification-Logistic Regression","text":"在上篇文章中，讲解了怎么用Generative Model做分类问题。这篇文章中，讲解了做Classification的另一种Discriminative的方式，也就是Logistic Regression。文章主要有两部分：第一部分讲解了Logistic Regression的三个步骤。第二个部分讲解了multi-class多分类的三个步骤，以及softmax是如何操作的。 Logistic RegressionStep1: Function Set在文章末尾，我们得出 $P_{w, b}\\left(C_{1} | x\\right)=\\sigma(w\\cdot x+b)$ 的形式，想跳过找 $\\mu_1,\\mu_2,\\Sigma$ 的过程，直接找 $w,b$ 。 因此Function Set: $f_{w, b}(x)=P_{w, b}\\left(C_{1} | x\\right)$ 。值大于0.5，则属于C1类，否则属于C2类。 Step2: Goodness of a Function使用极大似然的思想（在前一篇机率模型/生成模型中有讲） 估计函数是 ：$L(w, b)=f_{w, b}\\left(x^{1}\\right) f_{w, b}\\left(x^{2}\\right)\\left(1-f_{w, b}\\left(x^{3}\\right)\\right) \\cdots f_{w, b}\\left(x^{N}\\right)$ 目标： $ w^{*}, b^{*}=\\arg \\max _{w, b} L(w, b)$ 由于在之前的Regression中，我们都是找极小值点，为了方便处理，将估计函数转换为如下形式的损失函数： $$ \\begin{equation} \\begin{aligned} Loss &= -\\ln L(w, b)=\\ln f_{w, b}\\left(x^{1}\\right)+\\ln f_{w, b}\\left(x^{2}\\right)+\\ln \\left(1-f_{w, b}\\left(x^{3}\\right)\\right) \\cdots \\\\ &=\\sum_{n}-\\left[\\hat{y}^{n} \\ln f_{w, b}\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right)\\right] \\end{aligned} \\end{equation} $$ 目标 ： $w^{*}, b^{*}=\\arg \\min _{w, b} L(w, b)$ Cross entropy（交叉熵） 上式中的 $\\left[\\hat{y}^{n} \\ln f_{w, b}\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right)\\right]$ 其实是两个Bernoulli distribution的交叉熵。 交叉熵是什么？ 简单来说，交叉熵是评估两个distribution 有多接近。所以当两个分布的交叉熵为0时，表明这两个分布一模一样。 对于 $\\hat{y}^{n} \\ln f_{w, b}\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right)$ ： Distribution p: p(x = 1) = $\\hat{y}^n$ ; p( x = 0 ) = 1 - $\\hat{y}^n$ Distribution q: q(x = 1 ) = $f(x^n)$ ; q(x = 0 ) = 1 - $f(x^n)$ 交叉熵 $H(p,q)=-\\Sigma_xp(x)\\ln(q(x))$ 因此，这个损失函数的表达式其实也是输出分布和target分布的交叉熵，即： $L(f)=\\sum_{n} C\\left(f\\left(x^{n}\\right), \\hat{y}^{n}\\right)$ （ $C\\left(f\\left(x^{n}\\right), \\hat{y}^{n}\\right)=-\\left[\\hat{y}^{n} \\ln f\\left(x^{n}\\right)+\\left(1-\\hat{y}^{n}\\right) \\ln \\left(1-f\\left(x^{n}\\right)\\right)\\right]$ ） 和Linear Regression不同，为什么Logistic Regression不用square error，而要使用cross entropy。 在1.4小节会给出解释。 Step3: Find the best function在第三步，同样使用Gradient来寻找最优函数。 推导过程： $\\left.\\frac{-\\ln L(w, b)}{\\partial w_{i}}=\\sum_{n}-\\left[\\hat{y}^{n} \\frac{\\ln f_{w, b}\\left(x^{n}\\right)}{\\partial w_{i}}+\\left(1-\\hat{y}^{n}\\right) \\frac{\\ln \\left(1-f_{w, b}\\left(x^{n}\\right)\\right.}{\\partial w_{i}}\\right)\\right]$ $\\frac{\\partial \\ln f_{w, b}(x)}{\\partial w_{i}}=\\frac{\\operatorname{\\partial\\ln} f_{w, b}(x)}{\\partial z} \\frac{\\partial z}{\\partial w_{i}}$ $\\frac{\\partial \\ln \\sigma(z)}{\\partial z}=\\frac{1}{\\sigma(z)} \\frac{\\partial \\sigma(z)}{\\partial z}=\\frac{1}{\\sigma(z)} \\sigma(z)(1-\\sigma(z))$ $\\frac{\\partial z}{\\partial w_{i}}=x_{i}$ $\\frac{\\partial \\ln \\left(1-f_{w, b}(x)\\right)}{\\partial w_{i}}=\\frac{\\operatorname{\\partial\\ln}\\left(1-f_{w, b}(x)\\right)}{\\partial z} \\frac{\\partial z}{\\partial w_{i}}$ $\\frac{\\partial \\ln (1-\\sigma(z))}{\\partial z}=-\\frac{1}{1-\\sigma(z)} \\frac{\\partial \\sigma(z)}{\\partial z}=-\\frac{1}{1-\\partial(z)} \\sigma(z)(1-\\sigma(z))$ $\\frac{\\partial z}{\\partial w_{i}}=x_{i}$ $\\frac{\\partial \\sigma(z)}{\\partial z}=\\sigma(z)\\cdot(1-\\sigma(z))$ 注：$f_{w, b}(x)=\\sigma(z)$ ; $z=w \\cdot x+b=\\sum_{i} w_{i} x_{i}+b$ $$ \\begin{equation} \\begin{aligned} \\frac{-\\ln L(w, b)}{\\partial w_{i}}&=\\sum_{n}-\\left[\\hat{y}^{n}\\left(1-f_{w, b}\\left(x^{n}\\right)\\right) x_{i}^{n}-\\left(1-\\hat{y}^{n}\\right) f_{w, b}\\left(x^{n}\\right) x_{i}^{n}\\right] \\\\&=\\sum_{n}-\\left(\\hat{y}^{n}-f_{w, b}\\left(x^{n}\\right)\\right) x_{i}^{n} \\end{aligned} \\end{equation} $$ 因此Logistic Regression的损失函数的导数和Linear Regression的一样。 迭代更新： $w_{i} \\leftarrow w_{i}-\\eta \\sum_{n}-\\left(\\hat{y}^{n}-f_{w, b}\\left(x^{n}\\right)\\right) x_{i}^{n}$ 与Linear Regression 的对比 如图所示。 If : Logistic + Square Error前面一小节我们提到，在Logistic Regression中使用cross entropy判别一个函数的好坏,那为什么不使用square error来judge the goodness？ 如果使用 Square Error的方法，步骤如下： 来看Step 3: 损失函数的导数是 $2\\left(f_{w, b}(x)-\\hat{y}\\right) f_{w, b}(x)\\left(1-f_{w, b}(x)\\right) x_{i}$ 考虑 $\\hat{y}^n=1$ （即我们的target是1）： 如果 $f_{w,b}(x^n)=1$ , 即预测值接近 target, 算出来的 $\\partial{L}/\\partial{w_i}=0$ 是期望的。 如果 $f_{w,b}(x^n)=0$ , 即预测值原理 target, 算出来的 $\\partial{L}/\\partial{w_i}=0$ 是不期望的。 同理，当考虑 $\\hat{y}^n=0$ 情况时，也是如此。 更直观的看： 上图中，画出了两种损失函数的平面，中心的最低点是我们的target。 但在Square Error中，远离target的蓝色点，也处在很平坦的位置，其导数小，参数的更新会很慢。 因此在Cross Entropy中，离target越远，其导数更大，更新更快。 所以Cross Entropy的效果比Square Error更快，效果更好。 Discriminative V.S. Generative这篇文章中的Logistic Regression是Discriminative Model。 上篇文章中Classification是Generative Model。 有什么区别呢？ 上图中，Generative Model做了假设（脑补），假设它是 Gaussian Distribution，假设它是Bernoulli Distribution。然后去找这些分布的参数，在求出 $w,b$。 而在Discriminative Model中，没有做任何假设，直接找 $w,b$ 参数。 所以，这两种Model经过training找出来的参数一样吗？ 答案是不一样的。 The same model(function set), but different function is selected by the same training data. 在上篇Pokemon的例子中，比较两种方法的结果差异。 可见，在Pokemon的例子总，Discriminative的效果比Generative的效果好一些。 但是Generative Model就不好吗？ Benefit of generative model With the assumption of probability distribution, less training data is needed. 【训练生成模型所需数据更少】 With the assumption of probability distribution, more robust to the noise. 【生成模型对noise data更兼容】 Priors and class-dependent probabilities can be estimated from different sources. 【生成模型中的 先验概率Priors 和 基于类别的分布概率不同】 比如，做语音辨识系统，整个系统是generative的。 因为Prior（某一句话的概率）并不需要从data中知道，可以直接在网络上爬虫统计。 而class-dependent probabilities（这段语音是这句话的概率）需要data进行训练才能得知。 Multi-class classificationsoftmax 假设有三个类别：C1、C2、C3 。模型已经得到，参数分别是 w、b。 对于输入x, 判断x属于哪一个类别。 通过每个类别的 w、b求出 $z^i=w^i\\cdot x+b_i$ Softmax的步骤： exponential：每个z值得到 $=e^z$ . sum：将指数化后的值加起来$=\\Sigma_{j=1}^3e^{z_j}$ output: 每个类别的输出 $y_i=e^{z_1}/\\Sigma_{j=1}^3e^{z_j}$ ，即x属于类别i的概率。 求出的 $1&gt;y_i&gt;0$ 且 $\\Sigma_iy_i=1$ 。 通过Softmax，得到 $y_i=P(C_i|x)$ 。 Steps（手写笔记，略倾斜，原来不切一切还不知道自己歪的这么厉害 泪） Step 1: Step 2: Step 3: 使用Stochastic Gradient（即每个样本更新一次）的话： data: [x, $\\hat{y}$ ] , $\\hat{y}_i=1$ 更新 $w^j$ : $j=i$ : $w^j \\leftarrow w^j-\\eta\\cdot (y_i-1)\\cdot x$ $j\\neq i$ : $w^j \\leftarrow w^j-\\eta\\cdot y_i\\cdot x$ (下次一定，笔记写直一点！) 更为规范的推导见[1] Limitation of Logistic Regression 对于如上情况，Logistic Regression并不能进行分类，因为他的boundary 应该是线性的。 Feature Transforming如果对feature做转换后，就可以用Logistic Regression处理。 重定义feature， $x_1’$ :定义为到[0,0]的距离， $x_2’$ :定义为到[1,1]的距离。 于是图变成下图，即可用Logistic Regression进行分类。 但这样的做法，就不像人工智能了，因为Feature Transformation需要人来设计，而且较难设计。 Cascading logistic regression models另一种做法是，将logistic regression连接起来。 上图中，左边部分的两个logistic regression就相当于在做Feature Transformation，右边部分相当于在做Classification。 而通过这种形式，将多个model连接起来，也就是大热的Neural Network。 Reference Multi-class Classification推导：Bishop，P209-210","link":"/2020/04/01/Classification2/"},{"title":"「机器学习-李宏毅」：Deep Learning-Introduction","text":"这篇文章中，介绍了Deep Learning的一般步骤。 Up and downs of Deep Learning 1958: Perceptron (linear model) 1969: Perceptron has limitation 1980s: Multi-layer perceptron ​ Do not have significant difference from DNN today 1986: Backpropagation ​ Usually more than 3 hidden layers is not helpful 1989: 1 hidden layer is “good enough”, why deep? 2006: RBM initialization (breakthrough) 2009: GPU 2011: Start to be popular in speech recognition【语音辨识】 2012: win ILSVRC image competition 【图像识别】 Step 1: Neural Network在将Regression 和 Classification时，Step 1 是确定一个function set。 在Deep Learning中，也是相同的，只是这里的function set就是一个neural network的结构。 上图中，一个Neuron就是如上图所示的一个unit，neuron之间不同的连接方式构成不同的Neural Network。 Fully Connect Feedforward Network 这是一个Fully Connect Feedforward Network【全连接反馈网络】，其中每个neuron的activation function都是一个sigmod函数。 为什么说neural network其实就是一个function呢？上面两张图中，输入是一个vector，输出也是一个vector，可以用下面函数来表示。 $$ f\\left(\\left[\\begin{array}{c}1 \\\\ -1\\end{array}\\right]\\right)=\\left[\\begin{array}{c}0.62 \\\\ 0.83\\end{array}\\right] f\\left(\\left[\\begin{array}{l}0 \\\\ 0\\end{array}\\right]\\right)=\\left[\\begin{array}{l}0.51 \\\\ 0.85\\end{array}\\right] $$ 上图为全连接网络的一般形式，第一层是Input Layer，最后一层是Output Layer，中间的其他层称为Hidden Layer。 而Deep Learning中的Deep的含义就是Many hidden layers的意思。 Matrix Operation 上图的全连接网络中，第一个hidden layer的输出可以写成矩阵和向量的形式： $$ \\sigma\\left(\\left[\\begin{array}{cc}1 & -2 \\\\ -1 & 1\\end{array}\\right]\\left[\\begin{array}{c}1 \\\\ -1\\end{array}\\right]+\\left[\\begin{array}{c}1 \\\\ 0\\end{array}\\right]\\right)=\\left[\\begin{array}{c}0.98 \\\\ 0.12\\end{array}\\right] $$ 更为一般的公式，用W表示权重，b代表bias，a表示hidden layer的输出。输出vector y可以写成 $y = f(x)$ 的形式，即： $y= f(x)=$ 转换为矩阵运算的形式，就可以使用并行计算的硬件技术（GPU）来加速矩阵运算，这也是为什么用GPU来训练Neural Network 更快的原因。 Output Layer在 Logistic Regression中第4节讲到Logistic Regression有局限，消除局限的一种方法是Feature Transformation。 但是Feature Transformation需要人工设计，不太“机器学习”。 在下图全连接图中，把Output Layer换成一个Multi-class Classifier（SoftMax），而其中Hidden Layers的作用就是Feature extractor，从feature x提取出新的feature，也就是 output layer的输入。 这样就不需要人工设计Feature Transformation/Feature engineering，可以让机器自己学习：如何将原来的feature转换为更好分类的feature。 Handwriting Digit Recognition 在手写数字辨别中，输出是一个16*16的image（256维的vector），输出是一个10维的vector，每一维表示是该image是某个数字的概率。 在手写数字辨别中，需要设计neural network的结构来提取输入的256维feature。 Step 2: Goodness of function之前我们已经使用过的最小二乘法和交叉熵作为损失函数。 一般在Neural Network中，使用output vector 和target vector的交叉熵作为Loss。 Step 3: Pick the best function在NN中，也使用Gradient Descent。 但是，Deep Neural Network中，参数太多了，计算结构也很复杂。 Backpropagation：an efficient way to compute $\\partial{L}/\\partial{w}$ in neural network. Backpropagation本质也是Gradient Descent，只是一种更高效进行Gradient Descent的算法。 在很多 toolkit（TensorFlow，PyTorch ，Caffe等）中都实现了Backpropgation。 Backpropagation部分，见下一篇博客。 Reference","link":"/2020/04/18/DL-introdunction/"},{"title":"「Cryptography-Dan」：Introduction","text":"本系列是学习Dan Boneh教授的Online Cryptography Course。 这是Dan教授的第一讲：对密码学的一些Introduction。 What is cryptography?Crypto core：安全通信 Secret key establishment (密钥的建立)： Alice 和 Bob 会得到一个shared secret key，而且Alice 知道她是在和Bob通信，Bob也知道他是在和Alice通信。而attacker不能从通信中获取key。 Secure communicati （安全通信）： 在通信中，Alice、Bob用k将信息加密，保证了通信的confidentiality（机密性）；同时attacker也无法篡改通信的信息，保证了通信的integrity（完整性）。 Crypto can do much more密码学除了能保证安全通信，密码学还能做很多其他的事。 Digital signature &amp; Anonymous Digital signatures（数字签名）： 现实中，人们对不同的文档进行签名，虽然是不同的文档，但是签名的字是相同的。 如果这应用在网络的文档签名中，这将是很危险的。攻击者只需要将签名进行复制、粘贴，就可以将你的签名签在你并不想签的文档中。 数字签名的主要思想：数字签名其实是代签内容的函数值，所以如果攻击者只是复制数字签名（原签名的函数值），那么攻击者得到的数字签名也是无效的（函数值不同）。 在后面的课程系列中会详细讲这部分的内容。[1] Anonymous communication（匿名通信）： 匿名通信的实现，有Mix network （wiki详细介绍）协议，这是一种路由协议，通过使用混合的代理服务器链来实现难以追踪的通信。 通过这些代理的不断加密解密可以实现： Bob不知道与之通信的是Alice。 代理也不知道是Alice和Bob在通信。 双向通信：虽然Bob不知与之通信的是Alice，但也能respond。 Anonymous digital cash（匿名数字现金）： 现实中，我们可以去超市花掉一元钱，而超市不知道我是谁。 在网络中，如果Alice想去网上商店花掉数字现金一元钱，网上商店可以不知道是谁花掉的这一元钱吗？ 这就是匿名数字现金需要解决的问题： 可以在匿名的情况下花掉数字现金吗？ 如果可以，当Alice将这一元钱复制多次（数字现金都是数据串），得到了三元钱，再去把它花掉，由于匿名的原因，没人知道是谁花掉的这三元钱，商店找不到责任人。 这是匿名数字现金需要解决的第二个问题： 如何防止 double spending情况的发生？ 可以用这样的机制去实现匿名数字现金：当Alice花费这一块 once时，系统保证Alice的匿名性；但当Alice花费这一块 more than once ,系统立即揭露Alice的全部信息。 Protocols在介绍什么是Protocols之前，先介绍两种应用场景。 Elections 有5个人要进行投票选举0和1号候选人，但是需要保证：每个人除了知道自己的投票结果，互相不知道其他人的投票情况。在这种情况下怎么知道最后的winner是谁吗？ 如上图，可以引入一个第三方——election center，第三方验证每一个人只能投一次，最后统计票数决策出最后的winner。 Private auctions 介绍一种拍卖机制，Vickery auction：对一个拍卖品，每个投标者在不知道其他人投标价格的情况下进行投标，最后的acution winner： highest bidder &amp; pays 2nd highers bid。即是标价最高者得标，但他只需要付第二高的标价。 所以public知道的信息只有：中标者和第二高投标者的标价。 需要实现这种机制，也可以引入一个第三方——auction center。 但是引入第三方真的安全吗？安全第三方也不安全。 再看上面那个Election的例子，如果把上面四个人的投票情况作为输入，第三方的任务其实是输出一个函数 $f(x_1,x_2,x_3,x_4)$ 而不公开其他信息。 因为安全第三方也许并不安全，所以如果去掉第三方，上面四个人遵从某种协议，相互通信，最后能否得出这个 $f(x_1,x_2,x_3,x_4)$ 这个结果函数，而不透露其投票信息？ 答案是 “Yes”。 有一个惊人的定理：任何能通过第三方做到的事，也能不通过第三方做到。 Thm: anythong that can done with trusted auth. can also be done without. 怎么做到？答案是 Secure multi-party computation（安全多方计算）。 挖坑博文：姚氏百万富翁问题[2] Crypto magic Privately outsourcing computation (安全外包计算) Alice想要在Google服务器查询信息，为了不让别人知道她查询的是什么，她把search query进行加密。 Google服务器接收到加密的查询请求，虽然Google不知道她实际想查询什么信息，但是服务器能根据E[query]返回E[results]。 最后Alice将收到的E[results]解密，得到真正的results。 这就是安全外包计算的简单过程：Encryption、Search、Decryption。 Zero knowl（proof of knowledge) (零知识证明)： Alice 知道p、q(两个1000位的质数)相乘等于N。 Bob只知道N的值，不知道具体的p、q值。 Alice 给 Bob说她能够分解数N，但她不用告诉Bob N的具体因子是什么，只需要证明我能分解N，证明这是我的知识。 最后Bob知道Alice能够分解N，但他不知道怎么分解（也就是不知道N的因子到底是什么）。 A rigorous science在密码学的研究中，通常是这样的步骤： Precisely specify threat model. 准确描述其威胁模型或为达到的目的。比如签名的目的：unforgeable（不可伪造）。 Propose a construction. Prove that breaking construction under threat mode will solve an underlying hard problem. 证明攻击者攻击这个系统必须解决一个很难的问题（大整数分解问题之类的NP问题）。 这样也就证明了这个系统是安全的。 HistorySubstitution cipher（替换）what is it 替换密码很好理解，如上图的这种替换表（key）。 比较historic的替换密码——Caesar Cipher（凯撒密码），凯撒密码是一种替换规则：向后移三位，因此也可以说凯撒密码没有key。 the size of key space用$\\mathcal{K}$ （花体的K）来表示密钥空间。 英语字母的替换密码，易得密钥空间的大小是 $|\\mathcal{K}|=26!\\approx2^{88}$ （即26个字母的全排列）。 这是一个就现在而言也就比较perfect的密钥空间。 但替换密码也很容易被破解。 how to break it问：英语文本中最commom的字母是什么？ 答：“E” 在英语文本（大量）中，每个字母出现的频率并不是均匀分布，我们可以利用一些最common的字母和字母组合来破解替换密码。 Use frequency of English letters. Dan教授统计了标准文献中字母频率： “e”: 12.7% , “t”: 9.1% , “a” : 8.1%. 统计密文中（大量）出现频率最高、次高、第三高的字母，他们的明文也就是e、t、a。 Use frequency of pairs of letters (diagrams).（二合字母） 频率出现较高的二合字母：”he”, “an”, “in” , “th” 也能将h, n,i等破解出。 trigrams（继续使用三合字母） ……直至全部破解 因此substitution cipher是CT only attack！（惟密文攻击：仅凭密文就可以还原出原文） Vigener cipherEncryption 加密过程如上图所示： 密钥是 “CRYPTO”, 长度为6，将密钥重复书写直至覆盖整个明文长度。 将密钥的字母和对应的明文相加模26，得到密文。 Decryption解密只需要将密文减去密钥字母，再模26即可。 How to break it破解方法和替换密码类似，思想也是使用字母频率来破解。 这里分两种情况讨论： 第一种：已知密钥长度 破解过程： 将密文按照密钥长度分组，按照图中的话，6个一组。 统计每组的的第一个位置的字母出现频率。 假设密文中第一个位置最common的是”H” 密钥的第一个字母是：”H”-“E”=”C” 统计剩下位置的字母频率，直至完全破解密钥。 第二种：未知密钥长度 未知密钥长度，只需要依次假设密钥长度是1、2、3…，再按照第一种情况破解，直至破解情况合理。 Rotor MachinesRotor: 轴轮。 所以这种密码的加密核心是：输入明文字母，轴轮旋转一定角度，映射为另一字母。 single rotor 早期的是单轴轮，rotor machine的密钥其实是图右中间那个圆圆的可以旋转的柱子。 图左是变动的密钥映射表。 变动过程： 第一次输入A，密文是K。 轴轮旋转一个字母位：看图中E，从最下到最上（一个圈，只相隔一位）。 所以第二次再输入A，密文是E。 …… Most famous ：the Enigma Enigma machine是二战时期纳粹德国使用的加密机器，因此完全破解了Enigma是盟军提前胜利的关键。 左图中可以看出Enigma机器中是有4个轴轮，每个轴轮都有自己的旋转字母位大小，因此密钥空间大小是 $|\\mathcal{K}|=26^4\\approx2^{18}$ (在plugboard中，实际是 $2^{36}$)。 密钥空间很小，放在现在很容易被暴力破解。 plugboard 允许操作员重新配置可变接线，实现两个字母的交换。plugboard比额外的rotor提供了更多的加密强度。 对于Enigma machine的更多的具体介绍可以戳Enigma machine 的wiki链接。 Data Encryption StandardDES：#keys = $2^{56}$ ,block siez = 64bits，一次可以加密8个字母。 Today：AES（2001）、Salsa20（2008）…… 这里只是简单介绍。 Discrete Probability这个segment比较简单，概率论基本完全cover了，这里只讲一些重点。 Randomized algorithms随机算法有两种，一种是Deterministic algorithm（也就是伪随机），另一种是Randomized algorithm。 Deterministic algorithm $ y\\longleftarrow A(m)$ ，这是一个确定的函数，输入映射到唯一输出。 Randomized algorithm $y\\longleftarrow A(m ; r) \\quad \\text { where } r \\stackrel{R}{\\longleftarrow}{0,1}^{n}$ output： $y \\stackrel{R}{\\longleftarrow} A(m)$ ，y is a random variable. $ r \\stackrel{R}\\longleftarrow { 0,1 }^n $ :意思是r是n位01序列中的任意一个取值。R，random。变量r服从在 ${0,1}^n$ 取值的均匀分布。 由于随机变量r，对于给定m，$A(m;r)$ 是 ${0,1}^n$ 中的一个子集。 所以，对m的加密结果y，也是一个的随机变量，而且，y在 $A(m,r)$ 也是服从均匀分布。 因此，由于r的影响，对于给定m，加密结果不会映射到同一个值。（如上图所示） XORXOR有两种理解：（ $x \\oplus y $ ） 一种是：x,y的bit位相比较，相同则为0，相异为1. 另一种是：x,y的bit位相加 mod2. 异或在密码学中被频繁使用，主要是因为异或有一个重要的性质。 异或的重要性质：有两个在 ${0,1}^n$ （n位01串）取值的随机变量X、Y。X、Y相互独立，X服从任意某种分布，随机变量Y服从均匀分布。那么 $Z=Y\\oplus X$ ，Z在 ${0,1}^n$ 取值，且Z服从均分分布。 Thm: Y a rand. var. over ${0,1}^n$ , X an index. uniform var. on ${0,1}^n$ ​ Then Z := Y $\\oplus$ X is uniform var. on ${0,1}^n$ . Proof： 当n=1 画出联合分布 Pr[ Z=0 ]=Pr[ (x,y)=(0,0)] + Pr[(x,y)=(1,1)]=1/2 每一bit位都服从均匀分布，可以容易得出 Z是服从难过均匀分布。 The birthday paradox（生日悖论）更具体的分析见 Birthday problem 。 问题前提：一个人的生日在365天的任意一天是均匀分布的（实际当然不是，貌似更多集中在9月）。 根据信鸽理论（有N个鸽子，M个隔间，如果N&gt;M，那么一定有一个隔间有两只鸽子），所以367个人中，以100%的概率有两个人的生日相同。但是，当只有70个人时，就有99.9%的概率，其中两人生日相同；当只有23人，这个概率可以达到50%。 其实这并不是一个悖论，只是直觉误导，理性和感性认识的矛盾。当只有一个人，概率为0，当有367人时，为100%，所以我们直觉认为，这是线性增长的，其实不然。 概率论知识： 设事件A：23个人中，有两个人生日相等。 $P\\left(A^{\\prime}\\right)=\\frac{365}{365} \\times \\frac{364}{365} \\times \\frac{363}{365} \\times \\frac{362}{365} \\times \\cdots \\times \\frac{343}{365}$ $P\\left(A^{\\prime}\\right)=\\left(\\frac{1}{365}\\right)^{23} \\times(365 \\times 364 \\times 363 \\times \\cdots \\times 343)$ $P\\left(A^{\\prime}\\right) \\approx 0.492703$ $P(A) \\approx 1-0.492703=0.507297 \\quad(50.7297 \\%)$ 推广到一般情况，n个人(n","link":"/2020/03/04/Dan-Intro/"},{"title":"「机器学习-李宏毅」：Gradient","text":"总结「李宏毅老师-机器学习」的Gradient，主要从以下三个方面展开：调节learning rate；加快训练速度；对数据进行Feature Scaling。 阅读完三个tips，具体实现可demo Tip 1: Tuning your learning rates carefullyVisualize 损失函数随着参数变化的函数图 左图是Loss Function的函数图，红色是最好的Step，当Step过小（蓝色），会花费很多时间，当Step过大（绿色、黄色），会发现Loss越来越大，找不到最低点。 所以在Training中，尽可能的visualize loss值的变化。 但是当参数大于等于三个时， $loss function$的函数图就不能visualize了。 因此，在右图中，visualize Loss随着参数更新的变化，横轴即迭代次数，当图像呈现蓝色（small）时，就可以把learning rate 调大一些。 Adaptive Learning Rates(Adagrad)但是手动调节 $\\eta$是低效的，我们更希望能自动地调节。 直观上的原则是： $\\eta$ 的大小应该随着迭代次数的增加而变小。 最开始，初始点离minima很远，那step应该大一些，所以learning rate也应该大一些。 随着迭代次数的增加，离minima越来越近，就应该减小 learning rate。 E.g. 1/t decay： $\\eta^t=\\eta/ \\sqrt{t+1}$ 不同参数的 $\\eta$应该不同（cannot be one-size-fits-all)。 AdagradAdagrad 的主要思想是：Divide the learning rate of each parameter by the root mean squear of its previous derivatives.(通过除这个参数的 计算出的所有导数 的均方根) root mean squar : $ \\sqrt{\\frac{1}{n}(x_1^2+x_2^2+...+x_n^2)} $ Vanilla Gradient descent $w^{t+1} \\leftarrow w^{t}-\\eta^{t} g^{t}$ Adagrad $w^{t+1} \\leftarrow w^{t}-\\frac{\\eta^{t}}{\\sigma^{t}} g^{t} $ $\\eta^t$：第t次迭代的leaning rate $ \\eta^{t}=\\frac{\\eta}{\\sqrt{t+1}}$ $g^{t}=\\frac{\\partial L\\left(\\theta^{t}\\right)}{\\partial w} $ $\\sigma^t$：root mean squar of previous derivatives of w $\\tau^{t}=\\sqrt{\\frac{1}{t+1} \\sum_{i=0}^{t}\\left(g^{i}\\right)^{2}} $ 对比上面两种Adaptive Gradient，Adagrade的优势是learning rate 是和parameter dependent（参数相关的）。 Adagrad步骤简化步骤： 简化公式： $ w^{t+1} \\leftarrow w^{t}-\\frac{\\eta}{\\sqrt{\\sum_{i=0}^{t}\\left(g^{i}\\right)^{2}}} g^{t}$ ( $ \\eta^{t}=\\frac{\\eta}{\\sqrt{t+1}} $ , $ \\sigma^{t}=\\sqrt{\\frac{1}{t+1} \\sum_{i=0}^{t}\\left(g^{i}\\right)^{2}}$ ,约掉共同项即可) Adagrad Contradiction? ——Adagrad原理解释Vanilla Gradient descent $w^{t+1} \\leftarrow w^{t}-\\eta^{t} g^{t}$ Adagrad $ w^{t+1} \\leftarrow w^{t}-\\frac{\\eta}{\\sqrt{\\sum_{i=0}^{t}\\left(g^{i}\\right)^{2}}} g^{t}$ 在Vanilla Gradient descent中， $g^t$越大，也就是当前梯度大，也就有更大的step。 而在Adagrad中，当 $g^t$越大，有更大的step,而当 $\\sqrt{\\sum_{i=0}^t (g^i)^2} $ 越大，反而有更小step。 Contradiction？ 「Intuitive Reason（直观上解释）」 $ w^{t+1} \\leftarrow w^{t}-\\frac{\\eta}{\\sqrt{\\sum_{i=0}^{t}\\left(g^{i}\\right)^{2}}} g^{t}$ $\\sqrt{\\sum_{i=0}^t (g^i)^2} $ 是为了造成反差的效果。 类比一下，如果一个一直很凶的人，突然温柔了一些，你会觉得他特别温柔。所以同样是 $0.1$,第一行中，你会觉得特别大，第二行中，你会觉得特别小。 因此 $\\sqrt{\\sum_{i=0}^t (g^i)^2} $ 这一项的存在就能体现 $g^t$的变化有多surprise。 「数学一些的解释」1. Larger Gradient,larger steps?在前面我们都深信不疑这一点，但这样的描述真的是正确的吗？ 在这张图中，只有一个参数，认为当该点的导数越大，离minima越远，这样看来，Larger Gradient,larger steps是正确的。 在上图中的 $x_0$点，该点迭代更新的best step 应该正比于 $|x_0+\\frac{b}{2a}|$ ，即 $\\frac{|2,a, x_0+b|}{2a}$。 而 $\\frac{|2,a, x_0+b|}{2a}$的分子也就是该点的一阶导数的绝对值。 上图中，有 $w_1,w_2$两个参数。 横着用蓝色的线切一刀，得到的是 $w_2$ 固定，loss随着 $w_1$变化的图像：比较a、b两点，a点导数大，离minima远。 竖着用绿色的线切一刀，得到的是 $w_2$ 固定，loss随着 $w_1$变化的图像：比较c、d两点，c点导数大，离minima远。 但是，如果比较a、c两点呢？ a点对 $w_1$ 的偏导数和c点对 $w_2$的偏导数比较？ 比较出来，c点点偏导数更大，离minima更远吗？ 再看左图的图像，横着的弧度更平滑，竖着的弧度更尖一些，直观上看应该c点离minima更近一些。 所以Larger Gradient,larger steps点比较方法不能（cross parameters)跨参数比较。 所以最好的step $\\propto$ 一阶导数（Do not cross parameters)。 2.** Second Derivative** 前面讨论best step $\\frac{|2,a, x_0+b|}{2a}$的分子是该点一阶导数，那么其分母呢？ 当对一阶导数再求导时，可以发现其二阶导数就是best step的分母。 得出结论：the best step $\\propto$ |First dertivative| / Second derivative。 因此，再来看两个参数的情况，比较a点和c点，a点的一阶导数更小，二阶导数也更小；c点点一阶导数更大，二阶导数也更大。 所以如果要比较a、c两点，谁离minima更远，应该比较其一阶导数的绝对值除以其二阶导数的大小。 回到 $ w^{t+1} \\leftarrow w^{t}-\\frac{\\eta}{\\sqrt{\\sum_{i=0}^{t}\\left(g^{i}\\right)^{2}}} g^{t}$ 上一部分得出的结论是：the best step $\\propto$ |First dertivative| / Second derivative。 所以我们的learning rate 也应该和 |First dertivative| / Second derivative相关。 $g^t$也就是一阶导数，但为什么 $\\sqrt{\\sum_{i=0}^t (g^i)^2} $ 能代表二阶导数呢？ 上图中，蓝色的函数图有更小的二阶导数，绿色的函数图有更大的二阶导数。 在复杂函数中，求二阶导数是一个很复杂的计算。 所以我们想用一阶导数来反映二阶导数的大小。 在一阶导数的函数图中，认为一阶导数值更小的，二阶导数也更小，但是取一个点显然是片面的，所以考虑取多个点。 也就是用 $ \\sqrt{\\text{(first derivative)}^2}$ 来代表best step中的二阶导数。 总结一下Adagrad的为了找寻最好的learning rate，从找寻best step下手，用简单的二次函数为例，得出 best step $\\propto$ |First dertivative| / Second derivative。 但是复杂函数的二阶导数是难计算的，因此考虑用多个点的一阶导数来反映其二阶导数。 得出 $ w^{t+1} \\leftarrow w^{t}-\\frac{\\eta}{\\sqrt{\\sum_{i=0}^{t}\\left(g^{i}\\right)^{2}}} g^{t}$ 。 直观来解释公式中的一阶导数的root mean square，即来为该次迭代的一阶导数造成反差效果。 其他文献中的Adaptive Gradient理应都是为了调节learning rate使之有best step。(待补充的其他Gradient)[1] Tip 2:Stochastic Gradient DescentStochastic Gradient Descent在linear model中，我们这样计算Loss function： $L=\\sum_{n}\\left(\\hat{y}^{n}-\\left(b+\\sum w_{i} x_{i}^{n}\\right)\\right)^{2} $ 每求一次Loss function，L都对所有training examples的 $\\text{error}^2$求和，因此每一次的loss function的计算，都是一重循环。 在Stochastic Gradient Descent中，每一次求loss function，只取一个example $x^n$，减少一重循环，无疑更快。 Stochastic Gradient Descent Pick an example $x^n$ $L=\\left(\\hat{y}^{n}-\\left(b+\\sum w_{i} x_{i}^{n}\\right)\\right)^{2} $ 上图中，传统的Gradient Descent看完一次所有的examples，离minima还很远；而Stochastic Gradient Descent ，看完一次，已经离minima较近了。 Tip 3:Feature ScalingWhat is Feature Scaling 如上图所示，希望能让不同的feature能有相同的scale（定义域/规模） Why Feature Scaling假设model都是 $y = b+ w_1 x_1 +w_2 x_2$。 上图中，左边 $x_2$的规模更大，可以认为 $x_1$ 对loss 的影响更小， $ x_2$对loss的影响更大。 即当 $w_1,w_2$轻微扰动时，同时加上相同的 $\\Delta w$时，$x_2$ 使 $y$的取值更大，那么对loss 的影响也更大。 如图中下方的函数图 $w_1$方向的L更平滑， $w_2$ 方向更陡峭些，Gradient descent的步骤如图所示。 但当对 $x_2$进行feature scaling后，图像会更像正圆，Gradient descent使，参数更新向着圆心走，更新会更有效率。 How Feature Scaling概率论知识：标准化。 概率论： 随机变量 $X$ 的期望和方差均存在，且 $ D(X)>0$,令 $X^*=\\frac{X-E(X)}{\\sqrt{D(X)}}$ 那么 $E(X^*)=0,D(X)=1 $ , $ X^* $ 称为X的标准化随机变量。 对所有向量的每一维度，进行标准化处理： $x_{i}^{r} \\leftarrow \\frac{x_{i}^{r}-m_{i}}{\\sigma_{i}} $ （ $m_i$是该维度变量的均值， $\\sigma_i$ 是该维度变量的方差） 标准化后，每一个feature的期望都是0，方差都是1。 Gradient Descent Theory(公式推导)当用Gradient Descent解决 $\\theta^*=\\arg \\min_\\theta L(\\theta)$时，我们希望每次更新 $\\theta $ 都能得到 $L(\\theta^0)&gt;L(\\theta^1)&gt;L(\\theta^2)&gt;…$ 这样的理论结果，但是不总能得到这样的结果。 上图中，我们虽然不能一下知道minima的方向，但是我们希望：当给一个点 $\\theta^0$ 时，我们能很容易的知道他附近（极小的附近）的最小的loss 是哪个方向。 所以怎么做呢？ Tylor Series微积分知识：Taylor Series（泰勒公式）。 Tylor Series:函数 $h(x)$ 在 $x_0$ 无限可导，那么 $\\begin{aligned} \\mathrm{h}(\\mathrm{x}) &=\\sum_{k=0}^{\\infty} \\frac{\\mathrm{h}^{(k)}\\left(x_{0}\\right)}{k !}\\left(x-x_{0}\\right)^{k} \\\\ &=h\\left(x_{0}\\right)+h^{\\prime}\\left(x_{0}\\right)\\left(x-x_{0}\\right)+\\frac{h^{\\prime \\prime}\\left(x_{0}\\right)}{2 !}\\left(x-x_{0}\\right)^{2}+\\ldots \\end{aligned}$ 当 x 无限接近 $x_0$ 时，忽略后面无穷小的高次项， $h(x) \\approx h\\left(x_{0}\\right)+h^{\\prime}\\left(x_{0}\\right)\\left(x-x_{0}\\right) $ 上图中，用 $\\pi/4$ 处的一阶泰勒展示来表达 $\\sin(x)$ ,图像是直线，和 $\\sin(x)$ 图像相差很大，但当 x无限接近 $\\pi/4$ 是，函数值估算很好。 Multivariable Taylor Series $h(x, y)=h\\left(x_{0}, y_{0}\\right)+\\frac{\\partial h\\left(x_{0}, y_{0}\\right)}{\\partial x}\\left(x-x_{0}\\right)+\\frac{\\partial h\\left(x_{0}, y_{0}\\right)}{\\partial y}\\left(y-y_{0}\\right) +\\text{something raleted to} (x-x_x^0)^2 \\text{and} (y-y_0)^2+…$ 当 $(x,y)$ 接近 $(x_0,y_0)$ 时， $h(x,y)$ 用 $(x_0,y_0)$ 处的一阶泰勒展开式估计。 $ h(x, y) \\approx h\\left(x_{0}, y_{0}\\right)+\\frac{\\partial h\\left(x_{0}, y_{0}\\right)}{\\partial x}\\left(x-x_{0}\\right)+\\frac{\\partial h\\left(x_{0}, y_{0}\\right)}{\\partial y}\\left(y-y_{0}\\right)$ Back to Formal Derivation 当图中的红色圆圈足够小时，红色圆圈中的loss 值就可以用 $(a,b)$ 处的一阶泰勒展开式来表示。 $ \\mathrm{L}(\\theta) \\approx \\mathrm{L}(a, b)+\\frac{\\partial \\mathrm{L}(a, b)}{\\partial \\theta_{1}}\\left(\\theta_{1}-a\\right)+\\frac{\\partial \\mathrm{L}(a, b)}{\\partial \\theta_{2}}\\left(\\theta_{2}-b\\right) $ $(\\theta_1-a)^2+(\\theta_2-b)^2 \\leq d^2$ ,d 足够小。 用 $s=L(a,b)$ , $ u=\\frac{\\partial \\mathrm{L}(a, b)}{\\partial \\theta_{1}}, v=\\frac{\\partial \\mathrm{L}(a, b)}{\\partial \\theta_{2}} $ 表示。 最后问题变成： $L(\\theta)\\approx s+u(\\theta_1-a)+v(\\theta_2-b)$ 找 $(\\theta_1,\\theta_2)$，且满足 $(\\theta_1-a)^2+(\\theta_2-b)^2 \\leq d^2$，使 $L(\\theta)$ 最小。 变成了一个简单的最优化问题。 令 $\\Delta \\theta_1=\\theta_1-a$ , $\\Delta\\theta_2=\\theta_2-b$ 问题简化为： $\\text{min}:u \\Delta \\theta_1+v\\Delta\\theta_2$ $\\text{subject to}:{\\Delta\\theta_1}^2+{\\Delta\\theta_2}^2\\leq d^2$ 画出图，就是初中数学了。更新的方向应该是 $(u,v)$ 向量反向的方向。 所以： $\\left[\\begin{array}{l} \\Delta \\theta_{1} \\\\ \\Delta \\theta_{2} \\end{array}\\right]=-\\eta\\left[\\begin{array}{l} u \\\\ v \\end{array}\\right] $ $\\left[\\begin{array}{l} \\theta_{1} \\\\ \\theta_{2} \\end{array}\\right]=\\left[\\begin{array}{l} a \\\\ b \\end{array}\\right]-\\eta\\left[\\begin{array}{l} u \\\\ v \\end{array}\\right] $ $ \\left[\\begin{array}{l} \\theta_{1} \\\\ \\theta_{2} \\end{array}\\right]=\\left[\\begin{array}{l} a \\\\ b \\end{array}\\right]-\\eta\\left[\\begin{array}{l} u \\\\ v \\end{array}\\right]=\\left[\\begin{array}{l} a \\\\ b \\end{array}\\right]-\\eta\\left[\\begin{array}{l} \\frac{\\partial \\mathrm{L}(a, b)}{\\partial \\theta_{1}} \\\\ \\frac{\\partial \\mathrm{L}(a, b)}{\\partial \\theta_{2}} \\end{array}\\right] $ Limitation of Gradient Descent Gradient Descent 可能会卡在local minima或者saddle point（鞍点：一个方向是极大值，一个方向是极小值，导数为0） 实践中，我们往往会在导数无穷接近0的时候停下来（&lt; 1e-7)，Gradient Descent 可能会停在plateau(高原；增长后的稳定) Reference[1] 待补充的其他Gradient","link":"/2020/03/01/Gradient/"},{"title":"「机器学习-李宏毅」：Regression","text":"在YouTube上看台大李宏毅老师的课，看完Regression讲座的感受就是： 好想去抓Pokemon！！！ 这篇文章将总结李宏毅老师Regression的讲座，并尝试实现其demo。 Regression（回归）DefineRegression：是找到一个$function$，进行预测。对输入的feature，输出一个$Scalar$(数值，标量)。 Example Application Look for a $function$ Stock Market Forecast（股票预测） $input$：过去的股价信息 $output$：明天的股价平均值（$Scalar$) Self-Driving Car(自动驾驶) $input$：路况信息 $output$：方向盘角度（$Scalar$) Recommendation（推荐系统） $input$：使用者A、商品B $output$：使用者A购买商品B的可能性 可见，$input$都是一些特征信息，$output$都是一个标量数值，这就是Regression。 Regression Case: Pokenmon 看完这节课，感想：好想去抓宝可梦QAQ 预测一个pokemon进化后的CP（Combat Power，战斗力）值。 为什么要预测呐？ 如果进化后的CP值高，就进化他，不然就把他当糖果，因为宝可梦很难抓的。（？没玩过，我也不懂o r z） 上图妙蛙种子的信息(可能的$input$)： $x_{cp}$：CP值 $x_s$:物种 $x_{hp}$:生命值 $x_w$:重量 $x_h$:高度 output：进化后的CP值。 $x_{cp}$：用下标表示一个object的component。 $x^1$：用上标表示一个完整的object。 Step 1: 找一个Model（function set）Model ：$y = b + w \\cdot x_{cp}$ 假设用上式作为我们的Model，那么这些函数： $ \\begin{aligned} &\\mathrm{f}_{1}: \\mathrm{y}=10.0+9.0 \\cdot \\mathrm{x}_{\\mathrm{cp}}\\\\ &f_{2}: y=9.8+9.2 \\cdot x_{c p}\\\\ &f_{3}: y=-0.8-1.2 \\cdot x_{c p} \\end{aligned} $ 等都属于这个集合，但是显然像$f_3$这种函数是bad，CP值不可能是负数。bad functions 很多，所以在下面的步骤，会说明如何判别一个函数的好坏，自动的选出最好的那个 $function$。 把Model 1一般化，得到线代中的 Linear Model：$y = b+\\sum w_ix_i$ $x_i$：x的feature $b$：bias,偏置值 $w_i$：weight，权重 Step 2: 判别Goodness of Function(Training Data)Training Data假定使用Model ：$y = b + w \\cdot x_{cp}$ Training Data：十只宝可梦，用向量的形式表示。 使用Training data来judge the goodness of function.。 Loss Function(损失函数)概率论：做线性回归，一般使用最小二乘法。一般回归，大多使用极大似然估计。 Loss function $L$ ：$L(f)=L(w,b)=\\sum_{n=1}^{10}(\\hat{y}^n-(b+w\\cdot x_{cp}^n))^2$ 其中的 $\\hat{y}^n-(b+w\\cdot x_{cp}^n)$是Estimation error(估测误差) Loss Function的意义：它的 $input$是一个 $function$，它的 $output$体现了how bad it is,这个函数有多糟/好。 Figure the Result 上图横纵坐标是函数 $L$的参数 $w 、b$，图中的每一个point都是一个 $function $。 color：体现函数的输出，越红越大，说明选择的函数越bad。 所以我们要选择紫色区域结果最小的函数。 而这个得到best function的过程是可以通过无数次迭代实现的。（重复的迭代当时是交给计算机做了） Step 3:迭代找出Best Function$L(w,b)=\\sum_{n=1}^{10}(\\hat{y}^n-(b+w\\cdot x_{cp}^n))^2$ 找到Best Function: $f^{*}=\\arg \\min _{f} L(f)$ 也就是找到参数 $w^{*},b^{*}=\\arg \\min_{w,b} L(w,b)=\\arg \\min_{w,b}\\sum_{n=1}^{10}(\\hat{y}^n-(b+w\\cdot x_{cp}^n))^2$ arg ：argument,变元 arg min：使之最小的变元 arg max：使之最大的变元 据悉，线性回归的参数可以用线性代数的知识，解出closed-form solution（解析解），我先挖个坑QAQ，以后来填这块知识。[1] 在机器学习中，只要$L$函数可微分， 即可用Gradient Descent（梯度下降）的方法来求解。 Gradient Decent（梯度下降）和概率论中的梯度下降估计参数的原理相同，只是计算机不能直接解出方程的解，所以计算机的方法是迭代。 考虑一个参数w*$w^*=\\arg \\min_w L(w)$ 步骤： 随机选取一个初始值 $w^0$ 计算 $ \\frac{{\\rm d}L}{{\\rm d}w}|_{w=w^0}$ &nbsp; &nbsp; $\\begin{equation} w^{1} \\leftarrow w^{0}-\\left.\\eta \\frac{d L}{d w}\\right|_{w=w^{0}} \\end{equation}$ 计算 $ \\frac{{\\rm d}L}{{\\rm d}w}|_{w=w^0}$ &nbsp;&nbsp; $\\begin{equation} w^{2} \\leftarrow w^{1}-\\left.\\eta \\frac{d L}{d w}\\right|_{w=w^{1}} \\end{equation}$ …until $ \\frac{{\\rm d}L}{{\\rm d}w}|_{w=w^n}=0$ 上图迭代过程的几点说明 $\\begin{equation}\\left.\\frac{\\mathrm{d} L}{\\mathrm{d} w}\\right|_{w=w^{i}}\\end{equation}$的正负 如果是negative，也就是该点切线斜率是负的，那应该Increse w，以找到最低点。 Negative $\\rightarrow$ Increase w Positive $\\rightarrow$ Decrease w $-\\left.\\eta \\frac{d L}{d w}\\right|_{w=w^{i}}$：步长 $\\eta$：learning rate（学习速度），事先设好的值。 $-$(负号)：如果 $\\begin{equation}\\left.\\frac{\\mathrm{d} L}{\\mathrm{d} w}\\right|_{w=w^{i}}\\end{equation}$是负的，应该增加w。 Local optimal：局部最优和全局最优 如果是以上图像，则得到的w不是全局最优。 但线性回归的损失函数是凸函数，存在一个全局最优，没有局部最优。 考虑多个参数 $w^{*},b^{*}$ 微积分知识：gradient（梯度，向量)： $\\nabla L=\\left[\\begin{array}{l}\\frac{\\partial L}{\\partial w} \\\\frac{\\partial L}{\\partial b}\\end{array}\\right]$ 考虑多个参数和考虑一个参数思路相同，每次迭代，迭代两个参数。 $w^{*}, b^{*}=\\arg \\min _{w, b} L(w, b)$ 步骤： 随机选取初值 $w^0,b^0$ 计算 $\\left.\\left.\\frac{\\partial L}{\\partial w}\\right|_{w=w^{0}, b=b^{0},} \\frac{\\partial L}{\\partial b}\\right|_{w=w^{0}, b=b^{0}}$ &nbsp; &nbsp; $w^{1} \\leftarrow w^{0}-\\left.\\eta \\frac{\\partial L}{\\partial w}\\right|_{w=w^{0}, b=b^{0}} \\quad b^{1} \\leftarrow b^{0}-\\left.\\eta \\frac{\\partial L}{\\partial b}\\right|_{w=w^{0}, b=b^{0}}$ 计算 $\\left.\\left.\\frac{\\partial L}{\\partial w}\\right|_{w=w^{1}, b=b^{1},} \\frac{\\partial L}{\\partial b}\\right|_{w=w^{1}, b=b^{1}}$ &nbsp; &nbsp; &nbsp; $w^{2} \\leftarrow w^{1}-\\left.\\eta \\frac{\\partial L}{\\partial w}\\right|_{w=w^{1}, b=b^{1}} \\quad b^{2} \\leftarrow b^{1}-\\left.\\eta \\frac{\\partial L}{\\partial b}\\right|_{w=w^{1}, b=b^{1}}$ …until $ \\frac{{\\rm d}L}{{\\rm d}w}|_{w=w^n}=0$, $ \\frac{{\\rm d}L}{{\\rm d}b}|_{b=b^n}=0$ 上图，坐标为 $L(w,b)$函数的参数，Color代表 $L$的大小，越紫值越小。 每一个点都是一个 $function$，沿着梯度方向（图中法线方向）迭代，找到全局最优点。 再次说明：线性回归中，损失函数是convex（凸函数），没有局部最优解。 $\\frac{\\partial L}{\\partial w}$和 $\\frac{\\partial L}{\\partial b}$的公式推导$L(w, b)=\\sum_{n=1}^{10}\\left(\\hat{y}^{n}-\\left(b+w \\cdot x_{c p}^{n}\\right)\\right)^{2}$ 微积分的知识，显然。 数学真香。———我自己 $\\frac{\\partial L}{\\partial w}=\\sum_{n=1}^{10}2\\left(\\hat{y}^{n}-\\left(b+w \\cdot x_{c p}^{n}\\right)\\right)（-x_{cp}^n)$ $\\frac{\\partial L}{\\partial b}=\\sum_{n=1}^{10}2\\left(\\hat{y}^{n}-\\left(b+w \\cdot x_{c p}^{n}\\right)\\right)(-1)$ 实际结果分析Training Data Training Data的Error=31.9，但我们真正关心的是Testing Data的error。 Testing Data 是new Data：另外的Pokemon！。 Testing DataModel 1： $y = b+w\\cdot x_{cp}$ error = 35,比Training Data error更大。 Model 2：$y = b+w_1\\cdot x_{cp}+w_2\\cdot (x_{cp})^2$ Testing error=18.4，比Model 1 好。 Model 3：$y = b+w_1\\cdot x_{cp}+w_2\\cdot (x_{cp})^2+w_3\\cdot(x_{cp})^3$ Testing error=18.1，比Model 2好。 Model 4:$y = b+w_1\\cdot x_{cp}+w_2\\cdot (x_{cp})^2+w_3\\cdot(x_{cp})^3+w_4 \\cdot (x_{cp})^4$ Testing error =28.8,比Model3更差。 Model 5：$y = b+w_1\\cdot x_{cp}+w_2\\cdot (x_{cp})^2+w_3\\cdot(x_{cp})^3+w_4 \\cdot (x_{cp})^4+w_5\\cdot (x_{cp})^5$ Testing error = 232.1,爆炸了一样的差。 Overfiting（过拟合了）从上面5个Model中可以得出，越复杂的函数模型，在Testing data上不一定能得到更好的结果。（过拟合使Training data 的误差越来越小） 所以在选择Model时，需要选择合适的Model。 对模型进行改进如果收集更多的Training Data，可以发现他好像不是一个Linear Model。 Back to step 1:Redesigh the Model从上面那张图，感觉他不是一个Linear Model,而是需要if 是伊布，模型是…，if 是…,可见是和物种有关系。 （很抱歉，我只认识右上角时伊布，QAQ，我也说不出名字） 但用 $\\delta$(微积分学的狄拉克函数)表示条件语句，可以发现，他仍然是一个线性模型。 $\\delta(x_s= \\text{Pidgey)}\\left\\{\\begin{array}{ll}=1 & \\text { If } x_{s}=\\text { Pidgey } \\\\ =0 & \\text { otherwise }\\end{array}\\right.$ $y = b_1\\cdot \\delta_1+w_1\\cdot \\delta_1+b2\\cdot \\delta_2+w_2\\cdot \\delta_2+…$是一个linear model。 拟合出来，Training Data 和Testing Data的error都蛮小的。 如果想让拟合误差更小，还可以考虑其他的feature，重量、高度、HP等。 但同样的，如果函数过于复杂，也会出现Overfitting的情况。 Back to Step 2:Regularization（正则化）对于Linear Model :$y = b+\\sum w_i x_i$ 为什么要正则化？我们希望得到的函数是较平滑的，这样测试时，函数的输出对输入的noise不sensitive，即输入x的细微扰动，并不太会影响输出的结果。 所以当参数越接近0，函数越平滑。因此在原本的loss function后加入 $\\lambda \\sum(w_i)^2$项（ $\\lambda$需手调），可以保证函数较平滑。 正则化： $L = \\sum_n(\\hat{y}^n-(b+\\sum w_i x_i))^2 + \\lambda\\sum(w_i)^2$ $\\lambda $大小的选择 可以得出结论： $\\lambda $越大，Training Error变大了。 当 $\\lambda$更大，损失函数更考虑w参数的取值，更关心函数的平滑程度，而更少的关心拟合的error。 $\\lambda $越大，Testing Error变小了，当 $\\lambda$过大时，又变大。 $\\lambda $较小时，$\\lambda $增大，函数更平滑，能良好适应数据的扰动。 $\\lambda $较大时，函数过于平滑，宛如直线，这显然不能准确预测。 因此，在调节$\\lambda $大小时，也要适当选择。 正则化的一个注意点在regularization中，我们只考虑了w参数，没有考虑bias偏置值参数。 因为正则化是寻找较平滑拟合，而偏置参数只是让函数平移，与平滑无关。 Again：Regularization不考虑bias Fllowing Gradient descent[2] Overfitting and regularization[3] Validation[4] 由于博主也是在学习阶段，学习后，会po上下面内容的链接。 希望能在学习、写博客的过程中，锻炼自己的表达能力，尽量让文风言简意赅又科学严谨。 写博客是为了记录与分享，感谢指正。 Reference[1] “周志华西瓜书p55,待补充” [2] [3] [4]","link":"/2020/02/29/Regression/"},{"title":"「Cryptography-Dan」:Stream Cipher 1","text":"Stream Cipher的第一部分：介绍了One Time Pad和Stream Cipher中的PRG。其中OTP部分叙述了什么是Perfect Secrecy？为什么OTP很难在实践中应用？Stream Cipher部分中，本文主要阐述了什么是PRG？Stream Cipher的另一种安全的定义（依靠PRG的unpredictable)。本文后半部分，详细阐述了一种weak PRG——线性同余生成器，它是如何工作的？它为什么不安全？如何attack it elegantly? The One Time PadSymmetric Ciphers: difinitionDef :a cipher difined over $\\mathcal{(K,M,C)}$ is a paire of “efiicient “ algorithms $(E,D)$ where $$ E :\\mathcal{K \\times M \\longrightarrow \\mathcal{C}} \\quad ,\\quad D:\\mathcal{K\\times\\mathcal{C}\\longrightarrow\\mathcal{M}} \\\\ s.t. \\quad \\forall m\\in \\mathcal{M},k\\in \\mathcal{K}:D(k,E(k,m))=m $$ $\\mathcal{(K,M,C)}$ 分别是密钥空间、明文空间、密文空间。 对称加密其实是定义在$\\mathcal{(K,M,C)}$ 的两个有效算法 $(E,D)$ ，这两个算法满足consistence equation(一致性方程)：$D(k,E(k,m))=m$ 。 一些说明： $E$ is ofen randomized. 即加密算法E总是随机生成一些bits，用来加密明文。 $D$ is always deterministic. 即当确定密钥和明文时，解密算法的输出总是唯一的。 “efficient” 的含义 对于理论派：efficient表示 in polynomial time（多项式时间） 对于实践派：efficient表示 in a certain time One Time Pad(OTP)Definition of OTPThe one time pad(OTP) 又叫一次一密。 用对称加密的定义来表示OTP： $\\mathcal{M=C=}{0,1}^n\\quad \\mathcal{K}={0,1}^n$ $E：\\quad c = E(k,m)=k\\oplus m \\quad$ $D:\\quad m = D(k,c)=k\\oplus c$ 明文空间和密文空间相同，密钥空间也是n位01串集合。 而且，在OTP中，密钥key的长度和明文message长度一样长。 加密过程如上图所示。 证明其一致性方程 Indeed ： $D(k,E(k,m))=D(k,k\\oplus m)=k\\oplus (k\\oplus m)=0\\oplus m=m$ 但是OTP加密安全吗？ 如果已知明文(m)和他的OTP密文(c)，可以算出用来加密m的OTP key吗？ ：当然，根据异或的性质，key $k=m\\oplus c$ 所以什么是安全呢？ Perfect Security Definition根据Shannon 1949发表的论文，Shannon’s basic idea: CT(Ciphertext) should reveal no “info” about PT(Plaintext)，即密文不应该泄露明文的任何信息。 Perfect Security Def:A cipher $(E,D)$ over $\\mathcal{(K,M,C)}$ has perfect security if $\\forall m_0,m_1 \\in \\mathcal{M}\\ (|m_0|=|m_1|) \\quad \\text{and} \\quad \\forall c\\in \\mathcal{C} $$$Pr[E(k,m_0)=c]=Pr[E(k,m_1)=c] \\qquad \\text{where} \\ k\\overset{R}{\\longleftarrow}\\mathcal{K}$$ $k \\overset{R}\\longleftarrow \\mathcal{K}$ 的意思是 $k$ 是 从$\\mathcal{K}$ 中随机取的，即随机变量 $k$ 的取值是均匀分布。 对任意 $m_0,m_1$ （并且message长度相同），那么在密钥空间任意取 $k$ , $k$ 将 $m_0,m_1$ 加密为相同密文的概率相同。 对attacker来说 ：攻击者截取一段密文c，那么c是由 $m_0,m_1$ 加密而来的概率是相同的，即攻击者也不知道明文到底是 $m_0$ 还是 $m_1$ （因为概率相同）。 $\\Rightarrow$ Given CT can’t tell if msg is $m_0 \\ \\text{or}\\ m_1 $ (for all $m_i$ ) . 【攻击者不能区分明文到底是 $m_?$ 】 $\\Rightarrow$ most powerful adv.(adversary) learns nothing about PT from CT. 【不管攻击者多聪明，都不能从密文中得到密文的信息】 $\\Rightarrow$ no CT only attack!! (but other attackers possible). 【惟密文攻击对OTP无效】 OTP has perfect secrecyLemma : OTP has perfect secrecy. 用上一小节的perfect securecy的定义来证明这个引理。 Proof： 要证明： $Pr[E(k,m_0)=c]=Pr[E(k,m_1)=c] \\qquad \\text{where} \\ k\\overset{R}{\\longleftarrow}\\mathcal{K}$ 表达式： $\\forall m, c: \\quad \\operatorname{Pr}_{k}[E(k,m)=c]=\\frac{\\# \\text{keys} \\ k \\in \\mathcal{K} \\quad s.t.\\; E(k,m)=c}{|\\mathcal{K}|}$ 对于任意m,c, $\\operatorname{Pr}_{k}[E(k,m)=c]$ 等于能将m加密为c的密钥个数除以密钥空间的大小。 $\\because |\\mathcal{K}|$ 是相同的，所以即证 ： $\\{ \\# \\text{keys} \\ k \\in \\mathcal{K} \\quad s.t.\\; E(k,m)=c \\}=\\text{const}$ 对于任意 m,c，能将m加密为c的OTP key只有一个： $k=m\\oplus c$ $\\therefore$ OTP has perfect secrecy. key-len $\\geq$ msg-len Perfect Secrecy的性质带来了一个bad news。 Thm: perfect secrecy $\\Rightarrow$ $|\\mathcal{K}|\\geq|\\mathcal{M}|$ 如果一个cipher满足perfect secrecy,那么其密钥的长度必须大于等于明文长度。这也是perfect secrecy的必要条件。 所以OTP是perfect secrecy的最优情况，$|\\mathcal{K}|=|\\mathcal{M}|$ ，密钥长度等于明文长度。 为什么说是一个bad news呢？ 如果Alice用OTP给Bob发一段msg，在她发之前，她需要先发一个和msg等长的key，这个key只有Alice和Bob知道。 所以如果Alice有能保密传输key的方法，那她何不直接用这个方法传输msg呢？ 所以OTP : hard to use in practice! (long key-len) 因此，我们需要key-len短的cipher。 Pseudorandom Generators（伪随机数生成器）Stream Ciphers: making OTP practicalStream Ciphers（流密码）的思想就是：用PRG（pseudorandom Generators） key 代替 “random” key。 PRG其实就是一个function G：${ 0,1 }^s\\longrightarrow { 0,1 }^n \\quad, n&gt;&gt;s$ 。 通过函数将较小的seed space映射到大得多的output space。 注意： function G is eff. computable by a deterministic algorithm. 函数G是确定的，随机的只有s，s也是G的输入。 PRG的输出应该是 “look random”（下文会提到的PRG必须是unpredictable） Stream Ciphers的过程如上图所示：通过PRG，将长度较短的k映射为足够长的G(k)，G(k)异或m得到密文。 有两个问题？ 第一，Stream Cipher安全吗？为什么安全？ 第二，Stream Cipher have perfect secrecy? 现在，只能回答第二个问题。 ：流密码没有perfect secrecy。因为它不满足key-len $\\geq$ msg-len，流密码的密钥长度远小于明文长度。 流密码没有perfect secrecy，所以我们还需要引入另一种安全，这种安全和PRG有关。 PRG must be unpredictablePRG如果predictable，流密码安全吗？ Suppose predictable假设PRG是可预测的，即： $ \\exists:\\quad G(k)|_{1,2,...,i}\\quad \\overset{alg.}\\longrightarrow \\quad G(k)|_{i+1,...,n} $ 已知G(k)输出的前i bis，存在一种算法，能计算G(k)的后面剩余的bits。 攻击如上图所示： 如果attacker has prior knowledge：已知一段密文前缀的对应明文（m斜线字段）（比如在SMTP协议中，报文的开头总是”from”） attacker将该密文字段与已知明文字段异或，得到G(k)的前缀。 因为PRG是可预测的，所以可以通过G(k)的前缀计算出G(k)的剩下部分。 得到的G(K)就可以recover m。 即使，G(k)只能预测后一位，即 $\\quad G(k)|_{1,2,...,i}\\quad \\overset{alg.}\\longrightarrow \\quad G(k)|_{i+1}$ ，也不安全，当预测出下一位时，又得到了新的前缀，最终得到完整的G(k)。 所以当PRG可预测时，流密码就不安全了。 所以用Stream Cipher时，PRG必须unpredictable! Predictable: difinitionPredictable Def : $ \\exists $ \"eff\" alg. A and $\\exists$ $0\\leq i\\leq n-1$ ， s.t. $Pr_{k \\overset{R}\\leftarrow \\mathcal{K} } {[A(G(k)|_{1,2,...,i})=G(k)|_{i+1}]}>1/2 +\\epsilon$ for non-negligible $\\epsilon$ (e.g. $\\epsilon=1/2^{30}$) 可预测：即存在算法，通过G(k)的前i位可以计算出第i+1位的概率大于1/2 + $\\epsilon$ (不可忽略的值) Unpredictable Def : 即predictable的反面， $\\forall i$ : no “eff.” adv. can predict bit(i+1) for “non-neg” $\\epsilon$ . Q：假设 $\\mathrm{G}: \\mathrm{K} \\rightarrow{0,1}^{\\mathrm{n}} $ ，满足XOR(G(k))=1，G可预测吗？ W：G可预测，存在i = n-1,因为当已知前n-1位,可以预测第n位。 Weak PRGsLinear Congruential Generators一种应该永远不在安全应用中使用PRG——LCG（linear congruential generators）(线性同余随机生成器)。 虽然他们在应用中使用很快，而且其输出还有良好的统计性质（比如0的个数和1的个数基本相等等），但他们应该never be used for cryptographic。 因为在实践中，给出LCG输出的一些连续序列，很容易计算出输出的剩余序列。 Basic LCGDefinitionBasic LCG has four public system parameters: an integer q, two constants a,b $\\in { 0,…,q-1}$ , and a positive integer $w\\leq q$ . The constant a is taken to be relatively prime to q. 【有四个公开参数：整数q，两个q剩余系下的常数a,b，（a与q互素）一个小于等于q的正整数w。】 We use $\\mathcal{S}_q$ and $\\mathcal{R}$ to denote the sets: $\\mathcal{S}_{q}:=\\{0, \\ldots, q-1\\} ; \\quad \\mathcal{R}:=\\{0, \\ldots,\\lfloor(q-1) / w\\rfloor\\}$ Now, the generators $G_{\\mathrm{lcg}}: \\mathcal{S}_{q} \\rightarrow \\mathcal{R} \\times \\mathcal{S}_{q}$ with seed $s\\in\\mathcal{S}_{q}$ defined as follows: $G_{\\operatorname{lcg}}(s):=(\\lfloor s / w\\rfloor, \\quad a s+b \\bmod q)$ 【LCG的输出是一对数，$(\\lfloor s / w\\rfloor, \\quad a s+b \\bmod q)$ 】 当 $w=2^t$ 时，$\\lfloor s / w\\rfloor$ simpky erases the t lease significant bits of s【向右平移t位】。 Insecure当已知 $s^{\\prime}:=a s+b \\bmod q$ ，即可直接求出s，也就求出了所谓的随机数 $\\lfloor s/w\\rfloor$ . Variant: Blum-Micali constructionDefinition 如上图所示，变体的LCG是一个迭代，输出不包括 $s_i$ ，把 $r_1,…,r_n$ 作为一次迭代的输出。 不同的应用系统使用不同的 $q,a,b,w$ 参数，在Java 8 Development Kit（JDKv8）中，$q=2^{48}$ , $w=2^{22}$ ,constant $a=\\text{0x5DEECE66D}$ , $b=\\text{0x0B}$ 。 所以在JDKv8中, LCG的输出其实是 $s_i$（48bits） 的前48-22=26 bits 。 显然JDKv8中的参数大小应用在安全系统中，还是太不安全了。 how to attack in JDKv8 在迭代的第一次输出中，LCG就 reveal 26bits of the seed s。 对于s剩下的后22个bits，attacker can easily recover them by exhausitive search(穷举)： 对于每个可能的取值，attacker都能得到一个候选seed $\\hat{s}$ 用 $\\hat{s}$ 来验证我们所直接得到的LCG的输出。 如果 $\\hat{s}$ 验证失败，则到第三步继续穷举。直至验证成功。 当穷举至正确的s时，就可以直接预测LCG的剩余输出。 在现代处理器中，穷举 $2^{22}$ (4 million) 只需要1秒。所以LCG的参数较小时，是很容易attack。 当 $q=2^{512}$ 时，这种穷举的攻击方法就失效了。但是有一种对于LCG的著名攻击方法[1]，即使每次迭代，LCG只输出较少的bits，也能从这些较少的但连续的输出序列中预测出整个LCG输出序列。 Cryptanalysis ：elegant attackWarning of MathSupposeSuppose : q is large (e.g. $q=2^{512}$ ), and $G_{lcg}^{(n)}$ outputs about half the bits of the state s per iteration. 【q很大， $G_{lcg}^{(n)}$ 每次输出s的一半左右的bits】 More precisely, suppose: $w&lt;\\sqrt{q}/c$ for fixed c（e.g. $c=32$ ） 【保证输出s前一半左右bits的这个条件】 Suppose the attacker is given two consecutive outputs of the gnerator $r_i,r_{i+1}\\in \\mathcal{R}$ . 【已知两个连续输出 $r_i,r_{i+1}\\in \\mathcal{R}$ 】 Attacker Knows $r_{i}=\\left\\lfloor s_{i} / w\\right\\rfloor \\quad \\text { and } \\quad r_{i+1}=\\left\\lfloor s_{i+1} / w\\right\\rfloor=\\left\\lfloor\\left(a s_{i}+b \\bmod q\\right) / w\\right\\rfloor$ 【已知： $r_i,r_{i+1},w,a,b,q$；未知： $s_i$ 】 $r_{i} \\cdot w+e_{0}=s \\quad \\text { and } \\quad r_{i+1} \\cdot w+e_{1}=a s+b+q x \\qquad (0\\leq e_0,e_1&lt;w&lt;\\sqrt{q}/c)$ 【 去掉floor符号和mod：$e_0,e_1$ 是 $s_i,s_{i+1}$ 除 $w$ 的余数】 【已知： $r_i,r_{i+1},w,a,b,q$；未知： $s_i,e_0,e_1,x$ 】 re-arranging: put $x$ and $s$ on the left $s=r_{i} \\cdot w+e_{0} \\quad \\text { and } \\quad a s+q x=r_{i+1} w-b+e_{1}$ 【把未知参数s，x放在等式左边，方便写成矩阵形式】 $s \\cdot\\left(\\begin{array}{l}1 \\ a\\end{array}\\right)+x \\cdot\\left(\\begin{array}{l}0 \\ q\\end{array}\\right)=\\boldsymbol{g}+\\boldsymbol{e} \\quad \\text { where } \\quad \\boldsymbol{g}:=\\left(\\begin{array}{c}r_{i} w \\ r_{i+1} w-b\\end{array}\\right) \\quad \\text { and } \\quad \\boldsymbol{e}:=\\left(\\begin{array}{c}e_{0} \\ e_{1}\\end{array}\\right)$ 【已知： $\\boldsymbol{g},a,q$ ，未知：$\\boldsymbol{e},s,x$ 】 to break the generator it suffices to find the vector $\\boldsymbol{u}:=\\boldsymbol{g}+\\boldsymbol{e}$ . 【令 $u\\in {Z}^2$ , $\\boldsymbol{u}:=\\boldsymbol{g}+\\boldsymbol{e}=s \\cdot(1, a)^{\\mathrm{T}}+x \\cdot(0, q)^{\\mathrm{T}}$ 】 【如果我们求出了 $\\boldsymbol{u}$ ，那可以用线性代数的知识解出 $s$ 和 $x$ ,再用 $s$ 来预测PRG的剩下输出】 konws $\\boldsymbol{g}$ , knows $\\boldsymbol{e}$ is shorter, and $|\\boldsymbol{e} |_{\\infty}$ is at most $\\sqrt{q}/c$ , knows that $\\boldsymbol{u}$ is “close” to $\\boldsymbol{g}$ . 【e向量很小，$|\\boldsymbol{e} |_{\\infty}$ 上界是$\\sqrt{q}/c$ ，u离g很近】 Taxicab norm or Manhattan(1-norm) ${\\|}A{\\|}_1=\\max \\{ \\sum|a_{i1}|,\\sum|a_{i2}|,...,\\sum|a_{in}| \\}$ （列和范数，A矩阵每一列元素绝对值之和的最大值） Euclidean norm(2-norm) $\\|\\mathbf{x}\\|=\\left(\\sum_{i=1}^{n}\\left|x_{i}\\right|^{2}\\right)^{1 / 2}$ $\\infty$-范数 $\\|A\\|_{\\infty}=\\max \\{ \\sum|a_{1j}|,\\sum|a_{2j}|,...,\\sum|a_{mj}| \\}$ （行和范数，A矩阵每一行元素绝对值之和的最大值） attack can figure the lattice with attacking LCG. the lattice is generated by the vectors $(1,5)^T$ and $(0,29)^T$ , the attacker has a vector $\\boldsymbol{g}=(9,7)^T$ and wishes to find the closest lattice vector $\\boldsymbol{u}$ . 【上图是 $(1,5)^T$ 和 $(0,29)^T$ 两个向量生成的的格点，希望能从以上格点找到离已知 $\\boldsymbol{g}$ 向量最近的格点】 $\\mathcal{L}_a$ :由 $(1, a)^{\\mathrm{T}},(0, q)^{\\mathrm{T}}$ 作为基向量生成的点集合。 The problem is a special case of a general problem call the closest vector problem: given a lattice $\\mathcal{L}$ and a vector $\\boldsymbol{g}$ ,find a vector in $\\mathcal{L}$ that is closest to $\\mathcal{g}$ . There is an efficient polynomial time algorithm for this problem.[2] 【问题归结于 closest vector problem问题，在已知栅格点集合中找离某一向量最近的点，此问题已有多项式时间算法】 step 8 aboveLemma : * For at least $(1-16/c^2)\\cdot q $ of the a in $\\mathcal{S}_q$ , the lattice $\\mathcal{L}_a\\sub Z_2$ has the following property: for every $\\boldsymbol{g} \\in Z^2$ there is at most one vector $\\boldsymbol{u}\\in \\mathcal{L}_a$ such that $\\|\\boldsymbol{g}-\\boldsymbol{u}\\|_{\\infty}","link":"/2020/03/15/StreamCipher1/"},{"title":"「Cryptography-Dan」:Stream Cipher 2","text":"作为Stream Cipher的第二篇文章。第一部分分析了基于Stream Cipher的两种攻击：第一种是Two time pad,第二种是对与其完整性的攻击，即流密码是可被篡改的。第二部分具体说明了一些使用流密码加密的例子。包括分析基于软件的RC4流密码、基于硬件的CSS流密码和现代的安全流密码:eStream中的Salsa20。 Attack on OTP and stream ciphersAttack1: two time pad is insecureNever use strame cipher key more than once!! why insecure使用相同的PRG(k)加密不同明文时：$$C_1 \\leftarrow m_1 \\oplus \\text{PRG(k)}\\C_2 \\leftarrow m_2 \\oplus \\text{PRG(k)}$$Eavesdropper（窃听者）截获这两段密文 $C_1\\ C_2$ ，对密文进行疑惑操作，可得： $C_1 \\oplus C_2\\rightarrow m_1\\oplus m_2$ 。 在传输中，英语字母是用ASCII编码后再传输，所以这样的编码会带来很多redundancy（冗余），即根据 $m_1\\oplus m_2$ ，可以得到 $m_1\\ m_2$ 。 因此，当一个密钥会被使用多次时，就不应该直接用stream cipher，后面的章节会介绍multi-use ciphers。 Examples: Project Venona(1941-1946)我们已经知道：加密应该用OTP，即一次性密钥。 但是，当时是通过人工掷骰子并记录得到密钥，工作费时费力。因此不得不用生成的密钥加密多条消息。 最后仅凭截获密文，就破译了3000多条消息。 Examples: MS-PPTP(Windows NT)微软在Windows NT的PPTP协议（point to point transfer protocol）中使用的流密码是：RC4。 在这个协议中允许一个端系统向另一个端系统发送加密后的信息。 过程如下： 在一次对话连接中：主机想发送$m_1\\ m_1\\ m_3$ 三条消息进行查询，服务器想发送 $s_1\\ s_1\\ s_3$ 三条消息进行响应。 主机和服务器hava a shared key:k。 知道密钥不能加密多次，于是主机将三条消息进行concatenation（联结）： $m_1||m_2||m_3$ 。 主机用k作为密钥，得到G(k)，进行加密 $[m_1||m_2||m_3]\\oplus\\text{G(k)}$ 。 同样，服务器也将响应消息进行联结： $s_1||s_2||s_3$ 。 服务器也用k作为密钥，得到相同的G(k)，对响应消息进行加密 $[s_1||s_2||s_3]\\oplus\\text{G(k)}$ 。 因此，在一次对话中，主机和服务器都使用了相同的 G(k)进行加密，也就是 two time pad。 如何改进主机和服务器have a shared pair of key, 即主机和服务器都使用不同的key进行加密。 Examples: 802.11b WEPHow it worksWEP(Wired Equivalent Privacy)，有效等效加密，是一种用于IEEE 802.11b的一种安全算法。这个算法设计的很糟糕，现已被WPA所淘汰。 WEP用于Wi-Fi通信，是他的的加密层。 WEP的算法过程如下： 主机和路由器进行通信： 主机和路由 have a shared key。 主机想要发送一段消息，包括明文m和其校验码CRC(m)。 PRG’s seed： IV||k, k is a long term key，IV is a counter. Length of IV: 24 bits. IV的作用：每一次传送数据包时，用IV来改变每次的密钥。 用(IV||k作为密钥，得到PRG(IV||k),使用流密码进行加密传输。 主机直接发送IV和密文。 路由器用收到的IV和k连接，用PRG(IV||k)，对密文解密。 Problems of IV IV 导致的问题1: two time pad Length of IV: 24 bits Related IV after $2^{24}$ (16M frames) 【当发送16百万的帧后，PRG又会重复】 On some 802.11 cards: IV rests to 0 after power cycle. 【在有些单片机上，重启后IV会变成0：每次重启都会使用PRG(0||k)加密】 IV 导致的问题2: related keys 在PRG中，key for frame is related。(IV||k)，k是104 bits, IV 是24 bits，所以key的后104位总是相同的，不同密钥之间的差异也很小。 对RC4 PRG的攻击： Fluhrer, Mantin, and Shamir在2001年:只需要监听 $10^6$ 帧即可破译密钥[1]。 Recent attacks：只需要监听4000帧，即可破译WEP网络中的密钥。 所以，密钥关联是灾难性的。 Avoid related keys！ A better construction对于WEP，一种更好的做法是：将多个要发送的帧联结起来，得到 $m_1||m_2||…||m_n$ 长流，再用PRG对这个长流加密。 如上图所示，k扩展后，被分成很多段，用第一段加密第一帧，第二段加密第二帧……。 这样，加密每一帧的密钥都是一个伪随机密钥。(no relationship, and looks like random)。 当然，更好的解决方法是使用更强的加密算法（WPA2）。 Examples: disk encryption另一个例子是硬盘加密，在这个例子中，你会发现：使用流密码对硬盘加密不是一个好的举措。 如果使用流密码： Alice 想要给Bob写一封邮件，如上图所示。 邮件经过硬盘加密（流密码）后，存入内存块。 Alice 想要对存在这个硬盘中的邮件进行修改。 Alice只把Bob改成了Eve，其他部分都没有变，如上图所示。 保存后，邮件再次经过硬盘加密（流密码）后，存入内存块。 Attacker：他得到了硬盘上最初的密文和修改后的密文。 通过分析，他发现两段密文只有前小部分不同。（用相同的流密码密钥加密，修改后，密文很容易看出变化） 虽然Attacker不知道Alice是怎么修改的，但是他知道了Alice修改的具体位置。 $\\Rightarrow$ attacker得到了他不应该知道的信息，即修改的具体位置。 在硬盘加密中，对于文本内容的修改前后，也使用了相同的密钥段加密不同的消息，即two time pad。 因此在硬盘加密中，不推荐使用流密码。 Two time pad: SummaryNever use stream cipher key more than once!! Network traffic: negotiate new key for every session. Disk encryption: typically do not use a stream cipher. Attack2: no integrity(OTP is malleable)OPTP和Stream Cipher一样，不提供完整性的保证，只提供机密性的保证。 如上图所示： 如果attacke截获：密文 $m\\oplus k$ 。 并用sub-permutation key（子置换密钥）来对密文进行修改，得到新的密文：$(m\\oplus k)\\oplus p$ 新的密文最后解密得到的明文是 $m\\oplus p$ 。 所以对于有修改密文能力的攻击者来说，攻击者很容易修改密文，并且修改后的密文，对原本解密后的明文也有很大的影响。 具体攻击如下： Bob想要发送一封邮件：消息开头是From: Bob，使用OTP加密后，发送密文。 Attacker：截获了这段密文 假设：attacker知道这封邮件是来自Bob。 attacker想修改这封密文邮件，使得它来自others。 于是它用一个子置换密钥对原密文的特定位置（即Bob密文位置）进行操作，得到新的密文：From： Eve。 这个子置换密钥是什么呢？ 如上图所示，Bob的ASCII码是 42 6F 62，Eve的ASCII码是 45 76 65。 那么Bob $\\oplus$ Eve的ASCII码是 07 19 07。 因此这个子置换密钥是07 19 07。 最后收件人进行解密，得到的是明文：From：Eve。 对attacker来说，虽然他不能创建来自Eve的密文，但是他可以通过修改原本的密文，达到相同的目的。 Conclusion: Modifications to ciphertext are undertected and have predictable impact on plaintext. Real-world Stream CiphersOld example(SW): RC4RC4流密码，是Ron RivestRC4在1987年设计的。曾用于secure Web traffic(in the SSL/TLS protocol) 和wireless traffic (in the 802.11b WEP protocol). It is designed to operate on 8-bit processors with little internal memory. At the heart of the RC4 cipher is a PRG, called the RC4 PRG. The PRG maintains an internal state consisting of an array S of 256 bytes plus two additional bytes i,j used as pointers into S. 【RC4 cipher的核心是一个PRG，called the RC4 PRG。这个PRG的内部状态是一个256字节的数组S和两个指向S数组的指针】 RC4 stream cipher generator setup algorithms: 对S数组进行初始化，0-255都只出现一次入下图所示： 伪代码 stream generator: Once tha array S is initialized, the PRG generates pseudo-random output one byte at atime, using the following stream generator: The procedure runs for as long as necessary. Again, the index i runs linearly through the array while the index j jumps around. Security of RC4具体参见「A Graduate Course in Applied Cryptography」的p76-78 挖坑，有空填坑 cryptanalysis of RC4[2] Weakness of RC4 Bias in initial output: Pr[2^nd^ byte=0]=2/256. 如果PRG是随机的，其概率应该是1/256。 而Pr[2^nd^ byte=0]=2/256的结果是：消息的第二个字节不被加密的概率比正常情况多一倍。（0异或不变） 统计的真实情况是，不止第二个字节，前面很多字节的概率很不都均匀。 因此，如果要使用RC4 PRG，从其输出的257个字节开始使用。 Prob. of (0,0) is 1/256^2^ +1/256^3^ . 如果PRG是随机的，00串出现的概率应该是(1/256)^2^ . Related key attackes. 在上小节中「Examples: 802.11b WEP」，WEP使用的RC4流密码，related key对安全通信也是灾难性的。 Old example(HW): CSS (badly broken)The Content Scrambling System (CSS) is a system used for protecting movies on DVD disks. It uses a stream cipher, called the CSS stream cipher, to encrypt movie contents. CSS was designed in the 1980’s when exportable encryption was restricted to 40-bits keys. As a result, CSS encrypts movies using a 40-bits key. 【1980的美国出口法，限制出口的加密算法只能是40位，于是CSS的密钥是40位】[amazing.jpg] While ciphers using 40-bit keys are woefully insecure, we show that the CSS stream cipher is particularly weak and can be broken in far less time than an exhaustive search over all 2^40^ keys. 【虽然40位的密钥本来就不够安全，但是我们能用远小于穷举时间的方法破解CSS】 因为博主也是第一次学，很多东西也不了解。 所以概述性语言，我用教科书的原文记录，附注一些中文。望海涵～ Linear feedback shift register(LFSR)CSS 流密码是由两个LFSR（线性反馈移位寄存器）组成的，除了CSS，还有很多硬件系统是基于LFSR进行加密操作，但无一例外，都被破解了。 DVD encryption (CSS)：2 LFSRs GSM encryption (A5/,2): 3 LFSRs 【全球通信系统】 Bluetooth(E0): 4LFSRs LFSR can be implemented in hardware with few transistors. And a result, stream ciphers built from LFSR are attractive for low-cost consumer electronics such as DVD players, cell phones, and Bluetooth devices. 【LFSR在硬件上运行很快，也很省电，所以虽然基于LFSR的算法都被破解了，但是改硬件有点困难，所以还是有很多系统在使用】 上图是一个8位LFSR{4,3,2,0}。 LFSR是由一组寄存器组成，LFSR每个周期输出一位（即0位）。 有一些位（如上图的4，3，2，0）称为tap positions(出头)，通过这些位计算出feedback bit(反馈位)。 反馈位和寄存器组的未输出位组成新的寄存器组。 伪代码如下： 所以基于LFSR的PGR的seed是寄存器组的初始状态。 how CSS worksCSS的seed=5 bytes=40 bits。 CSS由两个LFSR组成，如下图所示，一个17-bit LFSR，一个25-bit LFSR。 seed of LFSR: 17-bit LFSR: 1||first 2 bytes ，即17位。 25-bit LFSR: 1||last 3 bytes，即25位。 CSS过程： 两个LFSR分别运行8轮，输出8 bits。 两个8bits 相加mod 256（还有加上前一块的进位）即是CSS一轮的输出：one byte at a time. Cryptanalysis of CSS (2^16 time attack)当已知CSS PRG的输出时，我们通过穷举（2^40^ time）破解得到CSS的seed。 但还有一种更快的破解算法，只需要最多2^16^ 的尝试。 破解过程如下： 影片文件一般是MPEG文件，假设我们已知明文MPEG文件的前20个字节。（已知明文的prefix） CSS是流密码，可以通过已知prefix还原出CSS的prefix，即CSS PRG的前20个字节的输出。 For all possible initial settings of 17-bit LFSR do: run 17-it LFSR to get 20 bytes of output. 【先让17-bit输出20个字节】 subtract from CSS prefix $\\Rightarrow$ candidate 20 bytes output of 25-bit LFSR. 【通过还原的CSS PRG的输出，得到25-bit输出的前20个字节】 If consistent with 25-bit LFSR, found correct initial settings of both!! 【具体是如何判别这20个字节是否是一个25-bit LFSR的输出呢？】 假设前三个字节是y1, y2, y3. 那么25-bit LFSR的initial :{1, y1 , y2, y3},其中y都是8 bits. 用这个初始状态生成20个字节，如果和得到的20个字节相同，则正确，否则再次枚举。 当得到了两个LFSR的seed, 就可以得到CSS PRG的全部输出，即可破解。 Modern stream ciphers: eStreammain idea eStream PRG ： $\\{0,1\\}^s\\times R \\rightarrow \\{0,1\\}^n$ (n&gt;&gt;s) seed: ${0,1}^s$ nonce: a non-repeating value for a given key.【就对于确定的seed,nonce绝不重复】 Encryption: $\\text{E(k, m; r)}=\\text{m}\\oplus \\text{PRG(k; r)} $ The pair (k,r) is never used more than once. 【PRG的输入是(k,r), 确保OTP】 eStram: Salsa 20(SW+HW)Salsa20/12 and Salsa20/20 are fast stream ciphers designed by Dan Bernstein in 2005. Salsa 20/12 is one of four Profile 1 stream cipher selected for the eStream portfolio of stream ciphers. eStream is a project that identifies fast and secure stream ciphers that are appropriate for practicle use. Variants of Salsa20/12 and Salsa20/20, called ChaCha12 and ChaCha20 respectively, were proposed by Bernstein in 2008. These stream ciphers have been incorporated into several widely deployed protocols such as TLS and SSH. Salsa20 PRG: $\\{0,1\\}^{128 \\text { or } 256} \\times\\{0,1\\}^{64} \\longrightarrow\\{0,1\\}^{n}$ (max n = 2^73^ bits) Salsa20 PRG $(\\mathrm{k} ; \\mathrm{r}):=\\mathrm{H}(\\mathrm{k},(\\mathrm{r}, 0)) | \\mathrm{H}(\\mathrm{k},(\\mathrm{r}, 1)) | \\ldots$ 通过计数器，使得输出联结，可以输出as long as you want pseudorandom segment. 算法过程如上图所示：Salsa20 PRG $(\\mathrm{k} ; \\mathrm{r}):=\\mathrm{H}(\\mathrm{k},(\\mathrm{r}, 0)) | \\mathrm{H}(\\mathrm{k},(\\mathrm{r}, 1)) | \\ldots$ 32 bytes的{k,r,i}通过扩展得到64 bytes的{ $\\tau_0,k,\\tau_1,r,i,\\tau_2,k,\\tau_3$ }. k :16 bytes的seed. i: 8 bytes的index，计数器。 r: 8 bytes的nonce. $\\tau_{0,1,2,3}$ 都是4 bytes的常数，Salsa20算法说明书上公开确定的值。 64 bytes 通过h函数映射，十轮。 h : invertible function designed to be fast on x86(SEE2). 在x86上有SEE2指令可以直接运行h函数，所以很快。 h是逆函数（也是公开的函数），输出可以通过逆运算得到其输入。 h是一个一一映射的map，每一个64bytes的输入都有唯一对应的64 bytes的输出。 将第十轮H函数的输出和最开始的输入做加法运算，word by word(32位)，即每4 bytes相加。 为什么要有这一步？ h是可逆运算，如果直接将函数的输出作为PRG的输出，那可以通过h的逆运算得到原64 bytes，也就得到了(k; r). Is Salsa20 secure(unpredictable)前文我们通过unpredictable来定义PRG的安全（下一篇文章会给出安全PRG更好的定义），所以Salsa20 安全吗？是否是不可预测的？ Unknown：no known provably secure PRGs. 【不能严格证明是一个安全PRG（后文会继续讲解什么是安全的PRG），如果严格证明了，也就证明了P=NP】 In reality： no known attacks bertter than exhaustive search. 【现实中还没有比穷举更快的算法】 Performance通过下图的比较，如果在系统中需要使用流密码，建议使用eStream。 speed ：该算法每秒加密多少MB的数据。 Reference S. Fluhrer, I. Mantin, and A. Shamir. Weaknesses in the key scheduling algorithm of RC4. In proceedings of selected areas of cryptography (SAC), pages 1-24, 2001. 「A Graduate Course in Applied Cryptography」p76-78:挖坑 待补充","link":"/2020/03/19/StreamCipher2/"},{"title":"「机器学习-李宏毅」：Error","text":"这篇文章叙述了进行regression时，where dose the error come from?这篇文章除了解释了error为什么来自bias和variance，还给出了当error产生时应该怎么办？如何让模型在实践应用中也能表现地和测试时几乎一样的好？ Error在中的2.4节，我们比较了不同的Model。下图为不同Model下，testing data error的变化。 可以发现，随着模型越来越复杂，testing data的error变小一些后，爆炸增大。 越复杂的模型在testing data上不一定能得到好的performance。 所以，where dose the error come from? ：bias and variance Bias and Variance of Estimator用打靶作比，如果你的准心，没有对准靶心，那打出的很多发子弹的中心应该离靶心有一段距离，这就是bias。 但把准心对准靶心，你也不一定能打中靶心，可能会有风速等一系列原因，让子弹落在靶心周围，这就是variance。 上图中，可以直观体现出bias 和 variance的影响。 概率论中 ： 一个通过样本值得到了估计量，有三个评判准则：无偏性、有效性和相和性。 这里的无偏性的偏也就是bias。 概率论中定义：设 $\\hat{\\theta}(X_1,X_2,…,X_n)$ 是未知参数 $\\theta$ 的估计量，若 $E(\\hat{\\theta})=\\theta$ ，则称 $\\hat{\\theta}$ 是 $\\theta$ 的无偏估计。 变量 $x$ ，假设他的期望是 $\\mu$ ，他的方差是 $\\sigma^2$. 对于样本： $x^1,x^2,…,x^N$ ，估计他的期望和方差。 概率论的知识： $m=\\frac{1}{N} \\sum_{n} x^{n} \\quad s^{2}=\\frac{1}{N} \\sum_{n}\\left(x^{n}-m\\right)^{2}$ $E(m)=\\mu$ ，所以用 $m$ 是 $\\mu$ 的无偏估计。(unbiased) 但是 $E\\left[s^{2}\\right]=\\frac{N-1}{N} \\sigma^{2} \\quad \\neq \\sigma^{2}$ ，所以这样的估计是有偏差的。(biased) 因此统计学中用样本估算总体方差都进行了修正。 而在机器学习中，Bias和Variance通常与模型相关。 上图中，假设黑色的线是 true function，红色的线是训练得到的函数，蓝色的线是，训练函数的平均函数。 可见，随着函数模型越来越复杂，bias在变小，但variance也在增大。 右下角图中，红色的线接近铺满了，variance已经很大了，模型过拟合了。 对机器学习中模型对bias影响的直观解释 左图的model简单，右图的model复杂。 简单的model，包含的函数集较小，可能集合圈根本没有包括target（true function），因此在这个model下，无论怎么训练，得到的函数都有 large bias。 而右图中，因为函数非常复杂，所以大概率包含了target，因此训练出的函数可能variacne很大，但有 small bias。 what to do with large bias/variance 上图中，红色的线表示bias的误差，绿色的线表示variance的误差，蓝色的线表示观测的误差。 当模型过于简单时：来自bias的误差会较大，来自vaiance的误差较小，也就是 Large Bias Small Variance 当模型过雨复杂时：来自bias的误差会较小，来自variance的误差会很大，也就是 Small Bias Large Variance 2 case : Underfitting ：If your model cannot even fit the training examples, then you have large bias. Overfitting : If you can fit the traning data, but large error on testing data , then you probably have large variance. With Large BiasFor bias, redesign your model. Add more features as input. A more complex model. 考虑更多的feature；使用稍微复杂些的模型。 With Large Variance More data Regularization (在这篇2.5.2文章中有叙述什么是regularization) Model Selection There is usually a trade-off beween bias and variance. Select a model that balances two kinds of error to minimize total error. 选择模型需要在bias和variance中平衡，尽量使得总error最小。 What you should NOT do: 以上，描述的是这样的一个情形：在traning data中，得到了三个自认不错的模型，kaggle的公开的testing data测试，分别得到三个模型的error，认为第三个模型最好！ 但是，当把kaggle用private的testing data 进行测试时，error肯定是大于0.5的，最好的model也不一定是第三个。 同理，当把我们训练出的model拿来实际应用时，可能会发现情况很糟，并且，这个model可能选的是测试中最好的，但在应用中并不是最好的。 Cross Validation什么是Cross Validation(交叉验证)？ 在机器学习中，就是下图过程： 把Traning Set 分成两个部分：Training Set和Validation Set。 在Training Set部分选出模型。 用Validation Set来判断哪个模型好：计算模型在Validate Set的error。 再用模型预测Testing Set(public)，得到的error一定是比Validation Set中大的。 Not recommend : Not用public testing data的误差结果去调整你的模型。 这样会让模型在public的performance比private的好。 但模型在private testing data的performance才是我们真正关注的。 那么当模型预测private testing set时（投入应用时），能尽最大可能的保证模型和在预测public testing data相近。 N-fold Cross ValidationN-fold Cross Validation（N-折交叉验证）的过程如下： 把Training Set 分为3（3-fold）份，每一次拿其中一份当Validation Set，另外两份当作Training Set。 每一次用Train Set来训练。得到了三个Model。 要判断哪一个Model好？ 每一个Model都计算出不同Validation Set的error。 得到一个Average Error。 最后选这个average error最小的model。 最后应用在public traning set，来评估模型应用在private training set的performance。","link":"/2020/03/15/error/"},{"title":"「机器学习-李宏毅」:HW1-Predict PM2.5","text":"在本篇文章中，用手刻Adagrad完成了「机器学习-李宏毅」的HW1-预测PM2.5的作业。其中包括对数据的处理，训练模型，预测，并使用sklearn toolkit的结果进行比较。有关HW1的相关数据、源代码、预测结果等，欢迎光临小透明的GitHub Task Descriptionkaggle link 从中央气象局网站下载的真实观测资料，必须利用linear regression或其他方法预测PM2.5的值。 观测记录被分为train set 和 test set, 前者是每个月前20天所有资料；后者是从剩下的资料中随机取样出来的。 train.csv: 每个月前20天的完整资料。 test.csv: 从剩下的10天资料中取出240笔资料，每一笔资料都有连续9小时的观测数据，必须以此观测出第十小时的PM2.5. Process Datatrain data如下图，每18行是一天24小时的数据，每个月取了前20天（时间上是连续的小时）。 test data 如下图，每18行是一笔连续9小时的数据，共240笔数据。 最大化training data size 每连续10小时的数据都是train set的data。为了得到更多的data，应该把每一天连起来。即下图这种效果： 每个月就有： $20*24-9=471$ 笔data 123456789# Dictionary: key:month value:month datamonth_data = {}# make data timeline continuousfor month in range(12): temp = np.empty(shape=(18, 20*24)) for day in range(20): temp[:, day*24: (day+1)*24] = data[(month*20+day)*18: (month*20+day+1)*18, :] month_data[month] = temp 筛选需要的Features : 这里，我就只考虑前9小时的PM2.5，当然还可以考虑和PM2.5等相关的氮氧化物等feature。 training data 1234567# x_data v1: only consider PM2.5x_data = np.empty(shape=(12*471, 9))y_data = np.empty(shape=(12*471, 1))for month in range(12): for i in range(471): x_data[month*471+i][:] = month_data[month][9][i: i+9] y_data[month*471+i] = month_data[month][9][i+9] testing data 12345# Testing data featurestest_x = np.empty(shape=(240, 9))for day in range(240): test_x[day, :] = test_data[18*day+9, :]test_x = np.concatenate((np.ones(shape=(240, 1)), test_x), axis=1) Normalization 123456789101112# feature scale: normalizationmean = np.mean(x_data, axis=0)std = np.std(x_data, axis=0)for i in range(x_data.shape[0]): for j in range(x_data.shape[1]): if std[j] != 0: x_data[i][j] = (x_data[i][j] - mean[j]) / std[j]for i in range(test_data.shape[0]): for j in range(test_data.shape[1]): if std[j] != 0: test_data[i][j] = (test_data[i][j] - mean[j])/std[j] Training手刻Adagrad 进行training。（挖坑：RMSprop、Adam[1] Linear Pseudo code 123456Declare weight vector, initial lr ,and # of iterationfor i_th iteration : y’ = the product of train_x and weight vector Loss = y’ - train_y gradient = 2*np.dot((train_x)’, Loss ) weight vector -= learning rate * gradient 其中的矩阵操作时，注意求gradient时矩阵的维度。可参考下图。 Adagrad Pseudo code 123456789Declare weight vector, initial lr ,and # of iterationDeclare prev_gra storing gradients in every previous iterations for i_th iteration : y’ = the inner product of train_x and weight vector Loss = y’ - train_y gradient = 2*np.dot((train_x)’, Loss ) prev_gra += gra**2 ada = np.sqrt(prev_gra) weight vector -= learning rate * gradient / ada 注：代码实现时，将bias存在w[0]处，x_data的第0列全1。因为w和b可以一同更新。（当然，也可以分开更新） Adagrad training 123456789101112131415161718192021# train-adagradbatch = x_data.shape[0] # full batchepoch = 400# some parameters for trainingdim = x_data.shape[1]+1w = np.zeros(shape=(dim, 1)) # concatenate bias = w[0]lr = np.full((dim, 1), 0.8) # learning rategrad = np.empty(shape=(dim, 1)) # gradient of loss to every paragradsum = np.zeros(shape=(dim, 1)) # sum of gradient**2x_data = np.concatenate((np.ones(shape=(x_data.shape[0], 1)), x_data), axis=1)loss_his = np.empty(shape=(epoch, 1))for T in range(epoch): L = y_data - np.dot(x_data, w) loss_his[T] = np.sum(L**2) / x_data.shape[0] grad = (-2)*np.dot(np.transpose(x_data), L) gradsum = gradsum + grad**2 w = w - lr*grad/(gradsum**0.5) Testing1answer = np.dot(test_x, w) Draw and Analysis在每次迭代更新时，我将Loss的值存了下来，以便可视化Loss的变化和更新速度。 Loss的变化如下图：(红色的是sklearn toolkit的loss结果) 此外，在源代码中，使用sklearn toolkit来比较结果。 结果如下： 123456789101112131415161718192021222324252627v1: only consider PM2.5Using sklearnLinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False)bias= [21.37402689]w= [[ 0.00000000e+00] [-5.54801503e-01] [-4.32873874e-01] [ 3.63669814e+00] [-3.99037687e+00] [-9.07364636e-01] [ 8.83495803e+00] [-9.51785135e+00] [ 1.32734655e-02] [ 1.81886444e+01]]In our modelbias= [19.59387132]w= [[-0.14448468] [ 0.39205748] [ 0.26897134] [-1.02415371] [ 1.21151411] [ 2.21925424] [-5.48242478] [ 4.01080346] [13.56369122]] 发现参数有一定差异，于是我在testing时，也把sklearn的结果进行预测比较。 一部分结果如下： 1234567891011121314151617['id', 'value', 'sk_value']['id_0', 3.551092352912313, 5.37766865368331]['id_1', 13.916795471648756, 16.559245678900034]['id_2', 24.811333478647043, 23.5085950470451]['id_3', 5.101440436158914, 6.478306159981166]['id_4', 26.7374726797937, 27.207516152986663]['id_5', 19.43735346531517, 21.916809502961648]['id_6', 22.20460696285646, 24.751295357256392]['id_7', 29.660872382552682, 30.24344042612033]['id_8', 17.5964527734513, 16.64242443764712]['id_9', 56.58017426943178, 59.760988216575115]['id_10', 13.767504260132299, 10.808372404511037]['id_11', 11.743000466164233, 11.526958393801682]['id_12', 59.509878887026105, 64.201008247897]['id_13', 53.19824337746267, 54.3856368053018]['id_14', 21.97191108867921, 24.530720709840974]['id_15', 10.833283625735444, 14.350345549104446] Code有关HW1的相关数据、源代码、预测结果等，欢迎光临小透明的GitHub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137########################## Date: 2020-4-4# Author: FredLau# HW1: predict the PM2.5##########################import sysimport numpy as npimport pandas as pdimport csvfrom sklearn import linear_modelimport matplotlib.pyplot as plt###################### process data# process train dataraw_data = np.genfromtxt('data/train.csv', delimiter=',')data = raw_data[1:, 3:]data[np.isnan(data)] = 0 # process nan# Dictionary: key:month value:month datamonth_data = {}# make data timeline continuousfor month in range(12): temp = np.empty(shape=(18, 20*24)) for day in range(20): temp[:, day*24: (day+1)*24] = data[(month*20+day)*18: (month*20+day+1)*18, :] month_data[month] = temp# x_data v1: only consider PM2.5x_data = np.empty(shape=(12*471, 9))y_data = np.empty(shape=(12*471, 1))for month in range(12): for i in range(471): x_data[month*471+i][:] = month_data[month][9][i: i+9] y_data[month*471+i] = month_data[month][9][i+9]# process test datatest_raw_data = np.genfromtxt('data/test.csv', delimiter=',')test_data = test_raw_data[:, 2:]test_data[np.isnan(test_data)] = 0# feature scale: normalizationmean = np.mean(x_data, axis=0)std = np.std(x_data, axis=0)for i in range(x_data.shape[0]): for j in range(x_data.shape[1]): if std[j] != 0: x_data[i][j] = (x_data[i][j] - mean[j]) / std[j]for i in range(test_data.shape[0]): for j in range(test_data.shape[1]): if std[j] != 0: test_data[i][j] = (test_data[i][j] - mean[j])/std[j]# Testing data featurestest_x = np.empty(shape=(240, 9))for day in range(240): test_x[day, :] = test_data[18*day+9, :]test_x = np.concatenate((np.ones(shape=(240, 1)), test_x), axis=1)################################# train-adagradbatch = x_data.shape[0] # full batchepoch = 400# some parameters for trainingdim = x_data.shape[1]+1w = np.zeros(shape=(dim, 1)) # concatenate bias = w[0]lr = np.full((dim, 1), 0.8) # learning rategrad = np.empty(shape=(dim, 1)) # gradient of loss to every paragradsum = np.zeros(shape=(dim, 1)) # sum of gradient**2x_data = np.concatenate((np.ones(shape=(x_data.shape[0], 1)), x_data), axis=1)loss_his = np.empty(shape=(epoch, 1))for T in range(epoch): L = y_data - np.dot(x_data, w) loss_his[T] = np.sum(L**2) / x_data.shape[0] grad = (-2)*np.dot(np.transpose(x_data), L) gradsum = gradsum + grad**2 w = w - lr*grad/(gradsum**0.5)f = open('output/v1.csv', 'w')sys.stdout = fprint('v1: only consider PM2.5\\n')################################ train by sklearn linear modelprint('Using sklearn')reg = linear_model.LinearRegression()print(reg.fit(x_data, y_data))print('bias=', reg.intercept_)print('w=', reg.coef_.transpose())print('\\n')# In our modelprint('In our model')print('bias=', w[0])print('w=', w[1:])############################ draw change of lossplt.xlim(0, epoch)plt.ylim(0, 10)plt.xlabel('$iteration$', fontsize=16)plt.ylabel('$Loss$', fontsize=16)iteration = np.arange(0, epoch)plt.plot(iteration, loss_his/100, '-', ms=3, lw=2, color='black')sk_w = reg.coef_.transpose()sk_w[0] = reg.intercept_sk_loss = np.sum((y_data - np.dot(x_data, sk_w))**2) / x_data.shape[0]plt.hlines(sk_loss/100, 0, epoch, colors='red', linestyles='solid')plt.legend(['adagrad', 'sklearn'])plt.show()# plt.savefig('output/v1.png')f.close()############### test (sklearn vs our adagradf = open('output/v1test.csv', 'w')sys.stdout = ftitle = ['id', 'value', 'sk_value']answer = np.dot(test_x, w)sk_answer = np.dot(test_x, sk_w)print(title)for i in range(test_x.shape[0]): content = ['id_'+str(i), answer[i][0], sk_answer[i][0]] print(content)f.close() Reference 待完成","link":"/2020/04/06/ml-lee-hw1/"},{"title":"「机器学习-李宏毅」：HW2-Binary Income Predicting","text":"这篇文章中，手刻实现了「机器学习-李宏毅」的HW2-Binary Income Prediction的作业。分别用Logistic Regression和Generative Model实现。包括对数据集的处理，训练模型，可视化，预测等。有关HW2的相关数据、源代码、预测结果等，欢迎光临小透明的GitHub Task introduction and Dataset Kaggle competition: link Task: Binary Classification Predict whether the income of an individual exceeds $50000 or not ? *Dataset: * Census-Income (KDD) Dataset (Remove unnecessary attributes and balance the ratio between positively and negatively labeled data) Feature Format train.csv, test_no_label.csv【都是没有处理过的数据，可作为数据参考和优化参考】 text-based raw data unnecessary attributes removed, positive/negative ratio balanced. X_train, Y_train, X_test【已经处理过的数据，可以直接使用】 discrete features in train.csv =&gt; one-hot encoding in X_train (education, martial state…) continuous features in train.csv =&gt; remain the same in X_train (age, capital losses…). X_train, X_test : each row contains one 510-dim feature represents a sample. Y_train: label = 0 means “&lt;= 50K” 、 label = 1 means “ &gt;50K ” 注：数据集超大，用notepad查看比较舒服；调试时，也可以先调试小一点的数据集。 Logistic RegressionLogistic Regression 原理部分见这篇博客。 Prepare data本文直接使用X_train Y_train X_test 已经处理好的数据集。 1234567891011121314# prepare dataX_train_fpath = './data/X_train'Y_train_fpath = './data/Y_Train'X_test_fpath = './data/X_test'output_fpath = './logistic_output/output_logistic.csv'fpath = './logistic_output/logistic'X_train = np.genfromtxt(X_train_fpath, delimiter=',')Y_train = np.genfromtxt(Y_train_fpath, delimiter=',')X_test = np.genfromtxt(X_test_fpath, delimiter=',')X_train = X_train[1:, 1:]Y_train = Y_train[1:, 1:]X_test = X_test[1:, 1:] 统计一下数据集： 1234567891011train_size = X_train.shape[0]dev_size = X_dev.shape[0]test_size = X_test.shape[0]data_dim = X_train.shape[1]with open(fpath, 'w') as f: f.write('In logistic model:\\n') f.write('Size of Training set: {}\\n'.format(train_size)) f.write('Size of development set: {}\\n'.format(dev_size)) f.write('Size of test set: {}\\n'.format(test_size)) f.write('Dimension of data: {}\\n'.format(data_dim)) 结果如下： 12345In logistic model:Size of Training set: 48830Size of development set: 5426Size of test set: 27622Dimension of data: 510 normalizenormalize data. 对于train data，计算出每个feature的mean和std，保存下来用来normalize test data。 代码如下： 123456789101112131415def _normalization(X, train=True, X_mean=None, X_std=None): # This function normalize columns of X. # Output: # X: normalized data # X_mean, X_std if train: X_mean = np.mean(X, axis=0) X_std = np.std(X, axis=0) for j in range(X.shape[1]): X[:, j] = (X[:, j] - X_mean[j]) / (X_std[j] + 1e-8) # avoid X_std==0 return X, X_mean, X_std # Normalize train_data and test_dataX_train, X_mean, X_std = _normalization(X_train, train=True)X_test, _, _ = _normalization(X_test, train=False, X_mean=X_mean, X_std=X_std) Development set split在logistic regression中使用的gradient，没有closed-form解，所以在train set中划出一部分作为development set 优化参数。 12345678def _train_dev_split(X, Y, dev_ratio=0.25): # This function splits data into training set and development set. train_size = int(X.shape[0] * (1 - dev_ratio)) return X[:train_size], Y[:train_size], X[train_size:], Y[train_size:]# Split data into train data and development datadev_ratio = 0.1X_train, Y_train, X_dev, Y_dev = _train_dev_split(X_train, Y_train, dev_ratio=dev_ratio) Useful function_shuffle(X, Y)本文使用mini-batch gradient。 所以在每次epoch时，以相同顺序同时打乱X_train,Y_train数组，再mini-batch。 1234567np.random.seed(0)def _shuffle(X, Y): # This function shuffles two two list/array, X and Y, together. randomize = np.arange(len(X)) np.random.shuffle(randomize) return X[randomize], Y[randomize] _sigmod(z)计算 $\\frac{1}{1+e^{-z}}$ ，注意：防止溢出，给函数返回值规定上界和下界。 1234def _sigmod(z): # Sigmod function can be used to compute probability # To avoid overflow return np.clip(1/(1.0 + np.exp(-z)), 1e-8, 1-(1e-8)) _f(X, w, b)是sigmod函数的输入，linear part。 输入： X：shape = [size, data_dimension] w：weight vector, shape = [data_dimension, 1] b: bias, scalar 输出： 属于Class 1的概率（Label=0，即收入小于$50k的概率） 123456789def _f(X, w, b): # This function is the linear part of sigmod function # Arguments: # X: input data, shape = [size, data_dimension] # w: weight vector, shape = [data_dimension, 1] # b: bias, scalar # Output: # predict probabilities return _sigmod(np.dot(X, w) + b) _predict(X, w, b)预测Label=0？（0或者1，不是概率） 123def _predict(X, w, b): # This function returns a truth value prediction for each row of X belonging to class1(label=0) return np.around(_f(X, w, b)).astype(np.int) _accuracy(Y_pred, Y_label)计算预测出的结果（0或者1）和真实结果的正确率。 这里使用 $1-\\overline{error}$ 来表示正确率。 12345def _accuracy(Y_pred, Y_label): # This function calculates prediction accuracy # Y_pred: 0 or 1 acc = 1 - np.mean(np.abs(Y_pred - Y_label)) return acc _cross_entropy_loss(y_pred, Y_label)计算预测出的概率（是sigmod的函数输出）和真实结果的交叉熵。 计算公式为： $\\sum_n {C(y_{pred},Y_{label})}=-\\sum[Y_{label}\\ln{y_{pred}}+(1-Y_{label})\\ln(1-{y_{pred}})]$ 12345678def _cross_entropy_loss(y_pred, Y_label): # This function calculates the cross entropy of Y_pred and Y_label # # Argument: # y_pred: predictions, float vector # Y_label: truth labels, bool vector cross_entropy = - np.dot(Y_label.T, np.log(y_pred)) - np.dot((1 - Y_label).T, np.log(1 - y_pred)) return cross_entropy[0][0] _gradient(X, Y_label, w, b)和Regression的最小二乘一样。（严谨的说，最多一个系数不同） 12345678def _gradient(X, Y_label, w, b): # This function calculates the gradient of cross entropy # X, Y_label, shape = [batch_size, ] y_pred = _f(X, w, b) pred_error = Y_label - y_pred w_grad = - np.dot(X.T, pred_error) b_grad = - np.sum(pred_error) return w_grad, float(b_grad) Training (Adagrad)初始化一些参数。 这里特别注意 : 由于adagrad的参数更新是 $w \\longleftarrow w-\\eta \\frac{gradient}{ \\sqrt{gradsum}}$ . 防止除0，初始化gradsum的值为一个较小值。 123456789101112# training by logistic model# Initial weights and biasw = np.zeros((data_dim, 1))b = np.float(0.)w_grad_sum = np.full((data_dim, 1), 1e-8) # avoid divided by zerosb_grad_sum = np.float(1e-8)# Some parameters for trainingepoch = 20batch_size = 2**3learning_rate = 0.2 AdagradAagrad具体原理见这篇博客的1.2节。 迭代更新时，每次epoch计算一次loss和accuracy，以便可视化更新过程，调整参数。 12345678910111213141516171819202122232425262728293031323334353637# Keep the loss and accuracy history at every epoch for plottingtrain_loss = []dev_loss = []train_acc = []dev_acc = []# Iterative trainingfor it in range(epoch): # Random shuffle at every epoch X_train, Y_train = _shuffle(X_train, Y_train) # Mini-batch training for id in range(int(np.floor(train_size / batch_size))): X = X_train[id*batch_size: (id+1)*batch_size] Y = Y_train[id*batch_size: (id+1)*batch_size] # calculate gradient w_grad, b_grad = _gradient(X, Y, w, b) # adagrad gradient update w_grad_sum = w_grad_sum + w_grad**2 b_grad_sum = b_grad_sum + b_grad**2 w_ada = np.sqrt(w_grad_sum) b_ada = np.sqrt(b_grad_sum) w = w - learning_rate * w_grad / np.sqrt(w_grad_sum) b = b - learning_rate * b_grad / np.sqrt(b_grad_sum) # compute loss and accuracy of training set and development set at every epoch y_train_pred = _f(X_train, w, b) Y_train_pred = np.around(y_train_pred) train_loss.append(_cross_entropy_loss(y_train_pred, Y_train)/train_size) train_acc.append(_accuracy(Y_train_pred, Y_train)) y_dev_pred = _f(X_dev, w, b) Y_dev_pred = np.around(y_dev_pred) dev_loss.append(_cross_entropy_loss(y_dev_pred, Y_dev)/dev_size) dev_acc.append(_accuracy(y_dev_pred, Y_dev)) Loss &amp; accuracy输出最后一次迭代的loss和accuracy。 结果如下： 1234Training loss: 0.2933570286596322Training accuracy: 0.8839238173254147Development loss: 0.31029505347634456Development accuracy: 0.8336166253549906 画出loss 和 accuracy的更新过程： loss： accuracy： 由于Feature数量较大，将权重影响最大的feature输出看看： 12345678910Other Rel &lt;18 spouse of subfamily RP: [7.11323764] Grandchild &lt;18 ever marr not in subfamily: [6.8321061] Child &lt;18 ever marr RP of subfamily: [6.77322397] Other Rel &lt;18 ever marr RP of subfamily: [6.76688406] Other Rel &lt;18 never married RP of subfamily: [6.37488958] Child &lt;18 spouse of subfamily RP: [5.97717831] United-States: [5.53932651] Grandchild 18+ spouse of subfamily RP: [5.42948497] United-States: [5.41543809] Mexico: [4.79920763] Code完整数据集、代码等，欢迎光临小透明GitHub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222################## Data:2020-04-05# Author: Fred Lau# ML-Lee: HW2 : Binary Classification###########################################################import numpy as npimport csvimport sysimport matplotlib.pyplot as plt########################################################### prepare dataX_train_fpath = './data/X_train'Y_train_fpath = './data/Y_Train'X_test_fpath = './data/X_test'output_fpath = './logistic_output/output_logistic.csv'fpath = './logistic_output/logistic'X_train = np.genfromtxt(X_train_fpath, delimiter=',')Y_train = np.genfromtxt(Y_train_fpath, delimiter=',')X_test = np.genfromtxt(X_test_fpath, delimiter=',')X_train = X_train[1:, 1:]Y_train = Y_train[1:, 1:]X_test = X_test[1:, 1:]def _normalization(X, train=True, X_mean=None, X_std=None): # This function normalize columns of X. # Output: # X: normalized data # X_mean, X_std if train: X_mean = np.mean(X, axis=0) X_std = np.std(X, axis=0) for j in range(X.shape[1]): X[:, j] = (X[:, j] - X_mean[j]) / (X_std[j] + 1e-8) # avoid X_std==0 return X, X_mean, X_stddef _train_dev_split(X, Y, dev_ratio=0.25): # This function splits data into training set and development set. train_size = int(X.shape[0] * (1 - dev_ratio)) return X[:train_size], Y[:train_size], X[train_size:], Y[train_size:]# Normalize train_data and test_dataX_train, X_mean, X_std = _normalization(X_train, train=True)X_test, _, _ = _normalization(X_test, train=False, X_mean=X_mean, X_std=X_std)# Split data into train data and development datadev_ratio = 0.1X_train, Y_train, X_dev, Y_dev = _train_dev_split(X_train, Y_train, dev_ratio=dev_ratio)train_size = X_train.shape[0]dev_size = X_dev.shape[0]test_size = X_test.shape[0]data_dim = X_train.shape[1]with open(fpath, 'w') as f: f.write('In logistic model:\\n') f.write('Size of Training set: {}\\n'.format(train_size)) f.write('Size of development set: {}\\n'.format(dev_size)) f.write('Size of test set: {}\\n'.format(test_size)) f.write('Dimension of data: {}\\n'.format(data_dim))np.random.seed(0)################################################################ useful functiondef _shuffle(X, Y): # This function shuffles two two list/array, X and Y, together. randomize = np.arange(len(X)) np.random.shuffle(randomize) return X[randomize], Y[randomize]def _sigmod(z): # Sigmod function can be used to calculate probability # To avoid overflow return np.clip(1 / (1.0 + np.exp(-z)), 1e-8, 1 - (1e-8))def _f(X, w, b): # This is the logistic function, parameterized by w and b # # Arguments: # X: input data, shape = [batch_size, data_dimension] # w: weight vector, shape = [data_dimension, 1] # b: bias, scalar # Output: # predict probability of each row of X being positively labeled, shape = [batch_size, 1] return _sigmod(np.dot(X, w) + b)def _predict(X, w, b): # This fucntion returns a truth value prediction for each row of X by logistic regression return np.around(_f(X, w, b)).astype(np.int)def _accuracy(Y_pred, Y_label): # This function calculates prediction accuracy # Y_pred: 0 or 1 acc = 1 - np.mean(np.abs(Y_pred - Y_label)) return accdef _cross_entropy_loss(y_pred, Y_label): # This function calculates the cross entropy of Y_pred and Y_label # # Argument: # y_pred: predictions, float vector # Y_label: truth labels, bool vector cross_entropy = - np.dot(Y_label.T, np.log(y_pred)) - np.dot((1 - Y_label).T, np.log(1 - y_pred)) return cross_entropy[0][0]def _gradient(X, Y_label, w, b): # This function calculates the gradient of cross entropy # X, Y_label, shape = [batch_size, ] y_pred = _f(X, w, b) pred_error = Y_label - y_pred w_grad = - np.dot(X.T, pred_error) b_grad = - np.sum(pred_error) return w_grad, float(b_grad)######################################## training by logistic model# Initial weights and biasw = np.zeros((data_dim, 1))b = np.float(0.)w_grad_sum = np.full((data_dim, 1), 1e-8) # avoid divided by zerosb_grad_sum = np.float(1e-8)# Some parameters for trainingepoch = 20batch_size = 2**3learning_rate = 0.2# Keep the loss and accuracy history at every epoch for plottingtrain_loss = []dev_loss = []train_acc = []dev_acc = []# Iterative trainingfor it in range(epoch): # Random shuffle at every epoch X_train, Y_train = _shuffle(X_train, Y_train) # Mini-batch training for id in range(int(np.floor(train_size / batch_size))): X = X_train[id*batch_size: (id+1)*batch_size] Y = Y_train[id*batch_size: (id+1)*batch_size] # calculate gradient w_grad, b_grad = _gradient(X, Y, w, b) # adagrad gradient update w_grad_sum = w_grad_sum + w_grad**2 b_grad_sum = b_grad_sum + b_grad**2 w_ada = np.sqrt(w_grad_sum) b_ada = np.sqrt(b_grad_sum) w = w - learning_rate * w_grad / np.sqrt(w_grad_sum) b = b - learning_rate * b_grad / np.sqrt(b_grad_sum) # compute loss and accuracy of training set and development set at every epoch y_train_pred = _f(X_train, w, b) Y_train_pred = np.around(y_train_pred) train_loss.append(_cross_entropy_loss(y_train_pred, Y_train)/train_size) train_acc.append(_accuracy(Y_train_pred, Y_train)) y_dev_pred = _f(X_dev, w, b) Y_dev_pred = np.around(y_dev_pred) dev_loss.append(_cross_entropy_loss(y_dev_pred, Y_dev)/dev_size) dev_acc.append(_accuracy(y_dev_pred, Y_dev))with open(fpath, 'a') as f: f.write('Training loss: {}\\n'.format(train_loss[-1])) f.write('Training accuracy: {}\\n'.format(train_acc[-1])) f.write('Development loss: {}\\n'.format(dev_loss[-1])) f.write('Development accuracy: {}\\n'.format(dev_acc[-1]))#################### Plotting Loss and accuracy curve# Loss curveplt.plot(train_loss, label='train')plt.plot(dev_loss, label='dev')plt.title('Loss')plt.legend()plt.savefig('./logistic_output/loss.png')plt.show()plt.plot(train_acc, label='train')plt.plot(dev_acc, label='dev')plt.title('Accuracy')plt.legend()plt.savefig('./logistic_output/acc.png')plt.show()################################## Predictpredictions = _predict(X_test, w, b)with open(output_fpath, 'w') as f: f.write('id, label\\n') for id, label in enumerate(predictions): f.write('{}, {}\\n'.format(id, label[0]))################################ Output the weights and biasind = (np.argsort(np.abs(w), axis=0)[::-1]).reshape(1, -1)with open(X_test_fpath) as f: content = f.readline().strip('\\n').split(',')content = content[1:]with open(fpath, 'a') as f: for i in ind[0, 0: 10]: f.write('{}: {}\\n'.format(content[i], w[i])) Generative ModelGenerative Model 原理部分见 这篇博客 Prepare data这部分和Logistic regression一样。 只是，因为generative model有closed-form solution，不需要划分development set。 12345678910111213141516171819202122232425262728293031323334353637383940# Prepare dataX_train_fpath = './data/X_train'Y_train_fpath = './data/Y_train'X_test_fpath = './data/X_test'output_fpath = './generative_output/output_{}.csv'fpath = './generative_output/generative'X_train = np.genfromtxt(X_train_fpath, delimiter=',')Y_train = np.genfromtxt(Y_train_fpath, delimiter=',')X_test = np.genfromtxt(X_test_fpath, delimiter=',')X_train = X_train[1:, 1:]Y_train = Y_train[1:, 1:]X_test = X_test[1:, 1:]def _normalization(X, train=True, X_mean=None, X_std=None): # This function normalize columns of X # Output: # X: normalized data # X_mean, X_std if train: X_mean = np.mean(X, axis=0) X_std = np.std(X, axis=0) for j in range(X.shape[1]): X[:, j] = (X[:, j] - X_mean[j]) / (X_std[j] + 1e-8) # avoid X_std==0 return X, X_mean, X_std# Normalize train_data and test_dataX_train, X_mean, X_std = _normalization(X_train, train=True)X_test, _, _ = _normalization(X_test, train=False, X_mean=X_mean, X_std=X_std)train_size = X_train.shape[0]test_size = X_test.shape[0]data_dim = X_train.shape[1]with open(fpath, 'w') as f: f.write('In generative model:\\n') f.write('Size of training data: {}\\n'.format(train_size)) f.write('Size of test set: {}\\n'.format(test_size)) f.write('Dimension of data: {}\\n\\n'.format(data_dim)) Useful functions12345678910111213141516171819202122232425# Useful functionsdef _sigmod(z): # Sigmod function can be used to compute probability # To avoid overflow return np.clip(1/(1.0 + np.exp(-z)), 1e-8, 1-(1e-8))def _f(X, w, b): # This function is the linear part of sigmod function # Arguments: # X: input data, shape = [size, data_dimension] # w: weight vector, shape = [data_dimension, 1] # b: bias, scalar # Output: # predict probabilities return _sigmod(np.dot(X, w) + b)def _predict(X, w, b): # This function returns a truth value prediction for each row of X belonging to class1(label=0) return np.around(_f(X, w, b)).astype(np.int)def _accuracy(Y_pred, Y_label): # This function computes prediction accuracy # Y_pred: 0 or 1 acc = 1 - np.mean(np.abs(Y_pred - Y_label)) return acc Training公式再推导计算公式： $$ \\begin{equation}\\begin{aligned}P\\left(C_{1} | x\\right)&=\\frac{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)}{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)+P\\left(x | C_{2}\\right) P\\left(C_{2}\\right)}\\\\&=\\frac{1}{1+\\frac{P\\left(x | C_{2}\\right) P\\left(C_{2}\\right)}{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)}}\\\\&=\\frac{1}{1+\\exp (-z)} =\\sigma(z)\\qquad(z=\\ln \\frac{P\\left(x | C_{1}\\right) P\\left(C_{1}\\right)}{P\\left(x | C_{2}\\right) P\\left(C_{2}\\right)}\\end{aligned}\\end{equation} $$ 计算z的过程： 首先计算Prior Probability。 假设模型是Gaussian的，算出 $\\mu_1,\\mu_2 ,\\Sigma$ 的closed-form solution 。 根据 $\\mu_1,\\mu_2,\\Sigma$ 计算出 $w,b$ 。 计算Prior Probability。 程序中用list comprehension处理较简单。 123# compute in-class meanX_train_0 = np.array([x for x, y in zip(X_train, Y_train) if y == 0])X_train_1 = np.array([x for x, y in zip(X_train, Y_train) if y == 1]) 计算 $\\mu_1,\\mu_2 ,\\Sigma$ （Gaussian） $\\mu_0=\\frac{1}{C0} \\sum_{n=1}^{C0} x^{n} $ (Label=0) $\\mu_1=\\frac{1}{C1} \\sum_{n=1}^{C1} x^{n} $ (Label=0) $\\Sigma_0=\\frac{1}{C0} \\sum_{n=1}^{C0}\\left(x^{n}-\\mu^{}\\right)^{T}\\left(x^{n}-\\mu^{}\\right)$ (注意 ：这里的 $x^n,\\mu$ 都是行向量，注意转置的位置） $\\Sigma_1=\\frac{1}{C1} \\sum_{n=1}^{C1}\\left(x^{n}-\\mu^{}\\right)^{T}\\left(x^{n}-\\mu^{}\\right)$ $\\Sigma=(C0 \\times\\Sigma_0+C1\\times\\Sigma_1)/(C0+C1)$ (shared covariance) 123456789101112131415mean_0 = np.mean(X_train_0, axis=0)mean_1 = np.mean(X_train_1, axis=0)# compute in-class covariancecov_0 = np.zeros(shape=(data_dim, data_dim))cov_1 = np.zeros(shape=(data_dim, data_dim))for x in X_train_0: # (D,1)@(1,D) np.matmul(np.transpose([x]), x) cov_0 += np.matmul(np.transpose([x - mean_0]), [x - mean_0]) / X_train_0.shape[0]for x in X_train_1: cov_1 += np.dot(np.transpose([x - mean_1]), [x - mean_1]) / X_train_1.shape[0]# shared covariancecov = (cov_0 * X_train_0.shape[0] + cov_1 * X_train_1.shape[0]) / (X_train.shape[0]) 计算 $w,b$ 在 这篇博客中的第2小节中的公式推导中， $x^n,\\mu$ 都是列向量，公式如下： $$ z=\\left(\\mu^{1}-\\mu^{2}\\right)^{T} \\Sigma^{-1} x-\\frac{1}{2}\\left(\\mu^{1}\\right)^{T} \\Sigma^{-1} \\mu^{1}+\\frac{1}{2}\\left(\\mu^{2}\\right)^{T} \\Sigma^{-1} \\mu^{2}+\\ln \\frac{N_{1}}{N_{2}} $$ $w^T=\\left(\\mu^{1}-\\mu^{2}\\right)^{T} \\Sigma^{-1} \\qquad b=-\\frac{1}{2}\\left(\\mu^{1}\\right)^{T} \\Sigma^{-1} \\mu^{1}+\\frac{1}{2}\\left(\\mu^{2}\\right)^{T} \\Sigma^{-1} \\mu^{2}+\\ln \\frac{N_{1}}{N_{2}}$ 但是 ，一般我们在处理的数据集，$x^n,\\mu$ 都是行向量。推导过程相同，公式如下： （主要注意转置和矩阵乘积顺序） $$ z=x\\cdot \\Sigma^{-1}\\left(\\mu^{1}-\\mu^{2}\\right)^{T} -\\frac{1}{2} \\mu^{1}\\Sigma^{-1}\\left(\\mu^{1}\\right)^{T}+\\frac{1}{2}\\mu^{2}\\Sigma^{-1} \\left(\\mu^{2}\\right)^{T} +\\ln \\frac{N_{1}}{N_{2}} $$ $w=\\Sigma^{-1}\\left(\\mu^{1}-\\mu^{2}\\right)^{T} \\qquad b=-\\frac{1}{2} \\mu^{1}\\Sigma^{-1}\\left(\\mu^{1}\\right)^{T}+\\frac{1}{2}\\mu^{2}\\Sigma^{-1} \\left(\\mu^{2}\\right)^{T} +\\ln \\frac{N_{1}}{N_{2}}$ 但是，协方差矩阵的逆怎么求呢？ numpy中有直接求逆矩阵的方法(np.linalg.inv)，但当该矩阵是nearly singular，是奇异矩阵时，就会报错。 而我们的协方差矩阵（510*510）很大，很难保证他不是奇异矩阵。 于是，有一个 牛逼 强大的数学方法，叫SVD(singular value decomposition, 奇异值分解) 。 原理步骤我……还没有完全搞清楚QAQ（先挖个坑）[1] 利用SVD，可以将任何一个矩阵（即使是奇异矩阵），分界成 $A=u s v^T$ 的形式：其中u,v都是标准正交矩阵，s是对角矩阵。（numpy.linalg.svd方法实现了SVD） 可以利用SVD求矩阵的伪逆 $A=u s v^T$ u,v是标准正交矩阵，其逆矩阵等于其转置矩阵 s是对角矩阵，其”逆矩阵“（注意s矩阵的对角也可能有0元素） 将非0元素取倒数即可。 $A^{-1}=v s^{-1} u$ 计算 $w,b$ 的代码如下： 123456789101112131415# compute weights and bias# Since covariance matrix may be nearly singular, np.linalg.in() may give a large numerical error.# Via SVD decomposition, one can get matrix inverse efficiently and accurately.# cov = u@s@vh# cov_inv = dot(vh.T * 1 / s, u.T)u, s, vh = np.linalg.svd(cov, full_matrices=False)s_inv = s # s_inv avoid &lt;1e-8for i in range(s.shape[0]): if s[i] &lt; (1e-8): break s_inv[i] = 1./s[i]cov_inv = np.matmul(vh.T * s_inv, u.T)w = np.matmul(cov_inv, np.transpose([mean_0 - mean_1]))b = (-0.5) * np.dot(mean_0, np.matmul(cov_inv, mean_0.T)) + (0.5) * np.dot(mean_1, np.matmul(cov_inv, mean_1.T)) + np.log(float(X_train_0.shape[0]) / X_train_1.shape[0]) Accuracy accuracy结果： 1Training accuracy: 0.8756450899439694 也将权重较大的feature输出看看： 12345678910age: [-0.51867291] Masters degree(MA MS MEng MEd MSW MBA): [-0.49912643] Spouse of householder: [0.49786805]weeks worked in year: [-0.44710924] Spouse of householder: [-0.43305697]capital gains: [-0.42608727]dividends from stocks: [-0.41994666] Doctorate degree(PhD EdD): [-0.39310961]num persons worked for employer: [-0.37345994] Prof school degree (MD DDS DVM LLB JD): [-0.35594107] Code具体数据集和代码，欢迎光临小透明GitHub 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import numpy as npnp.random.seed(0)############################################### Prepare dataX_train_fpath = './data/X_train'Y_train_fpath = './data/Y_train'X_test_fpath = './data/X_test'output_fpath = './generative_output/output_{}.csv'fpath = './generative_output/generative'X_train = np.genfromtxt(X_train_fpath, delimiter=',')Y_train = np.genfromtxt(Y_train_fpath, delimiter=',')X_test = np.genfromtxt(X_test_fpath, delimiter=',')X_train = X_train[1:, 1:]Y_train = Y_train[1:, 1:]X_test = X_test[1:, 1:]def _normalization(X, train=True, X_mean=None, X_std=None): # This function normalize columns of X # Output: # X: normalized data # X_mean, X_std if train: X_mean = np.mean(X, axis=0) X_std = np.std(X, axis=0) for j in range(X.shape[1]): X[:, j] = (X[:, j] - X_mean[j]) / (X_std[j] + 1e-8) # avoid X_std==0 return X, X_mean, X_std# Normalize train_data and test_dataX_train, X_mean, X_std = _normalization(X_train, train=True)X_test, _, _ = _normalization(X_test, train=False, X_mean=X_mean, X_std=X_std)train_size = X_train.shape[0]test_size = X_test.shape[0]data_dim = X_train.shape[1]with open(fpath, 'w') as f: f.write('In generative model:\\n') f.write('Size of training data: {}\\n'.format(train_size)) f.write('Size of test set: {}\\n'.format(test_size)) f.write('Dimension of data: {}\\n\\n'.format(data_dim))######################### Useful functionsdef _sigmod(z): # Sigmod function can be used to compute probability # To avoid overflow return np.clip(1/(1.0 + np.exp(-z)), 1e-8, 1-(1e-8))def _f(X, w, b): # This function is the linear part of sigmod function # Arguments: # X: input data, shape = [size, data_dimension] # w: weight vector, shape = [data_dimension, 1] # b: bias, scalar # Output: # predict probabilities return _sigmod(np.dot(X, w) + b)def _predict(X, w, b): # This function returns a truth value prediction for each row of X belonging to class1(label=0) return np.around(_f(X, w, b)).astype(np.int)def _accuracy(Y_pred, Y_label): # This function computes prediction accuracy # Y_pred: 0 or 1 acc = 1 - np.mean(np.abs(Y_pred - Y_label)) return acc######################## Generative Model: closed-form solution, can be computed directly# compute in-class meanX_train_0 = np.array([x for x, y in zip(X_train, Y_train) if y == 0])X_train_1 = np.array([x for x, y in zip(X_train, Y_train) if y == 1])mean_0 = np.mean(X_train_0, axis=0)mean_1 = np.mean(X_train_1, axis=0)# compute in-class covariancecov_0 = np.zeros(shape=(data_dim, data_dim))cov_1 = np.zeros(shape=(data_dim, data_dim))for x in X_train_0: # (D,1)@(1,D) np.matmul(np.transpose([x]), x) cov_0 += np.matmul(np.transpose([x - mean_0]), [x - mean_0]) / X_train_0.shape[0]for x in X_train_1: cov_1 += np.dot(np.transpose([x - mean_1]), [x - mean_1]) / X_train_1.shape[0]# shared covariancecov = (cov_0 * X_train_0.shape[0] + cov_1 * X_train_1.shape[0]) / (X_train.shape[0])# compute weights and bias# Since covariance matrix may be nearly singular, np.linalg.in() may give a large numerical error.# Via SVD decomposition, one can get matrix inverse efficiently and accurately.# cov = u@s@vh# cov_inv = dot(vh.T * 1 / s, u.T)u, s, vh = np.linalg.svd(cov, full_matrices=False)s_inv = s # s_inv avoid &lt;1e-8for i in range(s.shape[0]): if s[i] &lt; (1e-8): break s_inv[i] = 1./s[i]cov_inv = np.matmul(vh.T * s_inv, u.T)w = np.matmul(cov_inv, np.transpose([mean_0 - mean_1]))b = (-0.5) * np.dot(mean_0, np.matmul(cov_inv, mean_0.T)) + (0.5) * np.dot(mean_1, np.matmul(cov_inv, mean_1.T)) + np.log(float(X_train_0.shape[0]) / X_train_1.shape[0])# compute accuracy on training setY_train_pred = 1 - _predict(X_train, w, b)with open(fpath, 'a') as f: f.write('\\nTraining accuracy: {}\\n'.format(_accuracy(Y_train_pred, Y_train)))# Predictpredictions = 1 - _predict(X_test, w, b)with open(output_fpath.format('generative'), 'w') as f: f.write('id, label\\n') for i, label in enumerate(predictions): f.write('{}, {}\\n'.format(i, label))# Output the most significant weightwith open(X_test_fpath) as f: content = f.readline().strip('\\n').split(',')content = content[1:]ind = np.argsort(np.abs(np.concatenate(w)))[::-1]with open(fpath, 'a')as f: for i in ind[0:10]: f.write('{}: {}\\n'.format(content[i], w[i])) Reference SVD原理，待补充","link":"/2020/04/15/ml-lee-hw2/"},{"title":"「Python」：Module & Method","text":"长期记录帖：关于遇到过的那些Python 的Packets &amp; Module &amp; Method &amp; Attribute。中英记录。 Trickylist comprehension List comprehension provides a concise way to create lists. e.g. : squares = [x**2 for x in range(10)] A list comprehension consists of brackets containing an expression followed by a for clause, then zero or more for or if clauses. The result will be a new list resulting from evaluating the expression in the context of the for and if clauses which follow it. e.g. : Double loop: [(x,y) for x in [1,2,3] for y in [3,1,4] if x != y] 输出7个 e.g. : (Using zip() to loop together): [(x, y) for x,y in zip([1,2,3], [3,1,4]) if x!=y] 输出2个 Python-Build functionprint print(*objects, sep=’ ‘, end=’\\n’, file=sys.stdout) len Return the length(the number of items) of an object. str.format() 字符串格式化 eg: “{} {}”.format(“Hello”,”World) ‘Hello World’ zip(*iterables) Make an iterator that aggregates【聚集】 elements from each of the iterales. Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. 【返回一个元组的迭代器】 使用zip可以同时对多个迭代器进行迭代 enumerate Enumerate is a built-in funciton of Python. It allows us to loop over something and have an automatic counter. e.g. for counter, value in enumerate(some_list): print(counter, value) e.g. : an optional argument: tell enumerate from where to start the index. for c, value in enumerate(my_list, 1): print(c, value) with open(path) as f: 由于读写文件都可能产生IOError，一旦出错，后面的f.close()就不会调用。 用try……finally来实现，比较麻烦。 try: ​ f = open(path, ‘r’) ​ print(f.read()) finally: ​ if f: ​ f.close() 用with as 简化 with open(path, ‘r’) as f: ​ print(f.read()) numpynumpy.argsort numpy.argsort(a, axis=-1, kind=None, order=None) Returns the indices that would sort an array. Perform an indirect sort along the given axis using the algorithm specified by the kind keyword. It returns an array of indices of the same shape as a that index data along the given axis in sorted order. Parameters: a :array_like. axis : int or None, optional Axis along which to sort. The default is -1(the last axis). 【默认按照最后一个维度】 2-D: axis = 0按列排序 2-D: axis = 1 按行排序 kind :{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional The default is ‘quicksort’ Return: index_array: ndarray, int.【返回的是降序排列的索引数组】 e.g.: x = np.array([5, 1, 2]) np.argsort(x) # 降序 array([1,2,0]) np.argsort(-x) # 升序 array([0,2,1]) Linear algebra(numpy.linalg)numpy.dot numpy.dot(a,b) Dot product of two arrays. If both a and b are 1-D arrays, it is inner porduct of vectors. If both a and b are 2-D arrays, it is matrix multiplication, but using matmul is preferred. Id either a or b is 0-D(scalar), it is equivalent to multiply and using numpy.multiply(a, b) or a*b is preferred. …… numpy.matmul Matrix product of two arrays. numpy.matmul(x1, x2) numpy.linalg.inv(a) Compute the inverse of a matrix. Given a square matrix a, return the matrix ainv satisfying dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])/ numpy.linalg.inv(a) Parameters: a :(…, M, M) array_like. Matrix to e inverted. Return: ainv. numpy.linalg.svd numpy.linalg.svd(a, full_matrices=True, compute_uv=True, hermitian=False) Singular Value Decomposition 矩阵的奇异值分解 A = u @ s @ vh u, vh是标准正交矩阵, inv(u) = uh s是对角矩阵 Parameters: a :array_like, a real or complex array with a.ndim &gt;=2 full_matrices :bool, optional. True(default) If True, u and vh have the shapes(…, M, M) and (…, N, N), respectively. Otherwise, the shapes are(…, M, K) and (…, K, N), respectively, where K = min(M,N) compute_uv : bool, optional.True(default) Whether or not to compute u and vh in addition to s.【注，vh就是v的转置】 Return： u: array s: array vh:array numpy.zeros numpy.zeros(shape, dtype=float, order=’C’) Return a new array of given shape and type, filled with zeros. parameters: shape: int or truple of ints. e.g.,(2,3) or 2 dtype: data-type, optional.(Defaults is numpy.float64) oder: optional Returns: out ndarray numpy.full numpy.full(shape, fill_value, dtype=None) Return a new array of given shape and type, filled with fill_value. parameters: shape :int or sequence of ints (2,3) or 2 fill_value :scalar dtype :data-type, optional numpy.arange numpy.arange([start, ]stop, [step, ]dtype=None) Return evenly spaced values within a given interval. parameters: start: number, optional. (Defaults is 0) stop :number. [start,stop) step :number, optional(Defaults is 1) dtype : Returns :ndarray differ with built-in range function numpy.arange returnan ndarray rathan than a list. numpy.arange’s step can be float. numpy.meshgrid numpy.meshgrid(x, y) 生成用x向量为行，y向量为列的矩阵（坐标系） 返回 X矩阵和Y矩阵 X矩阵：网格上所有点的x值 Y矩阵：网格上所有点的y值 e.g., X, Y = np.meshgrid(x, y) 【X,Y 都是网格点坐标矩阵】 numpy.genfromtext numpy.genfromtxt (fname, delimiter=None) Load data from a text file, with missing values handled as specified. Each line past the first skip_header lines is split at the delimiter character, and characters following the comments characters are discarded. Parameters: fname :file, str, list of str, generator. dtype :dtype, optional. delimiter :str, int, or sequence, optional. (default = whitespace) The strin used to separate values. Python的列表读取处理数据很慢，numpy.genfromtext就很棒。 numpy.isnan numpy.isnan(x) Test element-wise for NaN(Not a number) and return result as a boolean array. Parameters: x :array_like Returns: y:ndarray or bool. True where x is NaN, false otherwise. numpy.empty nmpy.empty(shape, dtype=float, order=’C’) Return a new arry of given shape and type, without initializing entries. Parameters: shape :int or tuple of int dtype :data-type,optional Default is numpy.float64. Returns: out: ndarray numpy.reshape numpy.reshape(a, newshape, order=’C’) Gives a new shape to an array without changing its data.【改变张量的shape，不改变张量的数据】 Parameters: a : array-like newshape : int or tuple of ints One shape dimension can be -1. The value is inferred from the length of the array and remaning dimensions. Returns: reshaped_array:ndarray numpy.mean numpy.mean(a, axis=None) Compute the arithmetic mean along the specifiied axis.(the average of the array elements) Parameters: a : array_like axis ：None or int or tuple of ints, optional Axis or axes along which the means are computed. axis=0 ：沿行的垂直往下（列） axis=1 ：沿列的方向水平向右（行） numpy.std numpy.std(a, axis=None,) Compute the standard deviation along the specified axis.【标准差】 Parameters: a :array_like axis :Axis or axes along which the means are computed. numpy.shape attribute Tuple of array dimensions. numpy.concatenate numpy.concatenate((a1, a2, …), axis=0) Join a sequence of arrays along an existing axis. Parameters: a1, a2, … :sequence of array_like The arrays must have the same shape, excepting in the dimension corresponding to axis.【除了axia方向，其他维度的shape要相同】 If axis is None, arrays are flattened before use.【值为None，就先将向量变成一维的】 Default=0 numpy.ndarray.astype method numpy.ndarray.astype(dtype) Copy of the array cast to a specified type.【强制转换数据类型】 Parameters: dtype : str or dtype numpy.ones numpy.ones(shape, dtype=None) Return a new array of given shape and type, filled with ones. Parameters: shape : int or sequence of ints. dtype : data-type, optional numpy.array numpy.array(object, dtype = none) Create an array Parameters: object :array_like An array, any object exposing the array interface, an object whose array method returns an array, or any(nested) sequence. numpy ndarray 运算 [[1]]*3 = [[1],[1],[1]] A * B 元素相乘 numpy.dot(A, B) 矩阵相乘 numpy.power numpy.power(x1, x2) First array elements raised to powers from second array. Parameters: x1 :array_like . The bases. x2 :array_like The exponents. numpy.sum numpy.sum(a, axis=None, dtype=None) Sum of arrays elements over a given axis. Parameters: a :array_like Elements to sum. axis :None or int or tuple of ints, optional Axis or axes along which a sum is perfomed. The default, None, will sum all of the elementsof the input array. numpy.transpose numpy.transpose(a, axes=None) Permute the dimensions of the array.【tensor的维度换位】 Parameters: a : array_like axes : list of ints, optinal Default, reverse the dimensions. Otherwise permute the axes according to the values given. Returns : ndarray 张量a的shape是(10,2,15), numpy.transport(2,0,1)的shape就是(15,10,2) 对于一维：行向量变成列向量 对于二维：矩阵的转置 numpy.save numpy.save(file, arr) Save an array to a binary file in Numpy .npy format. Parameters: file :file, str, or pathlib arr :array_like Array data to be saved. numpy.clip Clip(limit) the values in an array numpy.clip(a, a_min, a_max) Parameters: a :array_like a_min : scalar or array_like a_max :scalar or array_like numpy.around Evenly round to the given number of decimals(十进制) numpy.around(a) Parameters： a :array_like Notes: For values exactly halfway between rounded decimal values, Numpy rounds to the nearest even values. 【这什么意思呢？ 就是说对于0.5的这种，为了统计上平衡，不会全部向上取整或者向下取整，会向最近的偶数取整，around（2.5）=2】 numpy.log The natural logarithm log is the inverse of exponential functions, so that log(exp(x))=x. numpy.log(x) Parameters: x : array_like numpy.ndarray.T attribute, the transpose array. ndarray.T numpy.random.shuffle Modify a sequence in-space by shufflng its contents. This function only shuffles the array along the first axis of a multi-diensional array. The order of sub-arrays is changed but their contents remains the same. numpy.random.shuffle(x) Parameters: x : array_like e.g. shuffle two list, X and Y, together. 【以相同的顺序打乱两个array】 np.random.seed(0) randomize = np.arrange(len(X)) np.random.shuffle(randomize) return X[randomize], Y[randomize] sklearnskelearn.linear_model.LinearRegression class sklearn.linear_model.LinearRegression(fit_intercept=True, normalize=False, copy_X=True, n_jobs=None) Ordinary least squares Linear Regress(最小二乘法回归运算) Parameters: fit_intercept :bool, optional, defalut True【True：需要bias的截距项】 normalize :bool, optional, default False 【True：对样本做feature scaling】 Attributes： coef_ :array of shape(n_features) 【权重】 intercept_ :bias Methods： fit(self,X,y[,sample_weight]) :Fit linear model e.g. , LinearRegression().fit(x_data, y_data) matplotlib.pyplotmatplotlib.pyplot.contourf contour and contourf draw contour lines and filled contours, respectively.【一个画等高线，一个填充等高线/轮廓】 contour([X, Y, ] Z, [levels], **kwargs) Parameters X, Y: The coordinates of the values in Z. A and Y must both be 2-D with the sanme shape as Z(e.g. created via numpy.meshgrid), or they must both be 1-D such that len(X) == M is the number of columns in Z and len(Y) = N is the number of rows in Z. 【X，Y要么是由像numpy.mershgrid(x, y) 生成的网格点坐标矩阵，要么X，Y是（基）向量，X向量是x轴的，对应到Z矩阵，是Z矩阵的列数，Y向量同理】 Z ：array-like(N,M) levels : int or array-like, optional. Determines the number and positions of contour lines / religions.【划分多少块等高区域】 alpha :float, optional. Between 0(transparent) and 1(opaque).【透明度】 cmap :str or Colormap, optional. e.g., pyplot.contourf(x, y, Z, 50, alpha=0.5, cmap=pyplot.get_cmap(‘jet’))【‘jet’是常用的那种红橙黄绿青蓝紫】 matplotlib.pyplot.plot plot([x], y, [fmt], , data=None, *kwargs) The coordinates of the points or line nodes are given by x, y. Parameters: x, y :array-like or scalar. fmt :str, optional. A format string. e.g., ‘.’, point marker. ‘-‘, solid line style. ‘–’,dashed line style. ‘b’, blue. ms/markersize : float lw/linewidth :float color : matplotlib.pyplot.xlim xlim(args, *kwargs) Get or set the x limits of the current axes. e.g. left, right = xlim() :get xlim(left, right) :set matplotlib.pyplot.show show(args, *kwargs) display a figure. matplotlib.pyplot.vlines Plot vertical lines. vlines(x, ymin, ymax, color=’k’, linestyles=’solid’) Parameters: x :scalar or 1D array_like ymin, ymax :scalar or 1D array_like matplotlib.pyplot.hlines Plot horizontal lines. vlines(y, xmin, xmax, color=’k’, linestyles=’solid’) Parameters: y :scalar or 1D array_like xmin, xmax :scalar or 1D array_like matplotlib.pyplot.savefig Save the current figure. savefig(fname) Parameters: fname :str ot Pathlike matplotlib.pyplot.legend Place a lengend on the axes. e.g. : legend() Labeling exisiting plot elements plt.plot(train_loss) plt.plot(dev_loss) plt.legend([‘train’, ‘dev’]) e.g. : le syssys.argv[] python a.py data.csv sys.argv = [‘a.py’, ‘data.csv’] 重定向到文件 f = open(‘out.csv’, ‘w’) sys.stdout = f print(‘此时print掉用的就是文件对象的write方法’)","link":"/2020/03/07/python/"},{"title":"「机器学习-李宏毅」：Tips for Deep Learning","text":"这篇文章中，详尽阐述了在训练Deep Neural Network时，改善performance的一些tips。tips从Training和Testing两个方面展开。在Training中结果不尽人意时，可以采取更换新的activation function（如ReLu,Maxout等）和采用Adaptive Learning Rate的GradientDescent算法（除了Adagrad,还有RMSprop、Momentum、Adam等）。当在Training中得到好的performance，但在testing中perform bad时，即遇到了overfitting，又该怎么处理呢？文章后半部分详尽介绍了EarlyStopping、Regularization和Dropout三个solution。 Recipe of Deep LearningDeep Learning 的三个步骤： 如果在Training Data中没有得到好的结果，需要重新训练Neural Network。 如果在Training Data中得到好的结果，在Testing Data（这里的Testing Data是指有Label的Data，比如Kaggle的Public Data或者是从Training Data中划分出的Development Data）没有得到的好的结果，说明Overfitting了，需要重新设计Neural Network的结构。 Do not always blame Overfitting 如果在Testing Data中，看到上图，20-layer的error小，56-layer的error大，56-layer一定overfitting了。 No!!!不要总把原因归咎于Overfitting。 再看Testing Data error之前，先看看Training Data的error。上图中，56-layer的DNN在Training Data的error本来就比20-layer的大，说明56-layer的DNN根本没有train好。 所以56-layer的DNN在Testing Data上的error大，原因不是overfitting，而是模型根本没有train好。 注： Overfitting是在Training Data上error小，但在Testing Data上的error大。 因此，对于在Training Data上得到不好的结果和在Training Data上得到好的结果但在Testing Data上得到不好的结果这两种情况，需要不同的解决方法。 Bad Results on Training Data在不重新设计DNN结构时，如果在Training Data中得到Bad Results，一般有两种方法来改进结果： New activation function【neuron换新的激活函数】 Adaptive Learning Rate New activation functionVanishing Gradient Problem 上图表示，在手写数字辨识中，Deeper layers并不能有好的performance。 为什么会这样呢？ 因为出现了Vanishing Gradient Problem，即gradient随着deeper layer逐渐消失的问题。 上图中，假设neuron的activation function是sigmod函数。 靠近Input layer层的参数的变化对Loss的影响很小，所以对Loss function做微分，gradient很小，参数更新慢。 而靠近Output layer层的参数的编号对Loss的影响更大，所以对Loss function做微分，gradient很大，参数更新快。 因为靠近Output Layer层的参数更新快，所以很快converge（收敛、趋于稳定）；但靠近Input Layer层的参数更新慢，几乎还处在random（随机）的状态。 当靠近Output Layer层的参数趋于稳定时，由于靠近Output Layer层的参数对Loss影响大，所以观察到的Loss的值也趋于稳定，于是，你就把training停掉了。 但是，靠近Input层的参数几乎处在random状态，所以拿模型用在Testing Data上，发现结果几乎是随机的。 怎么直观理解靠近Input Layer的参数的gradient小呢？ 用微分的直观含义来表示gradient $\\partial{l}/\\partial{w}$ : 当 $w$ 增加 $\\Delta{w}$ 时，如果 $l$ 的变化 $\\Delta{l}$ 变化大，说明 $\\partial{l}/\\partial{w}$ 大，否则 $\\partial{l}/\\partial{w}$ 小。 我们在DNN中使用的activation function是sigmod函数，sigmod函数会把值压到0和1之间。 因此，上图中，其他值不变，只有连接 $x_N$ 的参数 $w$ 增加 $\\Delta w$ 时，输入通过neuron的sigmod函数，函数的输出增加的 $\\Delta$ 会变小，随着Deeper Layer，neuron的输出的 $\\Delta$ 会越变越小，趋至0。 最后DNN输出的变化对 loss的影响小，即 $\\Delta{l}$ 趋至0，即参数的gradient $\\partial{l}/\\partial{w}$ 趋至0。（即 Vanishing Gradient） ReLu ：Rectified Linear Unit为了防止发生Vanishing Gradient Problem，在DNN中选择使用新的activation function。 ReLu长下面这个样子： z: input a: output 当 $z\\leq0$ 时， $a=0$ ；当 $z &gt;0$ 时， $a=z$ 。 Reason : Fast to compute Biological reason【有生物上的原因】 Infinite sigmod with different biases. 【是无穷个 有不同bias的sigmod函数 的叠加】 Vanishing gradient problem 【最重要的是没有vanishing gradient problem】 为什么ReLu没有vanishing gradient problem 上图DNN中，ReLu在输入是负数时，输出是0。因此这些输出是0的neuron可以去掉。 就变成了下图这个A Thinner linear network。由于ReLu函数的性质，靠近Input Layer的参数不会有smaller gradient。 这里有一个Q&amp;A: Q1: function变成linear的，会不会DNN就变弱了？ ： 当neuron的operation region不变的话，DNN的确是linear的，但是当neuron的operation region改变后，就是unlinear的。 ：即，当input的变化小，operation region不变（即输入不会从大于0变成小于0，小于0变成大于0这种），model还是linear的；但当input的变化大时，很多neuron的operation region都变化了，model其实就是unlinear的。 Q2: ReLu 怎么微分？ ：ReLu在0点不可微，那就随便指定为0这样（台湾腔QAQ）。 ReLu - variant当 $z\\leq 0$ 时，输出为0，就不能更新参数了。于是就有下图变体： 当 $z\\leq0$ 时，gradient都为0.01，为什么不能是其他值。于是就有下图变体：其中 $\\alpha$ 也是一个需要学习的参数 MaxoutMaxout，如下图，在设计neural network时，会给每一层的neuron分组，成为一个新的neuron。 Maxout也是一个Learnable activation function。 ReLu是Maxout学出来的一个特例。 上图中，左图是ReLu。 ReLu的输入 $z = wx+b$ ，输出 $a$ 如上图的绿色的线。 右图是Maxout。Maxout的输入 $z_1 =wx+b,z_2=0$ ，那么输出取max，输出 $a$ 如上图中绿色的线，和左图的ReLu相同。 Maxout is more than ReLu。 当参数更新时，Maxout的函数图像如下图： DNN中的参数是learnable的，所以Maxout也是一个learnable的activation function。 Reason ： Learnable activation function [Ian J. Goodfellow, ICML’13] Activation function in maxout network can be any piecewise linear convex function. 在maxout神经网络中的激活函数可以是任意的分段凸函数。 How many pieces depending on how many elements in a group. 分段函数分几段取决于一组中有多少个元素。 Maxout : how to trainGiven a training data x, we know which z would be the max. 【当给出每笔training data时，我们能知道Maxout neuron中哪一个最大】 如上图，在这笔training data x中，我们只train this thin and linear network 的参数，即max z相连的参数。 每笔不同的training data x，会得到不同的thin and linear network，最后，会train到每一个参数。 Adaptive Learning RateReview Adagrad在这篇文章： Gradient 第一小节讲到一种adaptive learning rate的gradient 算法：Adagrad 算法。在那篇文章中，我们得出的结论是 the best step $\\propto$ |First dertivative| / Second derivative. 在上图中，两个方向，因为蓝色方向的二阶微分更小，所以蓝色方向应该有更大的learning rate。 因此，在Adagrad中，我们用一阶微分来估量二阶微分的大小： $$ w^{t+1} \\leftarrow w^{t}-\\frac{\\eta}{\\sqrt{\\sum_{i=0}^{t}\\left(g^{i}\\right)^{2}}} g^{t} $$ RMSProp但是，在训练NN时，Error Surface（Total Loss对参数的变化）的图像可能会更复杂，如下图： 因为函数图像过于复杂，可能在同一方向的不同位置，也需要有不同的learning rate。 RMSProp是Adagrad的进阶版。 RMSProp过程： $w^{1} \\leftarrow w^{0}-\\frac{\\eta}{\\sigma^{0}} g^{0} \\quad \\sigma^{0}=g^{0}$ $w^{2} \\leftarrow w^{1}-\\frac{\\eta}{\\sigma^{1}} g^{1} \\quad \\sigma^{1}=\\sqrt{\\alpha (\\sigma^{0})^2+(1-\\alpha)(g^1)^2}$ $w^{3} \\leftarrow w^{2}-\\frac{\\eta}{\\sigma^{2}} g^{2} \\quad \\sigma^{2}=\\sqrt{\\alpha (\\sigma^{1})^2+(1-\\alpha)(g^2)^2}$ … $w^{t+1} \\leftarrow w^{t}-\\frac{\\eta}{\\sigma^{t}} g^{t} \\quad \\sigma^{t}=\\sqrt{\\alpha (\\sigma^{t-1})^2+(1-\\alpha)(g^t)^2}$ $\\sigma^t$ 也是在算gradients的 root mean squar。 但是在RMSProp中，加入了参数 $\\alpha$ (需要手动调节大小的参数)，可以给当前算出来的gradient $g^t$ 更大的权重，即更相信现在gradient的方向，不那么相信以前gradient的方向。 MomentumMomentum，则是引用物理中的惯性。 上图中，当小球到达local minima时，会因为惯性继续往前更新，则有可能到达minima的位置。 这里的Momentum，就代指上一次前进（参数更新）的方向。 Vanilla Gradient Descent 如果将Gradient的步骤画出图来，就是下图这样： 过程： Start at position $\\theta^0$ Compute gradietn at $\\theta^0$ Move to $\\theta^1=\\theta^0-\\eta\\nabla{L(\\theta^0)}$ Compute gradietn at $\\theta^1$ Move to $\\theta^2=\\theta^1-\\eta\\nabla{L(\\theta^1)}$ … …Stop until $\\nabla{L(\\theta^t)}\\approx0$ Momentum 在Momentum中，参数更新方向是当前Gradient方向和Momentum方向（上一次更新方向）的叠加。 Movement方向：上一次更新方向 - 当前gradient方向。 过程： Start at position $\\theta^0$ Movement: $v^0=0$ Compute gradient at $\\theta^0$ Movement $v^1=\\lambda v^0-\\eta\\nabla{L(\\theta^0)}$ Move to $\\theta^1=\\theta^0+v^1$ Compute gradient at $\\theta^1$ Movement $v^2=\\lambda v^1-\\eta\\nabla{L(\\theta^1)}$ Move to $\\theta^2=\\theta^1+v^2$ … …Stop until $\\nabla{L(\\theta^t)}\\approx0$ 和Vanilla Gradient Descent比较，$v^i$ 其实是过去gradient( $\\nabla{L(\\theta^0)}$ 、$\\nabla{L(\\theta^1)}$ 、… 、 $\\nabla{L(\\theta^{i-1})}$ )的加权和。 迭代过程： $v^0=0$ $v^1=-\\eta\\nabla{L(\\theta^0)}$ $v^2=-\\lambda\\eta\\nabla{L(\\theta^0)}-\\eta\\nabla{L(\\theta^1)}$ … 再用那个小球的例子来直觉的解释Momentum： 当小球在local minima时，gradient为0，但是Momentum（即上次移动方向）是继续往前，于是小球可以继续向前更新。 Adam = RMSProp + Momentum Algorithm：Adam, our proposed algorithm for stochastic optimization. 【Adam，是为了优化stochastic gradient】（至于什么是stochastic gradient，建议戳) $g_t^2$ indicates the elementwise square $g_t\\odot g_t$ . 【$g_t^2$ 是gradient $g_t$ 向量和 $g_t$ 的元素乘】 Good default settings for the tested machine learning problems are $\\alpha=0.001$ , $\\beta_1=0.9$ , $\\beta_2=0.999$ and $\\epsilon=10^{-8}$ . All operations on vectors are element-wise. With $\\beta_1^t$ and $\\beta_2^t$ we denote $\\beta_1$ and $\\beta_2$ to the power t. 【参数说明：算法默认的参数设置是 $\\alpha=0.001$ , $\\beta_1=0.9$ , $\\beta_2=0.999$ ， $\\epsilon=10^{-8}$ 。算法中所有vector之间的操作都是对元素操作。 $\\beta_1^t$ 和 $\\beta_2^t$ 是 $\\beta_1$ 和 $\\beta_2$ 的 $t$ 次幂】 Adam Pseudo Code： Require：$\\alpha$ : Stepsize 【步长/learning rate $\\eta$ 】 Require：$\\beta_1,\\beta_2\\in\\left[0,1\\right)$ : Exponential decay rates for the moment estimates. Require：$f(\\theta)$ : Stochastic objective function with parameters $\\theta$ .【参数 $\\theta$ 的损失函数】 Require: $\\theta_0$ ：Initial parameter vector 【初值】 $m_0\\longleftarrow 0$ (Initial 1st moment vector) 【 $m$ 是Momentum算法中的更新参数后的方向 $v$ 】 $v_0\\longleftarrow 0$ (Initial 2nd moment vector) 【 $v$ 是RMSprop算法中gradient的root mean square $\\sigma$ 】 $t\\longleftarrow 0$ (Initial timestep) 【更新次数】 while $\\theta_t$ not concerged do 【当 $\\theta$ 趋于稳定，即 $\\nabla{f(\\theta)}\\approx0$ 时】 $t\\longleftarrow t+1$ $g_t\\longleftarrow \\nabla{f_t(\\theta_{t-1})}$ (Get gradients w.r.t. stochastic objective at timestep t) 【算第t次时 $\\theta$ 的gradient】 $m_{t} \\leftarrow \\beta_{1} \\cdot m_{t-1}+\\left(1-\\beta_{1}\\right) \\cdot g_{t}$ (Update biased first momen t estimate) 【用Momentum算更新方向】 $v_{t} \\leftarrow \\beta_{2} \\cdot v_{t-1}+\\left(1-\\beta_{2}\\right) \\cdot g_{t}^{2}$ (Update biased second raw moment estimate) 【RMSprop估测最佳步长（ 和$v$ 负相关） 】 $\\widehat{m}_{t} \\leftarrow m_{t} /\\left(1-\\beta_{1}^{t}\\right)$ （Comppute bbi. as-corrected first momen t estima te) 【算出来的值有bias，论文中有具体解释为什么有。当更新次数增加时， $1-\\beta_1^t$ 也趋近于1】 $\\widehat{v}_{t} \\leftarrow v_{t} /\\left(1-\\beta_{2}^{t}\\right)$ (Compute bias-corrected second raw momen t estimate) 【和上同理】 $\\theta_{t} \\leftarrow \\theta_{t-1}-\\alpha \\cdot \\widehat{m}_{t} /(\\sqrt{\\widehat{v}_{t}}+\\epsilon)$ （Update parameters） 【 $\\widehat{m}t$ 相当于是更准确的gradient的方向，$\\sqrt{\\widehat{v}{t}}+\\epsilon$ 是为了估测最好的步长，调节learning rate】 Gradient Descent Limitation？在Gradient这篇文章中，讲到过Gradient有一些问题不能处理： Stuck at local minima Stuck at saddle point Very slow at the plateau （李老师说的，不是我说的QAQ）：但是Andrew（吴恩达）在2017年说过，不用太担心这个问题。为什么呢？ 如果要stuck at local minima，前提是每一维度都是local minima。 如果在一个维度遇到local minima的概率是p，当NN很复杂时，有很多参数时，比如1000，那么遇到local minima的概率是 $p^{1000}$ ，趋近于0了，几乎不会发生。 ：所以不用太担心Gradient Descent的局限性。 Bad Results on Testing DataEarly Stopping在更新参数时，可能会出现这样曲线图： 图中，Total Loss在training set中逐渐减小，但在validation set中逐渐增大。 而我们真正关心的其实是validation set的Loss。 所以想让参数停在validation set中loss最低时。 Keras能够实现EarlyStopping功能[1]：click here 123from keras.callbacks import EarlyStoppingearly_stopping = EarlyStopping(monitor='val_loss', patience=2)model.fit(x, y, validation_split=0.2, callbacks=[early_stopping]) RegularizationRegularization：Find a set of weight not only minimizing original cost but also close to zero. 构造一个新的loss function，除了最小化原来的loss function，还能使得参数趋紧0，使得function更平滑。 function的曲线更平滑，当输入有轻微扰动，不会太影响输出的结果。 L2 norm regularizationNew loss function: $$ \\begin{equation} \\begin{aligned} \\mathrm{L}^{\\prime}(\\theta)&=L(\\theta)+\\lambda \\frac{1}{2}\\|\\theta\\|_{2} \\\\ \\theta &={w_1,w_2,...} \\\\ \\|\\theta\\|_2&=(w1)^2+(w_2)^2+... \\end{aligned} \\end{equation} $$ 其中用第二范式 $\\lambda\\frac{1}{2}|\\theta|_2$ 作为regularization term。做regularization是为了使函数更平滑，所以一般不考虑bias) New gradient: $$ \\frac{\\partial \\mathrm{L}^{\\prime}}{\\partial w}=\\frac{\\partial \\mathrm{L}}{\\partial w}+\\lambda w $$ New update: $$ \\begin{equation} \\begin{aligned} w^{t+1} &\\longrightarrow w^{t}-\\eta \\frac{\\partial \\mathrm{L}^{\\prime}}{\\partial w} \\\\ &=w^{t}-\\eta\\left(\\frac{\\partial \\mathrm{L}}{\\partial w}+\\lambda w^{t}\\right) \\\\ &=(1-\\eta \\lambda) w^{t}-\\eta \\frac{\\partial \\mathrm{L}}{\\partial w} \\end{aligned} \\end{equation} $$ 在更新参数时，先乘一个 $(1-\\eta\\lambda)$ ，再更新。 weight decay（权值衰减）：由于 $\\eta,\\lambda$ 都是很小的值，所以 $w^t$ 每次都会先乘一个小于1的数，即逐渐趋于0，实现regularization。但是，因为更新中还有gradient部分，所以不会等于0。 L1 norm regularizationRegularization除了用第二范式，还可以用其他的，比如第一范式 $|\\theta|_1=|w_1|+|w_2|+…$ New loss function: $$ \\begin{equation}\\begin{aligned}\\mathrm{L}^{\\prime}(\\theta)&=L(\\theta)+\\lambda \\frac{1}{2}\\|\\theta\\|_1\\\\ \\theta &={w_1,w_2,...} \\\\ \\|\\theta\\|_1&=|w_1|+|w_2|+...\\end{aligned}\\end{equation} $$ 用sgn()符号函数来表示绝对值的求导。 符号函数：Sgn(number) 如果number 大于0，返回1；等于0，返回0；小于0，返回-1。 New gradient: $$ \\frac{\\partial \\mathrm{L}^{\\prime}}{\\partial w}=\\frac{\\partial \\mathrm{L}}{\\partial w}+\\lambda \\text{sgn}(w) $$ New update: $$ \\begin{equation} \\begin{aligned} w^{t+1} &\\longrightarrow w^{t}-\\eta \\frac{\\partial \\mathrm{L}^{\\prime}}{\\partial w} \\\\ &=w^{t}-\\eta\\left(\\frac{\\partial \\mathrm{L}}{\\partial w}+\\lambda \\text{sgn}(w^t)\\right) \\\\ &=w^{t}-\\eta \\frac{\\partial \\mathrm{L}}{\\partial w}-\\eta \\lambda \\operatorname{sgn}\\left(w^{t}\\right) \\end{aligned} \\end{equation} $$ 在用第一范式做regularization时，每次 $w^t$ 都要减一个值 $\\eta\\lambda\\text{sgn}(w^t)$ ，和用第二范式做regularization比较，后者每次都要乘一个小于1的值，即使是乘0.99，w下降也很快。 Weight decay（权值衰减）的生物意义： Our brain prunes（修剪） out the useless link between neurons. DropoutWiki: Dropout是Google提出的一种正则化技术，用以在人工神经网络中对抗过拟合。Dropout有效的原因，是它能够避免在训练数据上产生复杂的相互适应。Dropout这个术语代指在神经网络中丢弃部分神经元（包括隐藏神经元和可见神经元）。在训练阶段，dropout使得每次只有部分网络结构得到更新，因而是一种高效的神经网络模型平均化的方法。[2] 这里讲Dropout怎么做。 Training Each time before updating the parameters: Each neuron has p% to dropout. Using the new thin network for training. 【如上图，每个neuron有p的概率被dropout。于是NN就变成了下图thinner的NN】 For each mini-batch, we resample the dropout neurons. 【每次mini-batch，都要重新dropout，更新NN的结构】 TestingTesting中不做dropout If the dropout rate at training is p%, all the weights times 1-p%. 【如果在training中 dropout rate是 p%，在testing是，每个参数都乘 （1-p%)】 【比如dropout rate 是0.5。如果train出来的w是 1，那么testing中 w=0.5】 Why dropout in training：Intuitive Reason 这是一个比较有趣的比喻： 这也是一个有趣的比喻hhh: 即，团队合作的时候，如果每个人都认为队友在带我，那每个人都可能划水。 但是，（training中）如果你知道你的队友在划水，那你可能会做的更好。 但是，（testing中）发现每个人都有更好地做，都没有划水，那么结果就会很好。 （hhhh，李老师每次讲Intuitive Reason的时候，都觉得好有道理hhh，科学的直觉orz给我也整一个） Why multiply (1-p%) in testing: Intuitive reason为什么在testing中 weights要乘（1-p%)? 用一个具体的例子来直观说明： 上图中，如果dropout rate=0.5，假设只训练一次， $w_2,w_4$ 相连的neuron都被dropout。 在testing中，因为不对neurondropout，所以如果不改变weight，计算出的结果 $z’\\approx 2z$ 。 因此将所有weight简单地和(1-p%) 相乘，能尽量保证计算出的结果 $z’\\approx z$ 。 Dropout is a kind of ensembleEnsemble(合奏)，如下图，将testing data丢给train好的NN来估计，最后的估计值取所有NN输出的平均，如下图： 为什么说dropout is a kind of ensemble? Using one mini-batch to train one network 【dropout相当于每次用一个mini-batch来训练一个network】 Some parameters in the network are shared 【有些参数可能会在很多个mini-batch都被train到】 由于每个神经元有 p%的概率被dropout，因此理论上，如果有M个neuron，可能会训练 $2^M$ 个network。 但是在Ensemble中，将每个network存下来，testing的时候输出取平均，这样的过程太复杂了，结果也不一定会很好。 所以在testing中，no dropout，对原始network中的每个参数乘 (1-p%)，用这样简单的操作来达到ensemble的目的。 Reference Keras: how can i interrupt training when the validation loss isn’t decresing anymore. Dropout-wiki：https://zh.wikipedia.org/wiki/Dropout","link":"/2020/04/21/tips-for-DL/"},{"title":"「机器学习-李宏毅」：Recurrent Neural Network（RNN）","text":"这篇文章中首先从RNN能解决什么问题入手，分析了RNN与一般NN的区别。然后着重讲解了基于RNN的LSTM模型，包括LSTM的细节、和一般NN的区别，以及如何训练LSTM模型。具体阐述了在模型（RNN类模型）训练过程中为什么会遇到剧烈抖动问题和如何解决抖动的工程解决方法。 Example applicationSolt filling先从RNN的应用说起，RNN能做什么？ RNN可以做智慧系统： 如下图中，用户告诉订票系统：”I would like to arrive Taipei on November 2nd”. 订票系统能从这句话中得到Destination: Taipei，time of arrival: November 2nd. 这个过程也就是Solt Filling （槽位填充）。 如果用Feedforward network来解决solt filling问题，输入就是单词，输出是每个槽位（slot）的单词，如下图。 上图中，如何将word表示为一个vector？ EncodingHow to represent each word as a vector? 1-of-N encoding最简单的方式是1-of-N encoding方式（独热方式）。 向量维度大小是整个词汇表的大小，每一个维度代表词汇表中的一个单词，如果该维度置1，表示这个维度代表的单词。 Beyond 1-of-N encoding对1-of-N encoding方式改进。 第一种：Dimension for “Other” 在1-of-N的基础上增加一维度——‘other’维度，即当单词不在系统词汇表中，将other维度置1代表该单词。 第二种：Word hashing 即便是增加了”other”维度，编码vector的维度也很大，用word hashing的方式将大幅减少维度。 以apple为例，拆成app, ppl, ple三个部分，如上图所示，vector中表示这三个部分的维度置1。 用这样的word hashing方式，vector的维度只有 $26\\times 26\\times26$ ，大幅减少词向量的维度。 Example通过encoding的方式，单词用vector来表示，用前馈神经网络来解决solt filling问题。 如下图. input:一个单词（encoding为vector） output: input单词中属于该槽位(solts)的概率分布(vector)。 但用普通的前馈神经网络处理solt filling问题会出现下图问题： 上图中，arrive Taipei on November 2nd 和 leave Taipei on November 2nd，将这两句话的每个单词（vector）放入前馈神经网络，得出的dest槽位都应该是Taipei。 但，通过之前的语意，arrive Taipei的Taipei应该是终点，而leave Taipei的Taipei是起点。 因此，在处理这种问题时，我们的神经网络应该需要memory，对该输入的上下文有一定的记忆存储。 Recurrent Neural Network(RNN)Basic structure因此，我们对一般的前馈神经网络加入记忆元件a, a 存储hidden layer的输出，同时a也作为下一次计算的输入部分,下图就是最基础的RNN模型。 举一个例子来说明该过程： Input sequence: $\\begin{bmatrix}1 \\ 1 \\end{bmatrix}$ $\\begin{bmatrix}1 \\ 1 \\end{bmatrix}$ $\\begin{bmatrix}2 \\ 2 \\end{bmatrix}$ … RNN模型如下图所示：所有的weight都是1，没有bias; 所有的神经元的activation function 都是线性的。 input : $\\begin{bmatrix}1 \\ 1 \\end{bmatrix}$, 记忆元件初值 a1=0 a2=0. 记忆元件也作为输入的一部分，hidden layer的输出为 2 2, 更新记忆元件的值. output: $\\begin{bmatrix}4 \\ 4 \\end{bmatrix}$ , 记忆元件存储值 a1=2 a2=2. input : $\\begin{bmatrix}1 \\ 1 \\end{bmatrix}$ , 记忆元件存储值 a1=2 a2=2. 记忆元件也作为输入的一部分，hidden layer 的输出为6 6,更新记忆元件的值。 output: $\\begin{bmatrix}12 \\ 12 \\end{bmatrix}$ , 记忆元件存储值 a1=6 a2=6. 这里可以发现，第一次和第二次的输入相同，但是由于有记忆元件的缘故，两次输出不同。 input : $\\begin{bmatrix}2 \\ 2 \\end{bmatrix}$ , 记忆元件存储值 a1=6 a2=6. 记忆元件也作为输入的一部分，hidden layer 的输出为16 16,更新记忆元件的值。 output: $\\begin{bmatrix}32 \\ 32 \\end{bmatrix}$ , 记忆元件存储值 a1=16 a2=16. RNN中，由于有memory，会和一般前馈模型有两个不同的地方：一是输入相同的vector，输出可能是不同的；二是将一个sequence连续放进RNN模型中，如果sequence中改变顺序，输出也大多不同。 用这个RNN模型来解决之前的solt filling问题，就可以解决上下文语意不同影响solt的问题。 将arrive Taipei on November 2nd的每个单词都放入同样的模型中。 因此将RNN展开，如上图，像不同时间点的模型，但其实是不同时间点循环使用同一个模型。 由于左边的前文是arrive，右边的前文是leave，所以存储在memory中的值不同，Taipei作为input的输出（槽位的概率分布）也不同。 Elman Network &amp; Jordan Network上文中只是RNN模型中的一种，即Elman Network，记忆元件存储的是上一个时间点hidden layer的输出。 而Jordan Network模型中,他的记忆元件存储的是上一时间点的output。 （据说，记忆元件中存储output的值会有较好的performance，因为output是有target vector的，因此能具象的体现放进memory的是什么） Bidirectional RNN上文中的RNN模型，记忆元件中存储的都是上文的信息，如果要同时考虑上下文信息，即是bidirectional RNN(双向RNN)。 模型如下图。 双向RNN的好处是看的范围比较广，当计算输出 $y^t$ 时，上下文的内容都有考虑到。 Long Short-term Memory(LSTM)现在最常用的RNN模型是LSTM，Long Short-term Memory，这里的long是相当于上文中的RNN模型，因为上文提到的RNN模型都是short-term,即每一个时间点，都会把memory中的值洗掉，LSTM的long，就是会把memory的值保留的相对于久一些。 LSTM如下图，与一般NN不同的地方是，他有4个inputs,一个outputs。 LSTM主要有四部分组成： Input Gate：输入门，下方箭头是输入，左方箭头是输入信号控制输入门的打开程度，完全打开LSTM才能将输入值完全读入，打开的程度也是NN自己学。 Output Gate：输出门，上方箭头是输出，左方箭头是输入信号控制输出门的打开程度，同理，打开程度也是NN自己学习。 Memory Cell：记忆元件。 Forget Gate：遗忘门，右边的箭头是输入信号控制遗忘门的打开程度，控制将memory cell洗掉的程度。 LSTM更详细的阐述LSTM的内部机制： 注意： $z_o,z_i,z_f$ 是门的signal control,其实就等同于一般NN中neuron的输入z，是scalar。 gate其实就是一个neuron，通常gate neuron 的activation function f取 sigmod,因为值域在0到1之间，即对应门的打开程度。 input/forget/output gate的neuron的activation function是f(sigmod function), input neuron的activation function是g。 input gate控制输入:$g(z)f(z_i)$ input: z $\\rightarrow$ $g(z)$ input gate signal control: $z_i \\rightarrow f(z_i)$ multiply：$g(z)f(z_i)$ forget gate 控制memory：$cf(z_f)$ forget gate signal control: $z_f\\rightarrow f(z_f)$ 如果 $f(z_f)=1$ ,说明memory里的值保留；如果 $f(z_f)=0$ ,说明memory里的值洗掉。 更新当前时间点的memory(输入+旧的memory值) ：$c’=g(z)f(z_i)+cf(z_f)$ output gate 控制输出：$h(c’)f(z_o)$ output: $c’ \\rightarrow h(c’)$ output gare signal control: $z_o \\rightarrow f(z_o)$ multiply: $h(c’)f(z_o)$ LSTM模型（trained）如下图： 输入序列为 $\\begin{bmatrix}3 \\ 1 \\ 0 \\end{bmatrix}$$\\begin{bmatrix}4 \\ 1 \\ 0 \\end{bmatrix}$ $\\begin{bmatrix}2 \\ 0 \\ 0 \\end{bmatrix}$ $\\begin{bmatrix}1 \\ 0 \\ 1 \\end{bmatrix}$ $\\begin{bmatrix}3 \\ -1 \\ 0 \\end{bmatrix}$ 该LSTM activation function: g、h都为linear function（即输出等于输入），f为sigmod. 通过该LSTM的输出序列为： 0 0 0 7 0 0 （建议手算一遍） Compared with Original Networkoriginal network如下图： LSTM 的NN即用LSTM替换原来的neuron，这个neuron有四个inputs，相对于original network也有4倍的参数，如下图： 所以原来RNN的neuron换为LSTM，就是下图： 上图中： 这里的 $z^f,z^u,z,z^o$ 都是 $x^t \\begin{bmatrix} \\quad\\end{bmatrix}$ 矩阵运算得到的vector, 因为上图中有多个LSTM，因此 $z^i$ 的第k个元素，就是控制第k个LSTM的input signal control scalar。所以，$z^f,z^u,z,z^o$ 的维度等于下一层neuron/LSTM的个数。 所以这里memory（cell）$c^t$ 也是一个vector，第k个元素是第k个LSTM中cell存储的值。 向量运算和scalar一样，LSTM细节如下图： Extension：“peephole”上小节的LSTM是simplified，将LSTM hidden layer的输出 $h^t$ 和cell中存储的值 $c^t$ 和下一时间点的输入 $x^{t+1}$ 一同作为下一时间点的输入，就是LSTM的扩展版”peephole”。 如下图： Multi-layer LSTM多层的peephole LSTM如下图： （：wtf 我到底看到了什么 不要怕：Keras PyTorch等套件都有 “LSTM”，“GUR，”SimpleRNN“ 已实现好的layers. Learning训练RNN时，输入与target如下所示： 估测模型的好坏，计算RNN的Loss时，需要看作一个整体，计算每个时间点RNN输出与target的crossentropy的和。 训练也可同样用Backpropagation，但考虑到时间点，有一个进阶版的”Backpropogation through time(BPTT)”[1]。 RNN一般就用BPTT训练。 How to train wellnot easy to trainRNN-based network is not always easy to learn. 但基于RNN的模型往往不太好训练，总是会出现下图中的绿色线情况（即抖动）。 error surface is rougherror surface，即total loss在参数变化时的函数图。 会发现基于RNN的模型的error surface会长下图这个样子：有时很平坦(flat)有时很陡峭(steep) 橙色点出发： 起初处在flat的位置。 随着一次次更新，gradient在变小，learning rate即会变大。 可能稍微不幸，就会出现跨过悬崖，即出现了剧烈震荡的问题。 如果刚好当前处在悬崖低，这时的gradient很大，learning rate也很大，step就会很大，飞出去，极可能出现segment fault(NaN). Thomas Mikolv 用工程师的角度来解决这个问题，即当此时的gradient大于某个阈值(threshold)时，就不要让当前的gradient超过这个阈值（通常取15）。 这样处在悬崖低的橙色点，（Clipping路线），更新就会到绿色的，继续更新。 Why为什么RNN模型会出现抖动的情况呢？ 用下图这个简单例子说明（一般activation function用sigmod,而ReLu的performance一般较差）： 上图中，输入序列是1 0 0 0 …，memory连接下一个时间点的权重是w，可以轻易得到最后一个时间点的输出 $y^{1000}=w^{999}$ 。 上图中，循环输出1000次，如果w变化 $\\Delta w$ ，看输出 $y^{1000}$ 的变化，来直观体现gradient 的变化： 上图中，可以看出： 绿色部分：当w从1变化为1.01时， $y^{1000}$ 的输出变化即大，既有较大的gradient，理应有小的learning rate。 黄色部分：当w从0.99变化为0.01时， $y^{1000}$ 的输出几乎不变化，即有较小的gradient，理应有大大learning rate. 在很小的地方（0.01 到 1.01），他的gradient就变化即大，即抖动的出现。 Reason：RNN，虽然可以看作不同时间点的展开计算，但始终是同一个NN的权重计算（cell连接到下一个时间点的权重），在不同时间中，反复叠乘，因此会出现这种情况。 Helpful Techniques LSTM几乎已经算RNN的一个标准了，为什么LSTM的performance比较好呢。 为什么用LSTM替换为RNN？ :Can deal with gradient vanishing(not gradient explode). 可以解决gradient vanish的问题（gradient vanish problem 具体见 这篇文章2.1.1） 为什么LSTM可以解决gradient vanish问题 ：memory and input are added.（LSTM的的输出与输入和memory有关） : The influence never disappears unless forget gate is closed.（memory的影响可以很持久） GRU[2]（Gated Recurrent Unit）：是只有两个Gate，比LSTM简单，参数更少，不容易overfitting 玄学了叭 More Applications【待更新】 Many to OneMany to ManyBeyond SequenceSeq2SeqAuto-encoder-TextAuto-encoder-SpeechChat-botReference BPTT GRU","link":"/2020/06/11/rnn/"},{"title":"「Cryptography-Dan」:Stream Cipher 3","text":"Stream Cipher的第三篇文章。 文章主要分为两部分，前部分逐步定义Secure PRG的定义，通过引入statistical test（统计测试）和Advantage（优势）得出当且仅当PRG is unpredictable,PRG is secure的结论。 后部分介绍了密码学中的一个重要概念Semantic Security的定义，通过引入 computationally indistinguishable(计算上不可区分)的概念给出定义，并证明了OTP的语意安全和在安全PRG条件下的流密码的语意安全，得出如果流密码中使用的PRG is secure,那么流密码就具备semantic security。 文章开头，也简单介绍了密码学中negligible和non-negligible的含义。 Negligible and non-negligibleIn practice: $\\epsilon$ is a scalar and $\\epsilon$ non-neg: $\\epsilon \\geq 1/2^{30}$ (likely to happen over 1GB of data) $\\epsilon$ negligible: $\\epsilon \\leq 1/2^{80}$ (won’t happen over life of key) 在实践中，$\\epsilon$ 是一个数值，如果是non-neg不可忽略的话，大约在1GB的数据下就会发生，如果是可忽略的值，在密钥的生存周期内基本不会发生。 In theory: $\\epsilon$ is a function $\\varepsilon: Z^{\\geq 0} \\rightarrow R^{\\geq 0}$ and $\\epsilon$ non-neg: $\\exists d: \\epsilon(\\lambda)\\geq 1/\\lambda^d$ ($\\epsilon \\geq 1/\\text{poly} $, for many $\\lambda$ ) $\\epsilon$ negligible: $\\forall d, \\lambda \\geq \\lambda_{d}: \\varepsilon(\\lambda) \\leq 1 / \\lambda^{d}$ ( $\\epsilon \\leq 1/\\text{poly}$, for large $\\lambda$ ) [0]（理论中，这个还不太理解，待补充。） PRG Security DefsLet $G:K\\longrightarrow \\{0,1\\}^n$ be a PRG. Goal: define what it means that [ $k\\stackrel{R}{\\longleftarrow} \\mathcal{K}$ , output G(k) ] is “indistinguishable” from [ $r\\stackrel{R}{\\longleftarrow} \\{0,1\\}^n$ , output r] . 【使得PGR的输出和真随机是不可区分的】（ $\\stackrel{R}{\\longleftarrow}$ 的意思是在均匀分布中随机取） 下图中，红色的圈是全部的 ${0,1}^n$ 串，按照定义是均匀分布。而粉色G()是PRG的输出，由于seed很小，相对于全部的 ${0,1}^n$ ，所以G()的输出范围也很小。 因此，attacker观测G(k)的输出，是不能和uniform distribution（均匀分布）的输出区分开。 这也就是我们所想构造的安全PGR的目标。 Statistical TestsStatistical test on ${0,1}^n$ ：有一个算法A，$x\\in{0,1}^n$ ,A(x) 根据算法定义输出”0”或”1”. 统计测试是自定义的。 Example： A(x)=1 if $| \\#0(x)-\\#1(x)|\\leq 10\\cdot\\sqrt{n}$ 【期望串中0、1的数目差不多，这样look random】 A(x)=1 if $|\\#00(x)-\\frac{n}{4}\\leq10\\cdot\\sqrt{n}$ 【期望Pr(00)=1/4 ,串中00出现的概率为1/4，认为是look random】 A(x)=1if max-run-of-0(x) &lt; 10·log(n) 【期望串中0的最大游程不要超过规定值】 上面的第三个例子，如果输出为全1，满足上述的统计条件输出1，但全1串看起来并不random。 统计测试也由于是自定义的，所以通过统计测试的也不一定是random，其PRG也不一定是安全的。 所以，如何评估一个统计测试的好坏？ 下面引入一个重要的定义advantage，优势。 Advantage引入Advantage（优势）来评估一个统计测试的好坏。 Let G: $k \\rightarrow \\{0,1\\}^n$ be a PRG and A a stat. test on ${0,1}^n$ 【G是一个PRG，A是一个对01串的统计测试】 Define: the advantage of statisticaltest A relative to PRG G Adv$_\\text{PRG}[A,G]$ $\\text{Adv}_\\text{PRG}[A,G]=|Pr[A(G(k))=1]-Pr[A(r)=1]|\\in[0,1]$ , $k\\stackrel{R}{\\longleftarrow} \\mathcal{K}, r\\stackrel{R}{\\longleftarrow}\\{0,1\\}^n$ 【定义：Adv$_\\text{PRG}[A,G]$ 为统计测试A对于PRG G的优势为统计测试以PRG作为输入输出为1的概率 减去 统计测试以truly random string 作为输入输出为1的概率】 Adv close to 1 : 统计测试能区分PRG的输出和truly random string，即adversary可以利用区分PRG的输出和random的这一点从而破解系统。 Adv close to 0 : 统计测试不能区分PRG的输出和truly random string, 即adversary认为PRG的输出和random别无二致。 Advantage 优势[1] In cryptography, an adversary’s advantage is a measure of how successfully it can attack a cryptographic algorithm, by distinguishing it from an idealized version of that type of algorithm.Note that in this context, the “adversary” is itself an algorithm and not a person. A cryptographic algorithm is considered secure if no adversary has a non-negligible advantage, subject to specified bounds on the adversary’s computational resources (see concrete security). 在密码学中，adversary的优势是评估它通过某种理想算法破解一个加密算法的成功尺度。 这里的adversary是一种破解算法而不是指攻击者这个人。 当没有 adversary对该加密算法有不可忽略的优势时，该加密算法被认为是安全的，因为adversary只有有限的计算资源。 e.g.1 : A(x) = 0，统计测试A对PRG的任何输出都输出0，则Adv[A,G] = 0. e.g.2 : G: $k \\rightarrow {0,1}^n$ satisfies msb(G(k))=1 for 2/3 of keys in K. Define statistical test A(x) as : if[ msb(x)=1 ] output “1” else output “0” 【PRG G(k)的2/3的输出的最高有效位是1，定义统计测试A(x),输入的最高有效位为1输出1，否则输出0】 msb: most significant bit,最高有效位。 则 Adv[A,G] = | Pr[A(G(k))] - Pr[A(r)] | = 2/3 - 1/2 = 1/6 即 A can break the generator G with advantage 1/6, PRG G is not good. Secure PRGs: crypto definitionDef: We say that G: $k \\rightarrow {0,1}^n$ is secure PRG if $\\forall$ “eff” stat. tests A : Adv$_\\text{PRG}$ [A,G] is “negligible”. 这里的”eff”,指多项式时间内。 这个定义，“所有的统计测试”，这一点难以达到，因此没有provably secure PRGs。 但我们有heuristic candidates.（有限的stat. test 能满足） Easy fact: a secure PRG is unpredictable证明命题： a secure PRG is unpredictable. 即证明其逆否命题： PRG is predictable is insecure。 suppose A is an eddicient algorithm s.t. $\\text{Pr}_{k\\stackrel{R}{\\longleftarrow}\\mathcal{K}}[A(G(k))|_{1,...,i}=G(k)|_{i+1}]>\\frac{1}{2} + \\epsilon$ for non-negligible $\\epsilon$ . 【 算法A是一个有效的预测算法， $\\text{Pr}_{k\\stackrel{R}{\\longleftarrow}\\mathcal{K}}[A(G(k))|_{1,...,i}=G(k)|_{i+1}]>\\frac{1}{2} + \\epsilon$ , $\\epsilon$ 是不可忽略的值，即A能以大于1/2的概率推测下一位。】 Adversary能利用算法A来区分这个PRG和random依次来破解系统。 Define statistical test B as: B(x)=1 if $A(x|{1,…,i})=x{i+1}$ , else B(x)=0. 【定义一个统计测试B，如果预测算法A预测下一位正确输出1，否则输出0】 计算Adv$_\\text{PRG}$ : $r\\stackrel{R}{\\longleftarrow}\\{0,1\\}^n$ : Pr[B(r) = 1] = 1/2 $r\\stackrel{R}{\\longleftarrow}\\{0,1\\}^n$ : Pr[B(G(k)) = 1] = 1/2+ $\\epsilon$ Adv$_\\text{PRG}$[B,G] = |Pr[B(r)=1] - Pr[B(G(k))=1] | &gt; $\\epsilon$ Adversary 能以 $\\epsilon$ 的优势区分PRG和random，因此PRG 不安全。 所以，如果A是一个好的预测算法，那么B就是一个好的统计算法，Adversary就能通过B以 $\\epsilon$ 的优势破解系统。 在此，证明了 if A can predict PRG, PRG is insecure $\\Rightarrow$ A secure PRG is unpredictable. Thm(Yao’82): an unpredictable PRG is secure上节证明了A secure PRG is unpredictable. 在1982 Yao 的论文[2]中证明了其逆命题： an unpredictable PRG is secure. G: $k \\rightarrow {0,1}^n$ be PRG “Thm“ : if $\\forall i \\in$ {0,…, n-1} PRG G is unpredictable at pos. i then G is a secure PRG. 【定理：如果在任何位置PRG都是不可预测的，那么PRG就是安全的】 Proof： A: 预测算法： $\\forall i \\quad\\text{Pr}_{k\\stackrel{R}{\\longleftarrow}\\mathcal{K}}[A(G(k))|_{1,...,i}=G(k)|_{i+1}]=\\frac{1}{2} $ B:统计测试： B(x)=1 if $A(x|{1,…,i})=x{i+1}$ , else B(x)=0. Adv$_\\text{PRG}$[B,G] = |Pr[B(r)=1] - Pr[B(G(k))=1] | = 0 If next-bit predictors cannot distinguish G from random then no statistial test can! 【next-bit predictor指用预测算法的统计测试】 e.g. Let G: $k \\rightarrow {0,1}^n$ be PRG such that from the last n/2 bits of G(k) it is easy to compute the first n/2 bits. Is G predictable for som i $\\in$ {0, …, n-1} ? : Yes.当n=2时，可以预测出第一位。 在此，可以得出结论： Adversary不可区分PRG的输出和truly random string时被认为是安全的。 当且仅当PRG在任意位置不可预测时，PRG是安全的。 More generally: computationally indistinguishableLet P1 and P2 be two distributions over ${0,1}^n$ Def : We say that P1 and P2 are computationally indistinguishable (denoted $P_1\\approx_p P_2$) If $\\forall$ “eff” stat. tests A $\\left|\\text{Pr}_{x\\leftarrow_{P_1}}[A(x)=1]-\\text{Pr}_{x\\leftarrow_{P_2}}[A(x)=1]\\right|","link":"/2020/06/26/StreamCipher3/"},{"title":"「算法导论」:排序-总结","text":"本篇文章review了算法中的排序算法，包括冒泡排序、插入排序、归并排序、堆排序（以及用堆实现优先队列）、快速排序和计数排序。 分别从算法思路、算法伪代码实现、算法流程、算法时间复杂度四个方面阐述每个算法。 排序排序问题： 输入：一个 $n$个数的序列 $&lt;a_1,a_1,…,a_n&gt;$ 输出：输入序列的一个重拍 $&lt;a_1’,a_2’,…,a_n’&gt;$ ，使得 $a_1’\\leq a_2’ \\leq…\\leq a_n’$ . 在实际中，待排序的数很少是单独的数值，它们通常是一组数据，称为记录(record)。每个记录中包含一个关键字(key)，这就是需要排序的值。记录剩下的数据部分称为卫星数据(satellite data)，通常和关键字一同存取。 原址排序：输入数组中仅有常数个元素需要在排序过程中存储在数组之外。 典型的原址排序有：插入排序、堆排序、快速排序。 符号说明： $\\Theta$ 记号： $\\Theta$ 记号渐进给出一个函数的上界和下界。 $\\Theta(g(n))=\\left\\{f(n): \\text { there exist positive constants } c_{1}, c_{2}, \\text { and } n_{0}\\text { such that } \\right. \\left.0 \\leq c_{1} g(n) \\leq f(n) \\leq c_{2} g(n) \\text { for all } n \\geq n_{0}\\right\\}$ $g(n)$ 称为 $f(n)$ 的一个渐进紧确界(asymptotically tight bound) $O$ 记号 $O$ 记号只给出了函数的渐进上界。 $O(g(n))=\\left\\{f(n): \\text { there exist positive constants } c \\text { and } n_{0}\\text { such that } \\right. \\left.0 \\leq f(n) \\leq c g(n) \\text { for all } n \\geq n_{0}\\right\\}$ $\\Omega$ 记号 $\\Omega$ 记号给出了函数的渐进下界。 $\\Omega(g(n))=\\left\\{f(n): \\text { there exist positive constants } c \\text { and } n_{0}\\text { such that } \\right. \\left.0 \\leq c g(n) \\leq f(n) \\text { for all } n \\geq n_{0}\\right\\}$ 符号比较如下图： 排序算法运行时间一览 ： 算法 最坏情况运行时间 平均情况/期望运行时间 插入排序 $\\Theta (n^2)$ $\\Theta(n^2)$ 归并排序 $\\Theta(n\\lg{n})$ $\\Theta(n\\lg{n})$ 堆排序 $O(n\\lg{n})$ - 快速排序 $\\Theta(n^2)$ $\\Theta(n\\lg{n})$ (expected) 计数排序 $\\Theta(k+n)$ $\\Theta(k+n)$ 基数排序 $\\Theta(d(n+k))$ $\\Theta(d(n+k))$ 桶排序 $\\Theta(n^2)$ $\\Theta(n)$ (average-case) 冒泡排序反复交互相邻未按次序排列的元素。 BUBBLESORT(A) 参数：A待排序数组 1234for i = 1 to A.lengh-1 for j = A.length downto i+1 //每次迭代找出A[i..j]中最小的元素放在A[i]位置 if A[j] &lt; A[j-1] exchange A[j] with A[j-1] 冒泡排序是原址排序，流行但低效。 插入排序如下图所示，插入排序就像打牌时排序一手扑克牌。 开始时，我们的左手为空，桌子上的牌面向下。 然后，我们每次从桌子上拿走一张牌，想把它放在左手中的正确位置。 为了找到这张牌的正确位置，我们从右到左将这张牌和左手里的牌依次比较，放入正确的位置。 左手都是已排序好的牌。 INSERTION-SORT(A) A：待排序数组 12345678for j = 2 to A.length key = A[j] //将key插入到已排序好的A[1..j-1] i = j - 1 //pointer for sorted sequence A[1..j-1] while i &gt; 0 and A[i] &gt; key A[i+1] = A[i] i-- A[i+1] = key 插入排序是原址排序，对于少量元素是一个有效的算法。 最坏情况的运行时间： $\\Theta(n^2)$ . 归并排序分治分治： 将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。 分治的步骤： 分解：分解原问题为若干规模较小的子问题。 解决：递归地求解各子问题，规模较小，可直接求解。 合并：合并这些子问题的解成原问题的解。 算法核心归并排序中的分治 ： 分解：分解待排序的n个元素序列成各n/2个元素序列的两个子序列。 解决：使用归并排序递归地排序两个子序列，当序列长度为1时，递归到达尽头。 合并：合并两个已经排序好的子序列以产生排序好的原序列。 核心 ：合并两个已经排序好的子序列——MERGE(A, p, q, r) A: 待排序原数组。 p, q, r: 数组下标，满足 $p\\leq q&lt;r$ 。 假设子数组 A[p..q] 和A[q+1..r]都已经排好序，合并这两个数组代替原来的A[p..r]子数组。 MERGE算法理解： 牌桌上有两堆牌面朝上，每堆都已排好序，最小的牌在顶上。希望将两堆牌合并成排序好的输出牌堆，且牌面朝下。 比较两堆牌顶顶牌，选取较小的那张，牌面朝下的放在输出牌堆。 重复步骤2直至某一牌堆为空。 将剩下的另一堆牌面朝下放在输出堆。 MERGE合并的过程如下图所示： MERGE算法分析： 在上述过程中，n个元素，我们最多执行n个步骤，所以MERGE合并需要 $\\Theta(n)$ 的时间。 伪代码MERGE(A, p, q, r) 功能：合并已排序好的子数组A[p..q]和A[q+1..r] 参数：A为待排序数组，p, q, r为数组下标，且满足 $p\\leq q&lt;r$ 12345678910Let S[p..r] be new arraysk = p //pointer for S[]i = p, j = q+1 //pointer for subarraywhile k &lt;= r while ( i &lt;= q and j &lt;= r and A[i] &lt;= A[j] ) or j &gt; r // 取A[p..q]牌堆 S[k++] = A[i++] while ( i &lt;= q and j &lt;= r and A[i] &gt;= A[j] ) or i &gt; q //取A[q+1..r]牌堆 A[p..r] = S[p..r] MERGE-SORT(A, p, r) 功能：排序子数组A[p..r] 12345if p &lt; r q = (p+r)/2 MERGE-SORT(A, p, q) MERGE-SORT(A, q+1, r) MERGE(A, p, q, r) 算法分析分治算法运行时间分析分治算法运行时间递归式来自三个部分。 假设 $T(n)$ 是规模为 $n$ 的一个问题的运行时间。若规模问题足够小，则直接求解需要常量时间，将其写作 $\\Theta(1)$ 。 假设把原问题分解成 $a$ 个子问题，每个子问题的规模是原问题的 $1/b$ (在归并排序中， $a$ 和 $b$ 都为2，但很多分治算法中 $a\\neq b$ )。为了求解一个规模为 $n/b$ 规模的子问题，需要 $T(n/b)$ 的时间，所以需要 $aT(n/b)$ 的时间求解 $a$ 个子问题。 如果分解子问题需要 $D(n)$ 时间，合并子问题需要 $C(n)$ 时间。 递归式： $$ T(n)=\\left\\{\\begin{array}{ll}\\Theta(1) & \\text { if } n \\leq c \\\\ a T(n / b)+D(n)+C(n) & \\text { otherwise }\\end{array}\\right. $$ 归并排序分析前文分析了MERGE(A, p, q, r) 合并两个子数组的时间复杂度是 $\\Theta(n)$ ，即 $C(n)=\\Theta(n)$ ，且 $D(n)=\\Theta(n)$ . 归并排序的最坏情况运行时间 $T(n)$ : $$ T(n)=\\left\\{\\begin{array}{ll}\\Theta(1) & \\text { if } n=1 \\\\ 2 T(n / 2)+\\Theta(n) & \\text { if } n>1\\end{array}\\right. $$ 用递归树的思想求解递归式： 即递归树每层的代价为 $\\Theta(n)=cn$ ，共有 $\\lg{n}+1$ 层，所以归并排序的运行时间结果是 $\\Theta(n\\lg{n})$ . 堆排序堆自由树 ：连通的、无环的无向图。 有根数 ：是一棵自由树，其顶点存在一个与其他顶点不同的顶点，称为树的根。 度 ：有根树中一个结点 $x$ 孩子的数目称为 $x$ 的度。 深度 :从根 $r$ 到结点 $x$ 的简单路径。 二叉树 ：不包括任何结点，或者包括三个不相交的结点集合：一个根结点，一棵称为左子树的二叉树和一棵称为右子树的二叉树。 完全k叉树 ：所有叶结点深度相同，且所有内部结点度为k的k叉树。 （二叉）堆 ：是一个数组，它可以被看成一个近似的完全二叉树，树上的每个结点对应数组中的一个元素。除了最底层外，该树被完全填满，并且是从左到右填充。如下图所示。 堆的数组$A$ 有两个属性： $A.length$ ：数组元素的个数，A[1..A.length]中都存有值。 $A.heap-size$ ：有多少个堆元素在数组，A[1..heap-size]中存放的是堆的有效元素。 （$0\\leq A.heap-size\\leq A.lengh$ ) 堆的性质： $A[1]$ :存放的是树的根结点。 对于给定的一个结点 $i$ ，很容易计算他的父结点、左孩子和右孩子的下标。 PARENT(i) 1return i/2 //i&gt;&gt;&gt;1 LEFT(i) 1return 2*i //i&lt;&lt;&lt;1 RIGHT(i) 1return 2*i+1 //i&lt;&lt;&lt;1 | 1 包含$n$ 个元素的堆的高度为 $\\Theta(\\lg{n})$ 堆结构上的基本操作的运行时间至多和堆的高度成正比，即时间复杂度为 $O(\\lg{n})$ . 叶子结点：n/2+1 , n/2+2 , … , n 堆的分类： 最大堆： 除了根以外的结点 $i$ 都满足 $A[\\text{PARENT}(i)]\\geq A[i]$ . 某个结点最多和其父结点一样大。 堆的最大元素存放在根结点中。 最小堆： 除了根以外的结点 $i$ 都满足 $A[\\text{PARENT}(i)]\\leq A[i]$ . 堆的最小元素存放在根结点中。 堆的基本过程 : MAX-HEAPIFY：维护最大堆的过程，时间复杂度为 $O(\\lg{n})$ BUILD-MAX-HEAP：将无序的输入数据数组构造一个最大堆，具有线性时间复杂度 $O(n\\lg{n})$ 。 HEAPSORT：对一个数组进行原址排序，时间复杂度为 $O(n\\lg{n})$ MAX-HEAP-INSERT、HEAP-EXTRACT-MAX、HEAP-INCREASE-KEY和HEAP-MAXIMUM：利用堆实现一个优先队列，时间复杂度为 $O(\\lg{n})$ . 维护：MAX-HEAPIFY调用MAX-HEAPIFY的时候，假定根结点LEFT(i)和RIGHT(i)的二叉树都是最大堆，但A[i]可能小于其左右孩子，因此违背了堆的性质。 MAX-HEAPIFY通过让 A[i]“逐级下降”，从而使下标为i的根结点的子树满足最大堆的性质。 MAX-HEAPIFY(A, i) 功能：维护下标为i的根结点的子树，使其满足最大堆的性质。 参数：i 是该子树的根结点，其左子树右子树均满足最大堆的性质。 12345678910l = LEFT(i)r = RIGHT(i)if l &lt;= A.heap-size and A[l] &gt; A[i] largest = lelse largest = iif r &lt;= A.heap-size and A[r] &gt; A[i] largest = rif largest != i exchange A[i] with A[largest] MAX-HEAPIFY(A, largest) 下图是执行 MAX-HEAPIFY(A, 2)的执行过程。A.heap-size=10, 图(a)(b)(c)依次体现了值为4的结点依次下降的过程。 时间复杂度分析 ： MAX-HEAPIFY的时间复杂度为 $O(lg{n})$. 建堆：BUILD-MAX-HEAP堆的性质： 子数组A[n/2+1..n]中的元素都是树的叶子结点。因为下标最大的父结点是n/2，所以n/2以后的结点都没有孩子。 建堆 ：每个叶结点都可以看成只包含一个元素的堆，利用自底向上的方法，对树中其他结点都调用一次MAX-HEAPIFY，把一个大小为n = A.length的数组A[1..n]转换为最大堆。 BUILD-MAX-HEAP(A) 功能：把A[1..n]数组转换为最大堆 123A.heap-size = A.lengthfor i = A.length/2 downto 1 MAX-HEAPIFY(A, i) 下图是把A数组构造成最大堆的过程： 时间复杂度分析 ： BUILD-MAX-HEAP需要 $O(n)$ 次调用MAX-HEAPIFY，因此构造最大堆的时间复杂度是 $O(n\\lg{n})$ . 排序：HEAPSORT算法思路： 初始化时，调用BUILD-MAX-HEAP将输入数组A[1..n]建成最大堆，其中 n = A.length。 调用后，最大的元素在A[1]，将A[1]和A[n]互换，可以把元素放在正确的位置。 将n结点从堆中去掉(通过减少A.heap-size实现)，剩余结点中，原来根的孩子仍是最大堆，但根结点可能会违背堆的性质，调用MAX-HEAPIFY(A, 1)，从而构造一个新的最大堆。 重复步骤3，直到堆的大小从n-1降为2. HEAPSORT(A) 功能：利用堆对数组排序 12345BUILD-MAX-HEAP(A)for i = A.length downto 2 exchange A[1] with A[i] A.heap-size = A.heap-size - 1 MAX-HEAPIFY(A, 1) 下图为调用HEAPSORT的过程图： 时间复杂度分析 ： 建堆BUILD-MAX-HEAP的时间复杂度为 $O(n\\lg{n})$ ，n-1次调用MAX-HEAPIFY的时间复杂度为 $O(n\\lg{n})$ ，所以堆排序的时间复杂度为 $O(n\\lg{n})$ . 堆的应用：优先队列这里关注如何用最大堆实现最大优先队列。 优先队列(priority queue)： 一种用来维护由一组元素构成的集合S的数据结构，其中每一个元素都有一个相关的值，称为关键字(key)。 （最大）优先队列支持的操作 ： INSERT(S, x)：把元素 $x$ 插入集合S中，时间复杂度为 $O(\\lg{n})$ 。 MAXIMUM(S)：返回S中具有最大关键字的元素，时间复杂度为 $O(1)$ 。 EXTRACT-MAX(S)：去掉并返回S中的具有最大关键字的元素，时间复杂度为 $O(\\lg{n})$ 。 INCREASE-KEY(S, x, k)：将元素 $x$ 的关键字值增加到k，这里假设k的大小不小于元素 $x$ 的原关键字值，时间复杂度为 $O(\\lg{n})$ 。 MAXIMUM将集合S已建立最大堆的前提下，调用HEAP-MAXIMUM在 $\\Theta(1)$ 实现MAXIMUM的操作。 HEAP-MAXIMUM(A) 功能：实现最大优先队列MAXIMUM的操作，即返回集合中最大关键字的元素。 1return A[1] 时间复杂度分析 ：$\\Theta(1)$ EXTRACT-MAX类似于HEAPSORT的过程。 A[1]为最大的元素，A[1]的孩子都是最大堆。 将A[1]和A[heap-size]交换，减少堆的大小(heap-size)。 此时根结点的孩子满足最大堆，而根不一定满足最大堆性质，维护一下当前堆。 HEAP-EXTRACT-MAX(A) 功能：实现最大优先队列EXTRACT-MAX的操作，即去掉并返回集合中最大关键字的元素。 1234567if A.heap-size &lt; 1 error \"heap underflow\"max = A[1]A[1] = A[A.heap-size]A.heap-size = A.heap-size - 1MAX-HEAPIFY(A, 1)return max 时间复杂度分析 ：$O(\\lg{n})$ . INCREASE-KEY如果增加A[i]的关键词，可能会违反最大堆的性质，所以实现HEAP-INCREASE-KEY的过程类似插入排序：从当前i结点到根结点的路径上为新增的关键词寻找恰当的插入位置。 当前元素不断和其父结点比较，如果当前元素的关键字更大，则和父结点进行交换。 步骤1不断重复，直至当前元素的关键字比父结点小。 HEAP-INCREASE-KEY(A, i, key) 功能：实现最大优先队列INCREASE-KEY的功能，即将A[i]的关键字值增加为key. 参数：i为待增加元素的下标，key为新关键字值。 123456if key &lt; A[i] error \"new key is smaller than current key\"A[i] = keywhile i &gt; 1 and A[PARENT(i)] &lt; A[i] exchange A[i] with A[PARENT(i)] i = PARENT(i) 下图展示了HEAP-INCREASE-KEY的过程： 时间复杂度分析 ：$O(\\lg{n})$ INSERT如何插入一个元素扩展最大堆？ 先通过增加一个关键字值为 $-\\infin$ 的叶子结点扩展最大堆。 再调用HEAP-INCREASE-KEY过程为新的结点设置对应的关键字值。 MAX-HEAP-INSERT(A, key) 功能：实现最大优先队列的INSERT功能，即将关键字值为key的新元素插入到最大堆中。 参数：key是待插入元素的关键字值。 123A.heap-size = A.heap-size + 1A[A.heap-size] = -∞HEAP-INCREASE-KEY(A, A.heap-size, key) 时间复杂度分析 ：$O(\\lg{n})$ . 快速排序对于包含 $n$个数的输入数组来说，快速排序是一个最坏情况时间复杂度为 $\\Theta(n^2)$ 的排序算法。 虽然最坏情况时间复杂度很差，但是快速排序通常是实际排序应用中最好的选择，因为他的平均性能非常好：他的期望时间复杂度为 $\\Theta(n\\lg{n})$ ，而且 $\\Theta(n\\lg{n})$ 中隐含的常数因子非常小。 另外，它还能进行原址排序。 分治对A[p..r]子数组进行快速排序的分治过程： 分解： 数组A[p..r]被划分为两个（可能为空）的子数组A[p..q-1]和A[q+1..r]。 使得A[p..q-1]中的每个元素都小于等于A[q]，A[q+1..r]中的每个元素都大于等于A[q]。 其中计算下标q也是分解过程的一部分。 解决：通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序。 合并：因为子数组都是原址排序的，所以不需要合并操作，A[p..r]已经排好序。 快速排序：QUICKSORT按照分治的过程。 QUICKSORT(A, p, r) 功能：快速排序子数组A[p..r] 1234if p &lt; r q = PARTITION(A, p, r) QUICKSORT(A, p, q-1) QUICKSORT(A, q+1, r) 数组的划分：PARTITION快速排序的关键部分就在于如何对数组A[p..r]进行划分，即找到位置q。 PARTITION(A, p, r) 功能：对子数组A[p..r] 划分为两个子数组A[p..q-1]和子数组A[q+1..r]，其中A[p..q-1] 小于等于A[q]小于等于A[q+1..r] 返回：数组的划分下标q 12345678x = A[r]i = p - 1for j = p to r - 1 // j is pointer for comparation if A[j] &lt;= x i = i+1 exchange A[i] with A[j]exchange A[i+1] with A[r]return i+1 PARTITION总是选择一个 $x=A[r]$ 作为主元(pivot element)，并围绕它来划分子数组A[p..r]。 在循环中，数组被划分为下图四个（可能为空的）区域： $p\\leq k\\leq i$ ，则 $A[k]\\leq x$ . $i+1\\leq k \\leq j-1$ ，则 $A[k]&gt;x$. $k = r$ ，则 $A[k]=x$ . $j\\leq k\\leq r-1$ ，则 $A[k]$ 与 $x$ 无关。 下图是将样例数组PARTITION的过程： 快速排序的性能[*]待补充 快速排序的随机化版本与始终采用 $A[r]$ 作为主元的方法不同，随机抽样是从子数组A[p..r]随机选择一个元素作为主元。 加入随机抽样，在平均情况下，对子数组A[p..r]的划分是比较均匀的。 RANDOMIZED-PEARTITION(A, p, r) 功能：数组划分PARTITION的随机化主元版本 123i = RANDOM(p, r)exchange A[r] with A[i]return PARTITION(A, p, r) RANDOMIZED-QUICKSORT(A, p, r) 功能：使用随机化主元的快速排序 1234if p &lt; r q = RANDOMIZED-PARTITION(A, p, r) RANDOMIZED-QUICKSORT(A, p, q-1) RANDOMIZED-QUICKSORT(A, q+1, r) 计数排序计数排序 ： 假设 $n$ 个输入元素中的每一个都是在 0到 $k$ 区间内到一个整数，其中 $k$ 为某个整数。当 $k = O(n)$ 时，排序的运行时间为 $\\Theta(n)$ . 计数排序的思想 ： 对每一个输入元素 $x$，确定小于 $x$ 的元素个数。利用这个信息，就可以直接把 $x$ 放在输出数组正确的位置了。 COUNTING-SORT(A, B, k) 功能：计数排序 参数： A[1..n]输入的待排序数组，A.length = n B[1..n] 存放排序后的输出数组； 临时存储空间 C[0..k] ，A[1..n]中的元素大小不大于k. 123456789101112let C[0..k] be a new arrayfor i = 0 to k C[i] = 0for j = 1 to A.length C[A[j]] = C[A[j]] + 1//C[i] now contains the number of elements equal to i.for i = 1 to k C[i] = C[i] + C[i-1]//C[i] now contains the number of elements less than or equal to i.for j = A.length downto 1 B[C[A[j]]] = A[j] C[A[j]] = C[A[j]] - 1 下图是计数排序的过程： Reference Introduction to Algorithms. 算法导论","link":"/2020/06/29/sort-preview/"},{"title":"「机器学习-李宏毅」:Semi-supervised Learning","text":"这篇文章开篇讲述了什么是Semi-supervised Learning（半监督学习）？ 再次，文章具体阐述了四种Semi-supervised Learning，包括Generative Model，Low-density，Smoothness Assumption和Better Representation。 对于Generative Model，文章重点讲述了如何用EM算法来训练模型。 对于Low-density，文章重点讲述了如何让模型进行Self-training，并且在训练中引入Entropy-based Regularization term来尽可能low-density的假设。 对于Smoothness Assumption，文章重点讲述了Graph-based Approach（基于图的方法），并且在训练中引入Smoothness Regularization term来尽可能满足Smoothness Assumption的假设。 对于Better Representation，本篇文章只是简单阐述了其思想，具体介绍见这篇博客。 Introduction什么是Semi-supervised learning(半监督学习)？和Supervised learning（监督式学习）的区别在哪？ Supervised learning（监督式学习）： 用来训练的数据集 $R$ 中的数据labeled data，即 ${(x^r,\\hat{y}^r)}_{r=1}^R$ . 比如在图像分类数据集中： $x^r$ 是image，对应的target output $y^r$ 是分类的label。 而Semi-supervised learning（半监督式学习）： 用来的训练的数据集由两部分组成 $\\{(x^r,\\hat{y}^r)\\}_{r=1}^R$ , $\\{x^u\\}_{u=R}^{R+U}$ ，即labeled data和unlabeled data，而且通常情况下，unlabeled data的数量远远高于labeled data是数量，即 $U&gt;&gt;R$ . Semi-supervised learning 又分为两种，Transductive learning （转导/推论推导）和 Inductive learning（归纳推理） Transductive learing: unlabeled data is the testing data. 即测试数据在训练中用过。 Inductive learning: unlabeled data is not the testing data.测试数据是训练中没有用过的数据。 这里的使用testing data是指用testing data的feature，而不是使用testing data的label。 为什么会有semi-supervised learning？ Collecting data is easy, but collecting “labelled” data is expensive. 【收集数据很简单，但收集有label的数据很难】 We do semi-supervised learning in our lives 【在生活中，更多的也是半监督式学习，我们能明白少量看到的事物，但看到了更多我们不懂的，即unlabeled data】 Why Semi-supervised learning helps为什么半监督学习能帮助解决一些问题？ 如上图所示，如果只有labeled data，分类所画的boundary可能是一条竖线。 但如果有一些unlabeled data（如灰色的点），分类所画的boundary可能是一条斜线。 The distribution of the unlabeled data tell us something. 半监督式学习之所以有用，是因为这些unlabeled data的分布能告诉我们一些东西。 通常这也伴随着一些假设，所以半监督式学习是否有用往往取决于这些假设是否合理。 Semi-supervised Learning for Generative ModelSupervised Generative Model在这篇文章中，有详细讲述分类问题中的generative model。 给定一个labelled training data $x^r\\in C_1,C_2$ 训练集。 prior probability（先验概率）有 $P(C_i)$ 和 $P(x|C_i)$ ，假设是Gaussian模型，则 $P(x|C_i)$ 由Gaussian模型中的 $\\mu^i,\\Sigma$ 参数决定。 根据已有的labeled data，计算出假设的Gaussian模型的参数（如下图），从而得出prior probability。 即可算出posterior probability $P\\left(C_{1} \\mid x\\right)=\\frac{P\\left(x \\mid C_{1}\\right) P\\left(C_{1}\\right)}{P\\left(x \\mid C_{1}\\right) P\\left(C_{1}\\right)+P\\left(x \\mid C_{2}\\right) P\\left(C_{2}\\right)}$ Semi-supervised Generative Model在只有labeled data的图中，算出来的 $\\mu,\\Sigma$ 参数如下图所示： 但如果有unlabeled data（绿色点），会发现分布的模型参数更可能是是下图： The unlabeled data $x^u$ help re-estimate $P(C_1),P(C_2),\\mu^1,\\mu^2,\\Sigma$ . 因此，unlabeled data会影响分布，从而影响prior probability，posterior probability，最终影响 boundary。 EM所以有unlabeled data, 这个Semi-supervised 的算法怎么做呢？ 其实就是EM（Expected-maximization algorithm，期望最大化算法。） Initialization : $\\theta={P(C_1),P(C_2),\\mu^1,\\mu^2,\\Sigma}$ . 初始化Gaussian模型参数，可以随机初始，也可以通过labeled data得出。 虽然这个算法最终会收敛，但是初始化的参数影响收敛结果，就像gradient descent一样。 E：Step 1: compute the posterior probability of unlabeled data $P_\\theta(C_1|x^u)$ (depending on model $\\theta$ ) 根据当前model的参数，计算出unlabeled data的posterior probability $P(C_1|x^u)$ .(以$P(C_1|x^u)$ 为例) M：Step 2: update model. Back to step1 until the algorithm converges enventually. 用E步得到unlabeled data的posterior probability来最大化极大似然函数，更新得到新的模型参数，公式很直觉。(以 $C_1$ 为例) （$N$ ：data 的总数，包括unlabeled data; $N_1$ :label= $C_1$ 的data数） $P(C_1)=\\frac{N_1+\\Sigma_{x^u}P(C_1|x^u)}{N}$ 对比没有unlabeled data之前的式子， $P(C_1)=\\frac{N_1}{N}$ ，除了已有label= $C_1$ ，还多了一部分，即unlabeled data中属于 $C_1$ 的概率和。 $\\mu^{1}=\\frac{1}{N_{1}} \\sum_{x^{r} \\in C_{1}} x^{r}+\\frac{1}{\\sum_{x^{u}} P\\left(C_{1} \\mid x^{u}\\right)} \\sum_{x^{u}} P\\left(C_{1} \\mid x^{u}\\right) x^{u}$ 对比没有unlabeled data的式子 ，$\\mu^{1}=\\frac{1}{N_{1}} \\sum_{x^{r} \\in C_{1}} x^{r}$ ，除了已有的label= $C_1$ ，还多了一部分，即unlabeled data的 $x^u$ 的加权平均（权重为 $P(C_1\\mid x^u)$ ，即属于 $C_1$ 的概率）。 $\\Sigma$ 公式也包括了unlabeled data. 所以这个算法的Step 1就是EM算法的Expected期望部分，根据已有的labeled data得出极大似然函数的估计值； Step 2就是EM算法的Maximum部分，利用unlabeled data（通过已有模型的参数）最大化E步的极大似然函数，更新模型参数。 最后反复迭代Step 1和Step 2，直至收敛。 Why EM[1]挖坑EM详解。 为什么可以用EM算法来解决Semi-supervised? 只有labeled data 极大似然函数 $\\log{L(\\theta)}=\\sum_{x^r}\\log{P_\\theta(x^r,\\hat{y}^r)}$ , 其中 $P_\\theta(x^r,\\hat{y}^r)=P_\\theta(x^r\\mid \\hat{y}^r)P(\\hat{y}^r)$ . 对上式子求导是有closed-form solution的。 有labeled data和unlabeled data 极大似然函数增加了一部分 $\\log L(\\theta)=\\sum_{x^{r}} \\log P_{\\theta}\\left(x^{r}, \\hat{y}^{r}\\right)+\\sum_{x^{u}} \\log P_{\\theta}\\left(x^{u}\\right)$ . 将后部分用全概率展开， $P_{\\theta}\\left(x^{u}\\right)=P_{\\theta}\\left(x^{u} \\mid C_{1}\\right) P\\left(C_{1}\\right)+P_{\\theta}\\left(x^{u} \\mid C_{2}\\right) P\\left(C_{2}\\right)$ . 如果要求后部分，因为是unlabeled data, 所以模型 $\\theta$ 需要得知unlabeled data的label，即 $P(C_1\\mid x^u)$ ,而求这个式子，也需要得到 prior probability $P(x^u\\mid C_1)$ ,但这个式子需要事先得知模型 $\\theta$ ，因此陷入了死循环。 因此这个极大似然函数不是convex（凸），不能直接求解，因此用迭代的EM算法逐步maximum极大似然函数。 Low-density Separation Assumption另一种假设是Low-density Separation的假设，即这个世界是非黑即白的”Black-or-white”。 两种类别之间是low-density，交界处有明显的鸿沟，因此要么是类别1，要么是类别2，没有第三种情况。 Self-training对于Low-density Separation Assumption的假设，使用Self-training的方法。 Given：labeled data set $={(x^r,\\hat{y}^r}{r=1}^R$ ,unlabeled data set $={x^u}{u=l}^R+U$ . Repeat： Train model $f^$ from labeled data set. ($f^$ is independent to the model) 从labeled data set中训练出一个模型 Apply $f^*$ to the unlabeled data set. Obtain pseudo-label ${(x^u,y^u}_{u=l}^{R+U}$ . 用这个模型 $f^*$ 来预测unlabeled data set， 获得伪label Remove a set of data from unlabeled data set, and add them into the labeled data set. 拿出一些unlabeled data(pseudo-label)，放到labeled data set中，回到步骤1，再训练。 how to choose the data set remains open 如何选择unlabeled data 是自设计的 you can also provide a weight to each data. 训练中可以对unlabeled data(pseudo-label)和labeled data 赋予不同的权重. 注意： Regression模型是不能self-training的，因为unlabeled data和其pseudo-label放在模型中的loss为0，无法再minimize。 Hard LabelV.S. semi-supervised learning for generative model Semi-supervised learning for generative model和Low-density Separation的区别其实是soft label 和soft label的区别。 generative model是利用来unlabeled data的 $P(C_1|x^u)$ posterior probability来计算新的prior probability，迭代更新模型。 而low-density是计算出unlabeled data的pseudo-label，选择性扩大labeled data set(即加入部分由pseudo-label的unlabeled data)来迭代训练模型。 因此，如果考虑Neural Network： ($\\theta^*$ 是labeled data计算所得的network parameters) 如下图，unlabeled data $x^u$ 放入模型中预测，得到 $\\begin{bmatrix} 0.7 \\ 0.3\\end{bmatrix}$ . 如果是使用hard label，则 $x^u$ 的target是 $\\begin{bmatrix} 1 \\ 0\\end{bmatrix}$ . 如果是使用soft label，则 $x^u$ 的target是 $\\begin{bmatrix} 0.7 \\ 0.3\\end{bmatrix}$ . 如果是使用soft label，则self-training不会有效，因为新的data加进去，不会增大模型的loss，也就无法再minimize. 所以基于Low-density Separation的假设，是非黑即白的，需要使用hard label来self-training。 Entropy-based Regularization在训练模型中，我们需要尽量保证unlabeled data在模型中的分布是low-density separation。 即下图中，unlabeled data得到的pseudo-label的分布应该尽量集中，而不应该太分散。 所以，在训练中，如何评估 $y^u$ 的分布的集中度？ 根据信息学，使用 $y^u$ 的entropy，即 $E\\left(y^{u}\\right)=-\\sum_{m=1}^{5} y_{m}^{u} \\ln \\left(y_{m}^{u}\\right)$ (注：这里的 $y^u_m$ 应该是 $y^u=m$ 的概率) 当 $E(y^u)$ 越小，说明 $y^u$ 分布越集中，如下图。 因此，在self-training中： $L=\\sum_{y^r} C(x^r,\\hat{y}^r)+\\lambda\\sum_{x^u}E(y^u)$ Loss function的前一项（cross entropy）minimize保证分类的正确性，后一项（entropy of $y^u$ ) minimize保证 unlabeled data分布尽量集中，最大可能满足low-density separation的假设。 training：gradient decent. 因为这样的形式很像之前提到过的regularization(具体见这篇文章的3.2)，所以又叫entropy-based regularization. Outlook: Semi-supervised SVMSVM也是解决semi-supervised learning的方法. 上图中，在有unlabeled data的情况下，希望boundary 分的越开越好（largest margin）和有更小的error. 因此枚举unlabeled data所有可能的情况，但枚举在计算量上是巨大的，因此SVM（Support Vector Machines）可以实现枚举的目标，但不需要这么大的枚举量。 Smoothness AssumptionSmoothness Assumption的思想可以用以下话归纳： “You are known by the company you keep” 近朱者赤，近墨者黑。 蓬生麻中，不扶而直。白沙在涅，与之俱黑。 Assumption：“similar” $x$ has the same $\\hat{y}$ . 【意思就是说：相近的 $x$ 有相同的label $\\hat{y}$ .】 More precise assumption： x is not uniform if $x^1$ and $x^2$ are close in a hign density region, $\\hat{y}^1$ and $\\hat{y}^2$ are the same. Smoothness Assumption假设更准确的表述是： x不是均匀分布，如果 $x^1$ 和 $x^2$ 通过一个high density region的区域连在一起，且离得很近，则 $\\hat{y}^1$ 和 $\\hat{y}^2$ 相同。 如下图， $x^1$ 和 $x^2$ 通过high density region连接在一起，有相同的label，而 $x^2$ 和 $x^3$ 有不同的label. Smoothness Assumption通过观察大量unlabeled data，可以得到一些信息。 比如下图中的两张人的左脸和右脸图片，都是unlabeled，但如果给大量的过渡形态（左脸转向右脸）unlabeled data，可以得出这两张图片是相似的结论. Smoothness Assumption还可以用在文章分类中，比如分类天文学和旅游学的文章。 如下图， 文章 d1和d3有overlap word（重叠单词），所以d1和d3是同一类，同理 d4和d2是一类。 如果，下图中，d1和d3没有overlap word，就无法说明d1和d3是同一类。 但是，如果我们收集到足够多但unlabeled data，如下图，通过high density region的连接和传递，也可以得出d1和d3一类，d2和d4一类。 Cluster and then Label在Smoothness Assumption假设下，直观的可以用cluster and then label，先用所有的data训练一个classifier。 直接聚类标记(比较难训练）。 Graph-based Approach另一种方法是利用图的结构（Graph structure）来得知 $x^1$ and $x^2$ are close in a high density region (connected by a high density path). Represent the data points as a graph. 【把这些数据点看作一个图】 建图有些时候是很直观的，比如网页中的超链接，论文中的引用。 但有的时候也需要自己建图。 注意： 如果是影像类，base on pixel，performance就不太好，一般会base on autoencoder，将feature抽象出来，效果更好。 Graph Construction建图过程如下： Define the similarity $s(x^i, x^j)$ between $x^i$ and $x^j$ . 【定义data $x^i$ 和 $x^j$ 的相似度】 Add edge【定义数据点中加边（连通）的条件】 K Nearest Neighbor【和该点最近的k个点相连接】 e-Neighborhood【与离该点距离小于等于e的点相连接】 Edge weight is proportional to $s(x^i, x^j)$ 【边点权重就是步骤1定义的连接两点的相似度】 Gaussian Radial Basis Function： $s\\left(x^{i}, x^{j}\\right)=\\exp \\left(-\\gamma\\left\\|x^{i}-x^{j}\\right\\|^{2}\\right)$ 一般采用如上公式（经验上取得较好的performance）。 因为利用指数化后（指数内是两点的Euclidean distance），函数下降的很快，只有当两点离的很近时，该相似度 $s(x^i,x^j)$ 才大，其他时候都趋近于0. Graph-based Approach图建好后： The labeled data influence their neighbors. Propagate through the graph. 【label data 不仅会影响他们的邻居，还会一直传播下去】 如果data points够多，图建的好，就会像下图这样： 但是，如果data较少，就可能出现下图这种label传不到unlabeled data的情况： Smoothness Definition因为是基于Smoothness Assumption，所以最后训练出的模型应让得到的图尽可能满足smoothness的假设。 注意： 这里的因果关系是，unlabeled data作为NN的输入，得到label $y$ ，该label $y$ 和labeled data的 label $\\hat{y}$ 一起得到的图是尽最大可能满足Smoothness Assumption的。 （而不是建好图，然后unlabeled data的label $y$ 是labeled data原有的 $\\hat{y}$ 直接传播过来的，不然训练NN干嘛） 把unlabeled data作为NN的输入，得到label ，对labeled data和”unlabeled data” 建图。 为了在训练中使得最后的图尽可能满足假设，定义smoothness of the labels on the graph. $S=\\frac{1}{2} \\sum_{i,j} w_{i, j}\\left(y^{i}-y^{j}\\right)^{2}$ （对于所有的labeled data 和 “unlabeled data”（作为NN输入后，有label）） 按照上式计算，得到的Smoothness如下图所示： Smaller means smoother. 【Smoothness $S$ 越小，表示图越满足这个假设】 计算smoothness $S$ 有一种简便的方法： $S=\\frac{1}{2} \\sum_{i, j} w_{i, j}\\left(y^{i}-y^{j}\\right)^{2}=y^{T} L y$ (这里的1/2只是为了计算方便) $y$ : (R+U)-dim vector，是所有label data和”unlabeled data” 的label，所以是R+U维。 $y=\\begin{bmatrix}…y^i…y^j…\\end{bmatrix}^T$ $L$ :(R+U) $\\times$ (R+U) matrix，也叫Graph Laplacian（调和矩阵，拉普拉斯矩阵） $L$ 的计算方法：$L=D-W$ 其中 $W$ 矩阵算是图的邻接矩阵（区别是无直接可达边的值是0） $D$ 矩阵是一个对角矩阵，对角元素的值等于 $W$ 矩阵对应行的元素和 矩阵表示如下图所示： （证明据说很枯燥，暂时略[2]) Smoothness Regularization$S=\\frac{1}{2} \\sum_{i, j} w_{i, j}\\left(y^{i}-y^{j}\\right)^{2}=y^{T} L y$ $S$ 中的 $y$ 其实是和network parameters有关的（unlabeled data的label），所以把 $S$ 也放进损失函数中minimize，以求尽可能满足smoothness assumption. 以满足smoothness assumption的损失函数： $L=\\sum_{x^r} C\\left(y^{r}, \\hat{y}^{r}\\right)+\\lambda S$ 损失函数的前部分使labeled data的输出更贴近其label，后部分 $\\lambda S$ 作为regularization term，使得labeled data和unlabeled data尽可能满足smoothness assumption. 除了让NN的output满足smoothness的假设，还可以让NN的任何一层的输出满足smoothness assumption，或者让某层外接一层embedding layer，使其满足smoothness assumption，如下图： Better RepresentationBetter Presentation的思想就是：去芜存菁，化繁为简。 Find the latent(潜在的) factors behind the observation. The latent factors (usually simpler) are better representation. 【找到所观察事物的潜在特征，即该事物的better representation】 该部分后续见这篇博客。 Reference 挖坑：EM算法详解 挖坑：Graph Laplacian in smoothness. Olivier Chapelle：Semi-Supervised Learning","link":"/2020/07/03/semi-supervised/"}],"tags":[{"name":"DeepLearning","slug":"DeepLearning","link":"/tags/DeepLearning/"},{"name":"Backpropagation","slug":"Backpropagation","link":"/tags/Backpropagation/"},{"name":"CNN","slug":"CNN","link":"/tags/CNN/"},{"name":"Classification","slug":"Classification","link":"/tags/Classification/"},{"name":"Logistic Regression","slug":"Logistic-Regression","link":"/tags/Logistic-Regression/"},{"name":"Softmax","slug":"Softmax","link":"/tags/Softmax/"},{"name":"Cryptography","slug":"Cryptography","link":"/tags/Cryptography/"},{"name":"Gradient","slug":"Gradient","link":"/tags/Gradient/"},{"name":"Regression","slug":"Regression","link":"/tags/Regression/"},{"name":"StreamCipher","slug":"StreamCipher","link":"/tags/StreamCipher/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"DNN","slug":"DNN","link":"/tags/DNN/"},{"name":"RNN","slug":"RNN","link":"/tags/RNN/"},{"name":"LSTM","slug":"LSTM","link":"/tags/LSTM/"},{"name":"Algorithms","slug":"Algorithms","link":"/tags/Algorithms/"},{"name":"Machine-Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"open-classes","slug":"open-classes","link":"/tags/open-classes/"},{"name":"Gradient-Descent","slug":"Gradient-Descent","link":"/tags/Gradient-Descent/"},{"name":"error","slug":"error","link":"/tags/error/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"Intro-to-Algorithms","slug":"Intro-to-Algorithms","link":"/tags/Intro-to-Algorithms/"},{"name":"Semi-supervised","slug":"Semi-supervised","link":"/tags/Semi-supervised/"}],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"机器学习-李宏毅","slug":"机器学习-李宏毅","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9D%8E%E5%AE%8F%E6%AF%85/"},{"name":"Cryptography-Dan","slug":"Cryptography-Dan","link":"/categories/Cryptography-Dan/"},{"name":"算法导论","slug":"算法导论","link":"/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}]}