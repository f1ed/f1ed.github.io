<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fred&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://f7ed.com/"/>
  <updated>2021-04-09T09:44:28.371Z</updated>
  <id>https://f7ed.com/</id>
  
  <author>
    <name>f1ed</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「Paper Reading」：AFL++：Combine Incremental Steps of Fuzzing Research</title>
    <link href="https://f7ed.com/2021/04/09/aflpp/"/>
    <id>https://f7ed.com/2021/04/09/aflpp/</id>
    <published>2021-04-08T16:00:00.000Z</published>
    <updated>2021-04-09T09:44:28.371Z</updated>
    
    <content type="html"><![CDATA[<p>今天给大家分享的论文是一篇基于AFL的工作：AFL++：Combine Incremental Steps of Fuzzing Research，发表在USENIX Workshop。分享时的<a href="https://www.kdocs.cn/l/cuo67y1vfOwL">slides</a>  </p><a id="more"></a><p>目录</p><ul><li><p><a href="#Introduction">Introduction</a></p></li><li><p><a href="#State-of-the-Art">State-of-the-Art</a></p><ul><li><a href="#AFL">AFL</a> </li><li><a href="#Smart-Scheduling">Smart Scheduling</a><ul><li><a href="#AFLFast">AFLFast</a></li><li><a href="#MOpt">MOpt</a> </li></ul></li><li><a href="#Bypassing-Roadblocks">Bypassing Roadblocks</a><ul><li><a href="#LAF-Intel">LAF-Intel</a></li><li><a href="#RedQueen">RedQueen</a> </li></ul></li><li><a href="#Mutate-Structure-Inputs-AFLSmart">Mutate Structured Inputs: AFLSmart</a></li></ul></li><li><p><a href="#AFL++">AFL++</a></p></li><li><p><a href="#Evaluation">Evaluation</a> </p></li></ul><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Fuzzing已经成为软件测试强有力的工具，通过大量的非预期的输入，检测软件的运行状态，以发现软件的隐藏性漏洞。</p><p>而AFL是最具盛名的fuzzing工具，基于AFL的研究也层出不穷，但这些技术往往是正交式、独立地发展。</p><p>因此：</p><ol><li>将这些前沿新颖的fuzzing技术结合起来是一件很困难的事情</li><li>而评估这些不同维度的fuzzing技术也是一件很困难的事</li></ol><p>AFL++这个工作就致力于解决这个问题：</p><ol><li>AFL++提供了一个可用的fuzzing工具，结合了许多前沿fuzzing技术</li><li>AFL++还提供了一种新颖的可自定义的变异API（Custom Mutator API），研究人员能够轻松将自己设计的Mutator应用到AFL++上，或和其他Mutators结合起来。</li><li>这篇论文还评估了许多结合起来的fuzzing技术组合，评估结果体现了fuzzing技术的target-dependency.</li></ol><h1 id="State-of-the-Art"><a href="#State-of-the-Art" class="headerlink" title="State-of-the-Art"></a>State-of-the-Art</h1><p>在正式介绍AFL++ 之前，很有必要介绍一下afl++结合的其他fuzzing技术。</p><p>除了AFL的主要特点，afl++主要结合了三方面的技术，分别是：</p><p>调度上的。包括AFLFast的种子调度和MOpt的变异调度。</p><p>绕过fuzzing中的一些roadblocks，包括LAF- Intel和Red Queen。</p><p>针对一些复杂的结构化输入的变异。</p><h2 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h2><p>首先介绍一下AFL的工作原理和主要特征。</p><p>AFL是一种基于覆盖率反馈（coverage- guided）的fuzz工具。</p><p>AFL的工作流程如图所示：</p><img src="https://z3.ax1x.com/2021/04/09/cUSNqA.png" alt="cUSNqA.png" style="zoom:67%;" /><ol><li>编译时对源码进行插桩，以记录代码覆盖率（Code Coverage）</li><li>初始化一些输入文件，加入到输入队列（queue）</li><li>在队列中按照一定策略选择种子（seed），并进行大量的突变（mutation），得到大量的变异文件</li><li>如果该变异文件触发了新的执行路径，则将其保存下来，加入到队列中。</li><li>goto 2</li></ol><p>上述过程会一直进行下去，其中触发的crash会被记录下来，以便后面分析程序漏洞。</p><h3 id="Coverage-Guided-Feedback"><a href="#Coverage-Guided-Feedback" class="headerlink" title="Coverage Guided Feedback"></a>Coverage Guided Feedback</h3><p>AFL是一种使用边覆盖率作为反馈的灰盒fuzzer。</p><p>什么是边覆盖率呢？</p><p>在介绍边覆盖率之前，先介绍一下块覆盖率：</p><img src="https://z3.ax1x.com/2021/04/09/cNjrnI.png" alt="cNjrnI.png" style="zoom:90%;" /><p>如上图，将一个程序划分为一个一个的程序块，一个程序块中的指令要么都执行，要么都不执行。</p><p>将上述程序拖到IDA中，得到下图，因此可以用程序块之间的跳转表示边。所以</p><img src="https://z3.ax1x.com/2021/04/09/cNvCE6.png" alt="cNvCE6.png" style="zoom:60%;" /><p>A -&gt; B -&gt; C -&gt; D -&gt; E (tuples: AB, BC, CD, DE) </p><p>A -&gt; B -&gt; D -&gt; C -&gt; E (tuples: AB, BD, DC, CE)</p><p>这两条执行路径的覆盖率不同。</p><p>实现上，就是给每一个块分配一个编译随机值，通过上一个块和当前块的运算的值来表示该边，再进行统计。</p><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>AFL中的Mutation主要分为两种，一种是<strong>deterministic stage</strong>，从下表的变异中选择一个mutation进行连续变异。</p><img src="https://z3.ax1x.com/2021/04/09/cUS38O.png" alt="cUS38O.png" style="zoom:0%;" /><p>而<strong>havoc stage</strong> 则是每次选择一堆变异，工作作用在seed上。</p><h3 id="Fork-Server"><a href="#Fork-Server" class="headerlink" title="Fork Server"></a>Fork Server</h3><p>由于AFL会大量运行目标程序，因此为了减少fuzzer的执行开销，AFL使用了一种forkserver的技术。</p><p>forkserver的工作原理如下图所示:</p><img src="https://z3.ax1x.com/2021/04/09/cNjBjA.png" alt="cNjBjA.png" style="zoom:80%;" /><p>当fuzzer在执行目标程序前，会先执行fork()命令，得到一个子进程。</p><p>子进程再通过execv()指令执行目标程序，而execv()命令有一个很特别的地方，他会用这个目标程序的映像覆盖掉子进程的映像。</p><p>因此，此时的fuzzer fork()出的子进程就变成了插过桩的目标程序，也就是forkserver。</p><blockquote><p>The exec() family of functions replaces the current process image with a new process image.</p></blockquote><p>当fuzzer想要执行目标程序时，就和forkserver通信，将fork目标程序的任务交给forkserver，这样就极大的提高了fuzzer的执行效率。</p><h3 id="Persistent-Mode"><a href="#Persistent-Mode" class="headerlink" title="Persistent Mode"></a>Persistent Mode</h3><p>AFL另一个提高效率的功能是Persistent Mode。</p><p>使用Persistent Mode，只需要对程序做一点小小的改动，即对程序patch一个循环，就像这样：</p><img src="https://z3.ax1x.com/2021/04/09/cNjw1H.png" alt="cNjw1H.png" style="zoom:50%;" /><p>Persistent Mode允许单个进程重复输入，极大减少了fork的开销。</p><h2 id="Smart-Scheduling"><a href="#Smart-Scheduling" class="headerlink" title="Smart Scheduling"></a>Smart Scheduling</h2><h3 id="AFLFast"><a href="#AFLFast" class="headerlink" title="AFLFast"></a>AFLFast</h3><p>基于AFL的另一个改进领域是调度问题，一个是种子调度，如何选种子的问题；另一个是变异调度，如何选mutation的问题。</p><p>AFLFast主要是从种子调度的方向改进AFL。</p><p>AFLFast观察到种子大多数生成的输入都经历了相同的高频路径，因此想要设计一些策略能够focus on一些低频路径。</p><p>因此，AFLFast设计了两种策略：</p><ul><li><p>Search Strategy：关于在队列中如何选种子的问题，决定种子挑选顺序。</p></li><li><p>Power Schedule：关于选出的种子可以被fuzz多少次，即可以生成多少变异文件，而这个数量被定义为种子的energy。</p><blockquote><p>seed’s energy: the amount of generated inputs from each seed</p></blockquote></li></ul><h4 id="AFL-1"><a href="#AFL-1" class="headerlink" title="AFL"></a>AFL</h4><p>其实在AFL中也有相应的策略，我们先来看<strong>AFL中的种子策略</strong>是这样的：</p><ul><li><p>如何挑选种子：</p><p>在AFL中，<code>update_bitmap_score</code> 函数中维护了一个变量<code>fav_factor</code> ，这个值越小意味值种子越favored，而这个值其实是由程序的执行时间(exec_us)和种子的长度(len)决定的。</p><img src="https://z3.ax1x.com/2021/04/09/cNjd9e.png" alt="cNjd9e.png" style="zoom:57%;" /></li><li><p>如何给种子分配energy：</p><p>在AFL中，<code>calculate_score</code> 函数中维护了一个变量<code>perf_score</code> ，这个值越大意味着会给种子分配更多的energy，这个种子就有更多的机会被fuzz，而这个值主要由执行时间(exec_us)、程序的执行路(bitmap_size)、发现该种子的困难度(handicap)以及种子的深度(depth)共同决定的。</p><img src="https://z3.ax1x.com/2021/04/09/cUSaVI.png" alt="cUSaVI.png" style="zoom:50%;" /><p>其中handicap，困难度，可以这样来理解，这个值越大，说明发现这个种子经过了很长轮数，来之不易，所以希望能更focus on在这些来之不易的种子上。</p></li></ul><h4 id="AFLFast-1"><a href="#AFLFast-1" class="headerlink" title="AFLFast"></a>AFLFast</h4><p>而<strong>AFLFast</strong>中，不管是决定如何挑选种子，还是觉得如何给种子分配energy，AFLFast都还考虑了另外两个变量。</p><p>对每个种子，定义两个变量：</p><p>一个是<code>f(i)</code> ，表示该种子被fuzz的总次数，也叫做频率。</p><p>另一个是<code>s(i)</code> ，表示该种子在队列挑选中，被挑选了多少次。</p><img src="https://z3.ax1x.com/2021/04/09/cNjcAf.png" alt="cNjcAf.png" style="zoom:57%;" /><h4 id="AFLFast-Power-Schedule"><a href="#AFLFast-Power-Schedule" class="headerlink" title="AFLFast-Power Schedule"></a>AFLFast-Power Schedule</h4><p>这里主要介绍一下AFLFast的Power Schedule：</p><p>AFLFast提供了6中Power Schedule：</p><p>定义p(i)为分配的energy。</p><ol><li><p>EXPLOIT：p(i) = AFL</p><p>EXPLOIT模式下的power schedule，就是之前提到的AFL的原生策略。</p></li><li><p>EXPLORE：p(i) = AFL / const</p><p>EXPLORE模式下，对AFL中计算出的energy除以了一个常数。</p><p>看这样的一个例子：</p><img src="https://z3.ax1x.com/2021/04/09/cNjyHP.png" alt="cNjydHP.png" style="zoom:77%;" /><p>程序需要依次匹配到这些字符，才可以找到crash。</p><p>如果规定每个种子的energy是一个常数，即p = $2^{16}$ ，那总共分配 $2^{18}$ 的energy才能找到crash。</p><img src="https://z3.ax1x.com/2021/04/09/cNj24S.png" alt="cNj24S.png" style="zoom:70%;" /><p>但如果把这个种子的转移过程用马尔可夫链建模，可以发现如果从<code>b***</code> 转移到<code>ba**</code> ，fuzz的转移概率为 $2^{-10}$ （从4个字符中选择一个字节，每个字节有 $2^{8}$ 中情况）</p><img src="https://z3.ax1x.com/2021/04/09/cNjgN8.png" alt="cNjgN8.png" style="zoom:75%;" /><p>因此，可以得到从<code>i</code> 种子转移到<code>j</code> 种子需要的energy的期望是 $E[X_{ij}]=\frac{1}{p_{ij}}$  </p><p>那么找到<code>bad!</code> 状态，所需要的总energy的期望和为 : $E[X_{01}]+E[X_{12}]+E[X_{23}]+E[X_{34}]=4 \cdot 2^{10}=4k$  </p><p>因此，我们总是分配所需期望energy更多的值，所以在AFLFast模式，会对energy除以一个常数。</p></li></ol><p>剩下这四种策略都是从不同的方式抑制高频边被fuzz。</p><img src="https://z3.ax1x.com/2021/04/09/cNjW9g.png" alt="cNjW9g.png" style="zoom:47%;" /><h3 id="MOpt"><a href="#MOpt" class="headerlink" title="MOpt"></a>MOpt</h3><p>与种子调度相对的是变异调度，MOpt这个工作就是从变异调度的角度提升fuzz的效率。</p><p>MOpt工作的主要贡献有：</p><p>首先是观察到：很多有效的变异如bitflip，执行的时间却很少。</p><p>论文中统计了在deterministic stage不同变异产生的interesting test cases的数量，发现bitlip表现优异。</p><img src="https://z3.ax1x.com/2021/04/09/cNjf3Q.png" alt="cNjf3Q.png" style="zoom:67%;" /><p>但从变异执行时间的角度，发现这些变异效率高的变异，执行时间比较短。</p><img src="https://z3.ax1x.com/2021/04/09/cNjhcj.png" alt="cNjhcj.png" style="zoom:67%;" /><p>所以MOpt的motivation是：希望能花更多的时间在那些变异效率高的变异上。</p><h4 id="PSO"><a href="#PSO" class="headerlink" title="PSO"></a>PSO</h4><p>MOpt使用粒子群优化算法来对问题建模。</p><p>定义粒子（particle），即变异（mutation）。粒子的位置，就是该变异被选择的概率。</p><p>每一个粒子群（swarm），则是所有mutations的概率分布。</p><p>而MOpt与原始PSO算法不同，MOpt使用的是多个群（multiple swarms），每一个群都是一个概率分布。</p><p>在MOpt的工作流程中，主要有两个核心模块。</p><img src="https://z3.ax1x.com/2021/04/09/cNj4js.png" alt="cNj4js.png" style="zoom:67%;" /><p>一个是Pilot模块，另一个是Core模块。</p><p>Pilot模块：评估每一个粒子群，也就是该mutations的概率分布的fuzz效率。</p><p>Core模块：使用Pilot模块评估出的效率最高的mutation策略 来fuzz。</p><h2 id="Bypassing-Roadblocks"><a href="#Bypassing-Roadblocks" class="headerlink" title="Bypassing Roadblocks"></a>Bypassing Roadblocks</h2><p>fuzzing中有时会遇到一些roadblocks。</p><h3 id="LAF-Intel"><a href="#LAF-Intel" class="headerlink" title="LAF- Intel"></a>LAF- Intel</h3><p>LAF-Intel解决的fuzzing中遇到的一些困难比较语句，如下图：</p><img src="https://z3.ax1x.com/2021/04/09/cNjIun.png" alt="cNjIun.png" style="zoom:50%;" /><p>即使当输入为0xabad1dee时，已经非常接近正确答案了，fuzzer也会认为他是错误的。</p><p>因此LAF- Intel的思路是，把这些比较难的、比较一连串字符的比较划分为 多个单字节的比较。</p><p>这样可以让程序块的划分粒度更细，当你每匹配到一个字节时，就被认为是interesting，被保存到队列中，以后可以继续fuzz，这样，fuzzer就可以一步一步的解决这个roadblock。</p><p>另外，LAF-Intel是基于LLVM架构的，所以LAF- Intel实现了三种Pass：</p><ul><li>The split-compares-pass：划分为单字节比较，并全部转换为&lt;, &gt;, ==, !=和无符号数的比较。</li><li>The compare-transform-pass：重写了strcmp和memcmp，将其全部转换为单字节比较。</li><li>The split-switches-pass：将switch比较转换为单字节比较的if串。</li></ul><h3 id="RedQueen"><a href="#RedQueen" class="headerlink" title="RedQueen"></a>RedQueen</h3><p>RedQueen解决的roadblocks：</p><ul><li><p>magic number：和上文LAF-Intel解决的roadblocks类似。</p><img src="https://z3.ax1x.com/2021/04/09/cNjoBq.png" alt="cNjoBq.png" style="zoom:50%;" /></li><li><p>nested checksum：而校验和/嵌套校验和的情况就像下图所示：</p><img src="https://z3.ax1x.com/2021/04/09/cNjTH0.png" alt="cNjTH0.png" style="zoom:50%;" /><p>代码如下图所绘：</p><img src="https://z3.ax1x.com/2021/04/09/cUStrd.png" alt="cUStrd.png" style="zoom:57%;" /></li></ul><p>RedQueen这篇工作的贡献是：</p><p>首先他观察到种子的输入，有时是和程序的运行状态直接相关的，这种关联定义为Input-to-State联系。</p><p>比如下图：</p><img src="https://z3.ax1x.com/2021/04/09/cNjHEV.png" alt="cNjHEV.png" style="zoom:50%;" /><p>hook住cmp指令，运行时，观察到eax的值为<code>VALU</code> ，与之比较的值为<code>ABCD</code>（都是小端序）。</p><p>而VALU在输入中也有出现，所以这里观察到的VALU大概率就是输入的VALU，如果能将输入的VALU换成ABCD，就有较大可能绕过这个roadblock。</p><p>RedQueen就是利用这样的Input-to-State的关系来解决这些roadblocks。</p><h4 id="Magic-Bytes"><a href="#Magic-Bytes" class="headerlink" title="Magic Bytes"></a>Magic Bytes</h4><p>解决Magic Bytes的方法就是上文提到的那样，希望能找到一系列的可替换对。</p><img src="https://z3.ax1x.com/2021/04/09/cNjHEV.png" alt="cNjHEV.png" style="zoom:50%;" /><p>具体流程为：</p><ol><li>跟踪：将所有的cmp指令hook住，尝试运行一下，把指令比较的操作数都提取出来。</li><li>变化：对比较指令的操作数做变异操作，比如加一或减一的操作，因为从该条指令并不能得到源码中的比较关系，源码的比较逻辑可能是大于、小于等。</li><li>编码：对得到的替换对进行编码操作，如小端序、hex、base-64等，像刚刚的例子就是小端序的编码。</li><li>应用：将得到的这些替换对&lt; pattern -&gt; repl &gt;应用到输入中，即在输入中找pattern，替换为repl，试运行。</li></ol><p>在执行上述流程之前，RedQueen执行了一个操作，该操作极大提高了绕过的效率。</p><p>如果替换对为(0x00, 0x04)，并且输入文件像下面左图这样：</p><img src="https://z3.ax1x.com/2021/04/09/cNjbNT.png" alt="cNjbNT.png" style="zoom:67%;" /><p>输入文件中出现大量的0x00，就像产生了碰撞一样，其实很多位置并不和那条程序指令相关，这样就会花费大量时间。</p><p>如果输入是像上图右边这样的，比较colorful，那RedQueen的效率就会很高。</p><p>所以RedQueen在进行绕过之前，会对输入做染色（Colorization）的操作，在保证种子执行路径不变的情况下，增大输入的熵值。</p><h4 id="Nested-Checksum"><a href="#Nested-Checksum" class="headerlink" title="Nested Checksum"></a>Nested Checksum</h4><p>而对checksum的绕过，这其实是一件很难的事情，因此RedQueen会选择先忽略掉这些困难，后面再来修正。</p><p>具体操作：</p><ol><li><p>对输入进行染色</p></li><li><p>根据指定条件，识别这些像checksum比较的指令，hook住。</p></li><li><p>然后就用<code>cmp al, al</code> patch原程序，这样就让这些checksum的判断一定为正。</p><img src="https://z3.ax1x.com/2021/04/09/cNjq4U.png" alt="cNjq4U.png" style="zoom:50%;" /><p>但这样的patch就会带来false positive，即这些输入的执行路径可能并不是这样的。</p></li><li><p>RedQueen就会在之后进行输入验证，并修复他们。</p></li><li><p>在fix阶段，其实就是用magic bytes的方法，对checksum的位置进行替换。</p><p>不过如果对于嵌套的校验和指令，就需要按照拓扑序（Topological Sort），一个一个的fix。</p></li></ol><h2 id="Mutate-Structure-Inputs-AFLSmart"><a href="#Mutate-Structure-Inputs-AFLSmart" class="headerlink" title="Mutate Structure Inputs:AFLSmart"></a>Mutate Structure Inputs:AFLSmart</h2><p>对于输入复杂的、结构性强的程序，fuzzer通常会生成大量的无效输入。</p><p>因此AFLSmart将AFL和Peach结合起来，AFLSmart的输入为Peach pits格式，一种xml文件。</p><p>AFLSmart 将种子都表示为Peach pits格式，这样，就可以基于这些块进行变异，而不需要基于比特级的 变异。</p><img src="https://z3.ax1x.com/2021/04/09/cNjjgJ.png" alt="cNjjgJ.png" style="zoom:67%;" /><h1 id="AFL-2"><a href="#AFL-2" class="headerlink" title="AFL++"></a>AFL++</h1><p>AFL++就将上述提到的诸多fuzzing技术都结合在一起，并提供了一种可供扩展的API。</p><h2 id="Seed-Scheduling"><a href="#Seed-Scheduling" class="headerlink" title="Seed Scheduling"></a>Seed Scheduling</h2><p>AFL++的Seed Scheduling就是基于AFLFast的种子调度。</p><p>AFL++的Power Schedules除了AFLFast提到的6种，还有另外两种，Mmopt和Rare。</p><p>Mmopt主要关注那些最新发现的种子</p><p>而Rare主要关注那些具有罕见边的种子。</p><img src="https://z3.ax1x.com/2021/04/09/cNjX34.png" alt="cNjX34.png" style="zoom:57%;" /><h2 id="Mutators"><a href="#Mutators" class="headerlink" title="Mutators"></a>Mutators</h2><p>AFL++集成了许多mutator，包括RedQueen的Input-to-State mutator，包括Mopt mutator。</p><p>因此，AFL++就像一个框架，提供了一个自定义的mutator接口规范，实现这些接口，就可以将自己的mutator缝合到AFL++上，或者将不同的mutator缝合在一起。</p><p>AFL++除了提供了mutator的接口规范，还提供了trimming的借口规范。</p><h4 id="Input-To-State-Mutator"><a href="#Input-To-State-Mutator" class="headerlink" title="Input-To-State Mutator"></a>Input-To-State Mutator</h4><p>这个mutator是基于RedQueen的input-to-state.</p><p>这里主要介绍他和RedQueen不同的地方：</p><ul><li>Colorization<ul><li>RedQueen在染色时是保持程序执行路径不变，即hash of bitmap不变。</li><li>而AFL++除了保持程序的执行路径不变，还对程序的执行时间做了一定控制，规定了程序的执行时间下界为2x slowdown</li></ul></li><li>Bypass Comparison<ul><li>AFL++采用的是一种probabilistic fuzzing。即如果这个roadblock，使用替换的方法，或者修复的方法失败了，那fuzzer下一次就会以较小概率尝试绕过他。（当下解决不了的困难，先放一放zzzz）</li><li>不过其实RedQueen中也有相应的设计，RedQueen是使用的虚拟机断点hook cmp指令。因此，如果这个断电被hit的次数比较少，就将这个断点去掉。</li></ul></li><li>CmpLog Instrumentation<ul><li>RedQueen中采用的是虚拟机断点hook的cmp指令，当断点被hit时，再提取指令操作数。</li><li>而AFL++则是使用的一种共享表，每一个指令都记录他的前256次执行的操作数。</li></ul></li></ul><h3 id="MOpt-1"><a href="#MOpt-1" class="headerlink" title="MOpt"></a>MOpt</h3><p>AFL++中也缝合了MOpt的Pilot和Core模块。</p><p>并且可以和Input-to-State结合。</p><h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p>在插桩上，AFL++首先解决了边hit count溢出的问题。</p><p>因为在AFL中，边只会记录到255。</p><img src="https://z3.ax1x.com/2021/04/09/cNjOCF.png" alt="cNjOCF.png" style="zoom:50%;" /><p>有两种方法可以解决：</p><ol><li>NeverZero，加一个进位标志。NeverZero可以提高fuzzer的表现性能。</li><li>Saturated Counters：当计数超过255时，就停在255。这个做法，不推荐，反而会让fuzzer的性能变差。</li></ol><hr><p>除了使用NeverZero，AFL++还使用了Ngram优化边覆盖率的统计。</p><p>AFL原生的统计边覆盖率的代码是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location &#x3D; &lt;COMPILE_TIME_RANDOM&gt;; </span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location &#x3D; cur_location &gt;&gt; 1;</span><br></pre></td></tr></table></figure><p>AFL只考虑了上一个基本块和当前基本块，这样的计算速度更快，但会带来更多的碰撞。</p><p>而Ngram则是考虑当前基本块和前N-1个基本块表示该边，这样能部分碰撞，实验结果也表明Ngram能提高实验的性能。</p><p>AFL++实现了多种后端的插桩，具体实现的区别如下：</p><img src="https://z3.ax1x.com/2021/04/09/cNjzuR.png" alt="cNjzuR.png" style="zoom:50%;" /><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><p>略，具体可见<a href="https://www.kdocs.cn/l/cuo67y1vfOwL">slides</a>  。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><p>AFL：<a href="https://afl-1.readthedocs.io/en/latest/">https://afl-1.readthedocs.io/en/latest/</a></p></li><li><p>AFLFast: <a href="https://mboehme.github.io/paper/CCS16.pdf">https://mboehme.github.io/paper/CCS16.pdf</a></p><p><a href="https://github.com/mboehme/aflfast">https://github.com/mboehme/aflfast</a></p></li><li><p>RedQueen:<a href="https://react-h2020.eu/m/filer_public/6d/86/6d869f98-f544-49cc-8221-b380c593888f/ndss19-redqueen.pdf">https://react-h2020.eu/m/filer_public/6d/86/6d869f98-f544-49cc-8221-b380c593888f/ndss19-redqueen.pdf</a></p><p><a href="https://hexgolems.com/talks/redqueen.pdf">https://hexgolems.com/talks/redqueen.pdf</a></p></li><li><p>MOpt:<a href="https://www.usenix.org/system/files/sec19-lyu.pdf">https://www.usenix.org/system/files/sec19-lyu.pdf</a></p></li><li><p>AFLSmart: <a href="https://thuanpv.github.io/publications/TSE19_aflsmart.pdf">https://thuanpv.github.io/publications/TSE19_aflsmart.pdf</a></p></li><li><p>AFL++:<a href="https://aflplus.plus/papers/">https://aflplus.plus/papers/</a></p><p><a href="https://github.com/AFLplusplus/AFLplusplus">https://github.com/AFLplusplus/AFLplusplus</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天给大家分享的论文是一篇基于AFL的工作：AFL++：Combine Incremental Steps of Fuzzing Research，发表在USENIX Workshop。分享时的&lt;a href=&quot;https://www.kdocs.cn/l/cuo67y1vfOwL&quot;&gt;slides&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Paper" scheme="https://f7ed.com/categories/Paper/"/>
    
    
      <category term="Paper" scheme="https://f7ed.com/tags/Paper/"/>
    
      <category term="fuzz" scheme="https://f7ed.com/tags/fuzz/"/>
    
      <category term="AFL" scheme="https://f7ed.com/tags/AFL/"/>
    
      <category term="AFL++" scheme="https://f7ed.com/tags/AFL/"/>
    
      <category term="MOpt" scheme="https://f7ed.com/tags/MOpt/"/>
    
      <category term="RedQueen" scheme="https://f7ed.com/tags/RedQueen/"/>
    
      <category term="AFLFast" scheme="https://f7ed.com/tags/AFLFast/"/>
    
      <category term="AFLSmart" scheme="https://f7ed.com/tags/AFLSmart/"/>
    
      <category term="LAF-Intel" scheme="https://f7ed.com/tags/LAF-Intel/"/>
    
  </entry>
  
  <entry>
    <title>「PyTorch」：4-Neural Network Design</title>
    <link href="https://f7ed.com/2021/02/28/pytorch-nn-design/"/>
    <id>https://f7ed.com/2021/02/28/pytorch-nn-design/</id>
    <published>2021-02-27T16:00:00.000Z</published>
    <updated>2021-02-28T14:16:26.025Z</updated>
    
    <content type="html"><![CDATA[<p>PyTorch框架学习。</p><p>这篇文章主要介绍如何用PyTorch设计实现一个NN。</p><p>colab笔记：</p><p><a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%201%EF%BC%9AThe%20Layers.ipynb">Neural Network Design 1: The Layers</a> </p><p><a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%202%EF%BC%9ACallable%20Neural%20Networks.ipynb">Neural Network Design 2: Callable Neural Networks</a> </p><p><a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%203%EF%BC%9ACNN%20Forward%20Method.ipynb">Neural Network Design 3: CNN Forward Method</a> </p><p><a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%204%EF%BC%9APass%20A%20Batch%20of%20Images.ipynb">Neural Network Design 4: Pass A Batch of Images</a> </p><a id="more"></a><p>以CNN为例，讲解PyTorch中的layer、weight、</p><p>Overview：</p><ul><li>Build PyTorch CNN - Object Oriented Neural Networks</li><li>CNN Layers - Deep Neural Network Architecture</li><li>CNN Weights - Learnable Parameters in Neural Networks</li><li>Callable Neural Networks - Linear Layers in Depth</li><li>CNN Forward Method - Deep Learning Implementation</li><li>Forward Propagation Explained - Pass Image to PyTorch Neural Network</li><li>Neural Network Batch Processing - Pass Image Batch to PyTorch CNN</li><li>CNN Output Size Formula - Bonus Neural Network Debugging Session</li></ul><h1 id="Building-Neural-Networks-With-PyTorch"><a href="#Building-Neural-Networks-With-PyTorch" class="headerlink" title="Building Neural Networks With PyTorch"></a>Building Neural Networks With PyTorch</h1><p>From a high-level perspective or bird’s eye view of our deep learning project, we prepared our data, and now, we are ready to build our model.</p><p>【从高层次看，这一部分主要讲解如何用PyTorch设计model】</p><ul><li>Prepare the data</li><li><strong>Build the model</strong></li><li>Train the model</li><li>Analyze the model’s results</li></ul><p>We’ll do a quick OOP review in this post to cover the details needed for working with PyTorch neural networks, but if you find that you need more, the Python docs have an overview tutorial <a href="https://docs.python.org/3/tutorial/classes.html">here</a>.</p><p>【OOP的细节】</p><h3 id="PyTorch’s-torch-nn-Package"><a href="#PyTorch’s-torch-nn-Package" class="headerlink" title="PyTorch’s torch.nn Package"></a>PyTorch’s <code>torch.nn</code> Package</h3><p>To build neural networks in PyTorch, we use the <code>torch.nn</code> package, which is PyTorch’s neural network (nn) library. We typically import the package like so:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br></pre></td></tr></table></figure><p>PyTorch’s neural network library contains all of the typical components needed to build neural networks.</p><p>【nn库包含所有构建NN的典型组件】</p><h4 id="PyTorch’s-nn-Module-Class"><a href="#PyTorch’s-nn-Module-Class" class="headerlink" title="PyTorch’s nn.Module Class"></a>PyTorch’s <code>nn.Module</code> Class</h4><p>As we know, deep neural networks are built using multiple layers. This is what makes the network <em>deep</em>. Each layer in a neural network has two primary components:</p><p>【NN中的每一layer都由代码（input tensor到output tensor 的转换）和权重（weights）组成，因此可以用OOP的思想来抽象表示。】</p><ul><li>A transformation (code)</li><li>A collection of weights (data)</li></ul><p>In fact, this is the case with PyTorch. Within the <code>nn</code> package, there is a class called <code>Module</code>, and it is the base class for all of neural network modules which includes layers.</p><p>【nn库的Module类是所有NN模型中Layers的父类，即所有networks都要继承nn.Modules类】</p><h4 id="PyTorch-nn-Modules-Have-A-forward-Method"><a href="#PyTorch-nn-Modules-Have-A-forward-Method" class="headerlink" title="PyTorch nn.Modules Have A forward() Method"></a>PyTorch <code>nn.Module</code>s Have A <code>forward()</code> Method</h4><p>When we pass a tensor to our network as input, the tensor flows forward though each layer transformation until the tensor reaches the output layer. This process of a tensor flowing forward though the network is known as a <em>forward pass</em>.</p><p>【forward pass：tensor向前流，直至输出层】</p><p>Every PyTorch <code>nn.Module</code> has a <code>forward()</code> method, and so when we are building layers and networks, we must provide an implementation of the <code>forward()</code> method. The forward method is the actual transformation.</p><p>【所有layers 和 networks在继承nn.Module时，都要实现forward()接口，这个forward方法就是实际的输入到输出的转换】</p><h4 id="PyTorch’s-nn-functional-Package"><a href="#PyTorch’s-nn-functional-Package" class="headerlink" title="PyTorch’s nn.functional Package"></a>PyTorch’s <code>nn.functional</code> Package</h4><p>When we implement the <code>forward()</code> method of our <code>nn.Module</code> subclass, we will typically use functions from the <code>nn.functional</code> package. This package provides us with many neural network operations that we can use for building layers. In fact, many of the <code>nn.Module</code> layer classes use <code>nn.functional</code> functions to perform their operations.</p><p>【nn.functional包有很多实用的函数操作，可以帮助我们构建layers。事实上，nn.Module的许多子类就使用了nn.functional的方法来完成他们的操作。】</p><h1 id="Building-A-Neural-Network-In-PyTorch"><a href="#Building-A-Neural-Network-In-PyTorch" class="headerlink" title="Building A Neural Network In PyTorch"></a>Building A Neural Network In PyTorch</h1><p>We now have enough information to provide an outline for building neural networks in PyTorch. The steps are as follows:</p><p><em>Short version:</em></p><ol><li>Extend the <code>nn.Module</code> base class.【继承nn.Module类】</li><li>Define layers as class attributes.【定义layers作为该类的属性】</li><li>Implement the <code>forward()</code> method.【实现forward()接口】</li></ol><p><em>More detailed version:</em></p><ol><li>Create a neural network class that extends the <code>nn.Module</code> base class.</li><li>In the class constructor, define the network’s layers as class attributes using pre-built layers from <code>torch.nn</code>.</li><li>Use the network’s layer attributes as well as operations from the <code>nn.functional</code> API to define the network’s forward pass.</li></ol><h4 id="Define-The-Network’s-Layers-As-Class-Attributes"><a href="#Define-The-Network’s-Layers-As-Class-Attributes" class="headerlink" title="Define The Network’s Layers As Class Attributes"></a>Define The Network’s Layers As Class Attributes</h4><p>We’re building a CNN, so the two types of layers we’ll use are linear layers and convolutional layers.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">1</span>, out_channels=<span class="number">6</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">12</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        self.fc1 = nn.Linear(in_features=<span class="number">12</span> * <span class="number">4</span> * <span class="number">4</span>, out_features=<span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(in_features=<span class="number">120</span>, out_features=<span class="number">60</span>)</span><br><span class="line">        self.out = nn.Linear(in_features=<span class="number">60</span>, out_features=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, t)</span>:</span></span><br><span class="line">        <span class="comment"># implement the forward pass</span></span><br><span class="line">        <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure><p>Inside of our <code>Network</code> class, we have five layers that are defined as attributes. We have two convolutional layers, <code>self.conv1</code> and <code>self.conv2</code>, and three linear layers, <code>self.fc1</code>, <code>self.fc2</code>, <code>self.out</code>.</p><p>【在Network中，有5个layers作为该类的attributes】</p><p>We used the abbreviation <code>fc</code> in <code>fc1</code> and <code>fc2</code> because linear layers are also called <em>fully connected layers</em>. They also have a third name that we may hear sometimes called <em>dense</em>. So linear, dense, and fully connected are all ways to refer to the same type of layer. PyTorch uses the word <em>linear</em>, hence the <code>nn.Linear</code> class name.</p><p>We used the name <code>out</code> for the last linear layer because the last layer in the network is the output layer.</p><p>【fc是fully connected layers的缩写，全连接层，nn.Linear】</p><p>【out是输出层。】</p><h3 id="Our-CNN-Layers"><a href="#Our-CNN-Layers" class="headerlink" title="Our CNN Layers"></a>Our CNN Layers</h3><p>Each of our layers extends PyTorch’s neural network <code>Module</code> class. For each layer, there are two primary items encapsulated inside, a forward function definition and a weight tensor.</p><p>【每一layer都会继承PyTorch的Module类。对于每一layer，都会封装两个组件：forward函数和权重tensor】</p><p>The weight tensor inside each layer contains the weight values that are updated as the network learns during the training process.</p><p>【每一层的weitght tensor都包含在NN训练中更新的权重参数。】</p><p>PyTorch’s neural network <code>Module</code> class keeps track of the weight tensors inside each layer. The code that does this tracking lives inside the <code>nn.Module</code> class, and since we are extending the neural network module class, we inherit this functionality automatically.</p><p>【其中，权重tensor就是在训练NN中会更新的参数，Module类会自动跟踪其每一层的weight tensor】</p><h3 id="CNN-Layer-Parameters"><a href="#CNN-Layer-Parameters" class="headerlink" title="CNN Layer Parameters"></a>CNN Layer Parameters</h3><h4 id="Parameter-Vs-Argument"><a href="#Parameter-Vs-Argument" class="headerlink" title="Parameter Vs Argument"></a>Parameter Vs Argument</h4><p>We’ll parameters are used in function definitions as place-holders while arguments are the actual values that are passed to the function. The parameters can be thought of as local variables that live inside a function.</p><p>【Parameters作为占位符用于函数定义，而Arguments是传递给函数的实际的值。】</p><h4 id="Two-Types-Of-Parameters"><a href="#Two-Types-Of-Parameters" class="headerlink" title="Two Types Of Parameters"></a>Two Types Of Parameters</h4><p>To better understand the argument values for these parameters, let’s consider two categories or types of parameters that we used when constructing our layers.</p><p>【在构建layers时，有两种参数】</p><ol><li>Hyperparameters【超参数】</li><li>Data dependent hyperparameters【数据依赖超参数】</li></ol><p>When we construct a layer, we pass values for each parameter to the layer’s constructor. With our convolutional layers have three parameters and the linear layers have two parameters.</p><p>【在构建layer时，我们向layer constructor传递参数。】</p><ul><li>Convolutional layers<ul><li><code>in_channels</code></li><li><code>out_channels</code></li><li><code>kernel_size</code></li></ul></li><li>Linear layers<ul><li><code>in_features</code></li><li><code>out_features</code></li></ul></li></ul><h4 id="Hyperparameters"><a href="#Hyperparameters" class="headerlink" title="Hyperparameters"></a>Hyperparameters</h4><p>In general, hyperparameters are parameters whose values are chosen manually and arbitrarily.</p><p>【hyperparameters是手动主观确定的参数。】</p><p>As neural network programmers, we choose hyperparameter values mainly based on trial and error and increasingly by utilizing values that have proven to work well in the past. For building our CNN layers, these are the parameters we choose manually.</p><p>【超参数往往是基于经验trial和误差error确定的.】</p><p>【在CNN中，我们需要确定这些参数。】</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td><code>kernel_size</code></td><td>Sets the filter size. The words <em>kernel</em> and <em>filter</em> are interchangeable.</td></tr><tr><td><code>out_channels</code></td><td>Sets the number of filters. One filter produces one output channel.</td></tr><tr><td><code>out_features</code></td><td>Sets the size of the output tensor.</td></tr></tbody></table><h4 id="Data-Dependent-Hyperparameters"><a href="#Data-Dependent-Hyperparameters" class="headerlink" title="Data Dependent Hyperparameters"></a>Data Dependent Hyperparameters</h4><p>Data dependent hyperparameters are parameters whose values are dependent on data. The first two data dependent hyperparameters that stick out are the <code>in_channels</code> of the first convolutional layer, and the <code>out_features</code> of the output layer.</p><p>【依赖于数据的超参数。比如在第一个卷积层的in_channles和输出层的out_features参数的确定都依赖于数据。】</p><p>In general, the <em>input</em> to one layer is the <em>output</em> from the previous layer, and so all of the <code>in_channels</code> in the conv layers and <code>in_features</code> in the linear layers depend on the data coming from the previous layer.</p><p>【一个layer的输入依赖于前一层的输出。】</p><p>When we switch from a conv layer to a linear layer, we have to flatten our tensor. This is why we have <code>12*4*4</code>.</p><h4 id="Summary-Of-Layer-Parameters"><a href="#Summary-Of-Layer-Parameters" class="headerlink" title="Summary Of Layer Parameters"></a>Summary Of Layer Parameters</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(in_channels=<span class="number">1</span>, out_channels=<span class="number">6</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">12</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">self.fc1 = nn.Linear(in_features=<span class="number">12</span> * <span class="number">4</span> * <span class="number">4</span>, out_features=<span class="number">120</span>)</span><br><span class="line">self.fc2 = nn.Linear(in_features=<span class="number">120</span>, out_features=<span class="number">60</span>)</span><br><span class="line">self.out = nn.Linear(in_features=<span class="number">60</span>, out_features=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>Layer</th><th>Param name</th><th>Param value</th><th>The param value is</th></tr></thead><tbody><tr><td>conv1</td><td>in_channels</td><td>1</td><td>the number of color channels in the input image.</td></tr><tr><td>conv1</td><td>kernel_size</td><td>5</td><td>a hyperparameter.</td></tr><tr><td>conv1</td><td>out_channels</td><td>6</td><td>a hyperparameter.</td></tr><tr><td>conv2</td><td>in_channels</td><td>6</td><td>the number of out_channels in previous layer.</td></tr><tr><td>conv2</td><td>kernel_size</td><td>5</td><td>a hyperparameter.</td></tr><tr><td>conv2</td><td>out_channels</td><td>12</td><td>a hyperparameter (higher than previous conv layer).</td></tr><tr><td>fc1</td><td>in_features</td><td>12 * 4 * 4</td><td>the length of the flattened output from previous layer.</td></tr><tr><td>fc1</td><td>out_features</td><td>120</td><td>a hyperparameter.</td></tr><tr><td>fc2</td><td>in_features</td><td>120</td><td>the number of out_features of previous layer.</td></tr><tr><td>fc2</td><td>out_features</td><td>60</td><td>a hyperparameter (lower than previous linear layer).</td></tr><tr><td>out</td><td>in_features</td><td>60</td><td>the number of out_channels in previous layer.</td></tr><tr><td>out</td><td>out_features</td><td>10</td><td>the number of prediction classes.</td></tr></tbody></table><h1 id="CNN-Weights-Learnable-Parameters-In-Neural-Networks"><a href="#CNN-Weights-Learnable-Parameters-In-Neural-Networks" class="headerlink" title="CNN Weights - Learnable Parameters In Neural Networks"></a>CNN Weights - Learnable Parameters In Neural Networks</h1><p>Colab: <a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%201%EF%BC%9AThe%20Layers.ipynb">Neural Network Design: The Layers</a> </p><h3 id="Learnable-Parameters"><a href="#Learnable-Parameters" class="headerlink" title="Learnable Parameters"></a>Learnable Parameters</h3><p><em>Learnable parameters</em> are parameters whose values are learned during the training process.</p><p>【Learnable parameters是在训练中可以学习的参数。】</p><p>With learnable parameters, we typically start out with a set of arbitrary values, and these values then get updated in an iterative fashion as the network learns.</p><p>【从一个主观确定的值开始，在网络学习中迭代更新。】</p><p>Where are the learnable parameters?</p><p>We’ll the learnable parameters are the weights inside our network, and they live inside each layer.</p><p>【Learnable parameters存在在网络中的每一层，是在我们网络中的权重参数。】</p><h3 id="Getting-An-Instance-The-Network"><a href="#Getting-An-Instance-The-Network" class="headerlink" title="Getting An Instance The Network"></a>Getting An Instance The Network</h3><p> Let’s grab an instance of our network class and see this.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network = Network()</span><br></pre></td></tr></table></figure><p>After the object is initialized, we can then access our object using the network variable.</p><p>【获得一个网络的实例，即会自动运行<code>__init__</code> 对其初始化。】</p><h4 id="How-Overriding-Works"><a href="#How-Overriding-Works" class="headerlink" title="How Overriding Works"></a>How Overriding Works</h4><p>All Python classes automatically extend the object class. If we want to provide a custom string representation for our object, we can do it, but we need to introduce another object oriented concept called <em>overriding</em>.</p><p>【所有Python的类都会继承oobject class，可以重写该类的字符表达（string representation）。】</p><p>We can override Python’s default string representation using the <code>__repr__</code> function. This name is short for <em>representation</em>.</p><p>【重写<code>__repr__</code> 函数】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">network = Network()</span><br><span class="line"><span class="keyword">print</span> (network)</span><br><span class="line"></span><br><span class="line">Network(</span><br><span class="line">  (conv1): Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (conv2): Conv2d(<span class="number">6</span>, <span class="number">12</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (fc1): Linear(in_features=<span class="number">192</span>, out_features=<span class="number">120</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (fc2): Linear(in_features=<span class="number">120</span>, out_features=<span class="number">60</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (out): Linear(in_features=<span class="number">60</span>, out_features=<span class="number">10</span>, bias=<span class="literal">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="What’s-In-The-String-Representation"><a href="#What’s-In-The-String-Representation" class="headerlink" title="What’s In The String Representation?"></a>What’s In The String Representation?</h3><h4 id="Convolutional-Layers"><a href="#Convolutional-Layers" class="headerlink" title="Convolutional Layers"></a>Convolutional Layers</h4><p>For the convolutional layers, the kernel_size argument is a Python tuple <code>(5,5)</code> even though we only passed the number <code>5</code> in the constructor.</p><p>【kernel_size的值，确定filter的大小。当传递一个值时，默认为square filter。】</p><p>The stride is an additional parameter that we could have set, but we left it out. When the stride is not specified in the layer constructor the layer automatically sets it.</p><p>【kernel移动的stride如果没有设置会自动设置。】</p><h4 id="Linear-Layers"><a href="#Linear-Layers" class="headerlink" title="Linear Layers"></a>Linear Layers</h4><p>For the linear layers, we have an additional parameter called bias which has a default parameter value of true. It is possible to turn this off by setting it to false.</p><p>【linear layers还有一个自动设置为True的bias参数。】</p><h3 id="Accessing-The-Network’s-Layers"><a href="#Accessing-The-Network’s-Layers" class="headerlink" title="Accessing The Network’s Layers"></a>Accessing The Network’s Layers</h3><p>Well, now that we’ve got an instance of our network and we’ve reviewed our layers, let’s see how we can access them in code.</p><p>【如何访问NN中的layers：当一般属性访问，每一层都会返回一个字符表达】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; network.conv1</span><br><span class="line">Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">&gt; network.conv2</span><br><span class="line">Conv2d(<span class="number">6</span>, <span class="number">12</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">&gt; network.fc1</span><br><span class="line">Linear(in_features=<span class="number">192</span>, out_features=<span class="number">120</span>, bias=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">&gt; network.fc2                                    </span><br><span class="line">Linear(in_features=<span class="number">120</span>, out_features=<span class="number">60</span>, bias=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">&gt; network.out</span><br><span class="line">Linear(in_features=<span class="number">60</span>, out_features=<span class="number">10</span>, bias=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="Accessing-The-Layer-Weights"><a href="#Accessing-The-Layer-Weights" class="headerlink" title="Accessing The Layer Weights"></a>Accessing The Layer Weights</h3><p>Now that we have access to each of our layers, we can access the weights inside each layer. </p><p>【访问每一层的权重参数。】</p><p>Colab: <a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%201%EF%BC%9AThe%20Layers.ipynb">Neural Network Design: The Layers</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; network.conv1.weight</span><br></pre></td></tr></table></figure><h4 id="PyTorch-Parameter-Class"><a href="#PyTorch-Parameter-Class" class="headerlink" title="PyTorch Parameter Class"></a>PyTorch Parameter Class</h4><p>PyTorch has a special class called <code>Parameter</code>. The <code>Parameter</code> class extends the tensor class, and so the weight tensor inside every layer is an instance of this <code>Parameter</code> class.</p><p>【PyTorch还有一个特殊的类：Parameter类。这个类继承了tensor类，所以每一层中的weight tensor实则都是Parameter类的实例。】</p><h3 id="Weight-Tensor-Shape"><a href="#Weight-Tensor-Shape" class="headerlink" title="Weight Tensor Shape"></a>Weight Tensor Shape</h3><p>For the convolutional layers, the weight values live inside the filters, and in code, the filters are actually the weight tensors themselves.</p><p>【对卷积层来说，weight是在filter中的，而filter在代码中的体现就是weight tensor。】</p><p>The convolution operation inside a layer is an operation between the input channels to the layer and the filter inside the layer. This means that what we really have is an operation between two tensors.</p><p>【卷积操作实则就是input tensor 和filter 的weight tensor之间的操作。】</p><p>For the first conv layer, we have <code>1</code> color channel that should be convolved by <code>6</code> filters of size <code>5x5</code> to produce <code>6</code> output channels. This is how we interpret the values inside our layer constructor.</p><p>【对于第一个卷积层来说，有6个 5 * 5的filer，会生成6个输出channel。】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; network.conv1</span><br><span class="line">Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>Inside our layer though, we don’t explicitly have <code>6</code> weight tensors for each of the <code>6</code> filters. We actually represent all <code>6</code> filters using a single weight tensor whose shape reflects or accounts for the <code>6</code> filters.</p><p>【但我们不会使用6个weight tensor来表示该卷积层的6个filters，而是使用一个单独的weight tensor来表示该层的所有filers。】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; network.conv1.weight.shape</span><br><span class="line">torch.Size([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure><p>The second axis has a length of <code>1</code> which accounts for the single input channel, and the last two axes account for the height and width of the filter.</p><p>【weight tensor的第一维度表示filters的数量，该tensor把所有filters都打包在一起。第二维度认为是filter的depth，和输入tensor的channel相同，最后两维为height 和width】</p><p>The two main takeaways about these convolutional layers is that our filters are represented using a single tensor and that each filter inside the tensor also has a depth that accounts for the input channels that are being convolved.</p><p>【卷积层的两个要点（takeways）】</p><ol><li>All filters are represented using a single tensor.【用一个tensor表示该层的所有filters】</li><li>Filters have depth that accounts for the input channels.【其中每一个filter有depth，值等于输入的channels】</li></ol><p>卷积层Weight Tensor的shape：<strong>(Number of filters, Depth, Height, Width)</strong></p><h3 id="Weight-Matrix"><a href="#Weight-Matrix" class="headerlink" title="Weight Matrix"></a>Weight Matrix</h3><p>With linear layers or fully connected layers, we have flattened rank-1 tensors as input and as output. The way we transform the in_features to the out_features in a linear layer is by using a rank-2 tensor that is commonly called a weight matrix.</p><p>【对于全连接层，我们需要拉直（flatten）输入/输出为rank-1的tensor】</p><p>【这种在全连接层中in_features到out_features的转换，使用weight matrix来实现，所以该层的参数就是一个rank-2的tensor】</p><h4 id="Linear-Function-Represented-Using-A-Matrix"><a href="#Linear-Function-Represented-Using-A-Matrix" class="headerlink" title="Linear Function Represented Using A Matrix"></a>Linear Function Represented Using A Matrix</h4><p>The important thing about matrix multiplications like this is that they represent linear functions that we can use to build up our neural network.</p><p>Specifically, the weight matrix is a linear function also called a linear map that maps a vector space of <code>4</code> dimensions to a vector space of <code>3</code> dimensions.</p><p>【矩阵乘法实则是线性函数。具体来说，矩阵乘法也称为一个线性映射，将一个4D vector映射为一个3D vector。】</p><h3 id="Accessing-The-Networks-Parameters"><a href="#Accessing-The-Networks-Parameters" class="headerlink" title="Accessing The Networks Parameters"></a>Accessing The Networks Parameters</h3><p>【访问NN的所有参数】</p><p>The first example is the most common way, and we’ll use this to iterate over our weights when we update them during the training process.</p><p>【遍历<code>network.parameters()</code> 】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> network.parameters():</span><br><span class="line">    print(param.shape)</span><br><span class="line"></span><br><span class="line">torch.Size([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">torch.Size([<span class="number">6</span>])</span><br><span class="line">torch.Size([<span class="number">12</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">torch.Size([<span class="number">12</span>])</span><br><span class="line">torch.Size([<span class="number">120</span>, <span class="number">192</span>])</span><br><span class="line">torch.Size([<span class="number">120</span>])</span><br><span class="line">torch.Size([<span class="number">60</span>, <span class="number">120</span>])</span><br><span class="line">torch.Size([<span class="number">60</span>])</span><br><span class="line">torch.Size([<span class="number">10</span>, <span class="number">60</span>])</span><br><span class="line">torch.Size([<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>The second way is just to show how we can see the name as well. This reveals something that we won’t cover in detail, the bias is also a learnable parameter. Each layer has a bias by default, so for each layer we have a weight tensor and a bias tensor.</p><p>【每一层中的bias也是一个可学习的参数。】</p><p>【遍历<code>network.named_parameters()</code> 】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, param <span class="keyword">in</span> network.named_parameters():</span><br><span class="line">    print(name, <span class="string">'\t\t'</span>, param.shape)</span><br><span class="line"></span><br><span class="line">conv1.weight  torch.Size([<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">conv1.bias  torch.Size([<span class="number">6</span>])</span><br><span class="line">conv2.weight  torch.Size([<span class="number">12</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">conv2.bias  torch.Size([<span class="number">12</span>])</span><br><span class="line">fc1.weight  torch.Size([<span class="number">120</span>, <span class="number">192</span>])</span><br><span class="line">fc1.bias  torch.Size([<span class="number">120</span>])</span><br><span class="line">fc2.weight  torch.Size([<span class="number">60</span>, <span class="number">120</span>])</span><br><span class="line">fc2.bias  torch.Size([<span class="number">60</span>])</span><br><span class="line">out.weight  torch.Size([<span class="number">10</span>, <span class="number">60</span>])</span><br><span class="line">out.bias  torch.Size([<span class="number">10</span>])</span><br></pre></td></tr></table></figure><h1 id="Callable-Neural-Networks-Linear-Layers-In-Depth"><a href="#Callable-Neural-Networks-Linear-Layers-In-Depth" class="headerlink" title="Callable Neural Networks - Linear Layers In Depth"></a>Callable Neural Networks - Linear Layers In Depth</h1><p>Colab: <a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%202%EF%BC%9ACallable%20Neural%20Networks.ipynb">Neural Network Design 2: Callable Neural Networks</a> </p><p>In this one, we’ll learn about how PyTorch neural network modules are callable, what this means, and how it informs us about how our network and layer forward methods are called.</p><p>【在这一节中，我们能知道在network和layer中forward方法是如何调用的？】</p><h3 id="How-Linear-Layers-Work"><a href="#How-Linear-Layers-Work" class="headerlink" title="How Linear Layers Work"></a>How Linear Layers Work</h3><h4 id="Transform-Using-A-Matrix"><a href="#Transform-Using-A-Matrix" class="headerlink" title="Transform Using A Matrix"></a>Transform Using A Matrix</h4><p>【使用矩阵乘法来转换】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">in_features = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], dtype=torch.float32)</span><br><span class="line"></span><br><span class="line">weight_matrix = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">], dtype=torch.float32)</span><br><span class="line"></span><br><span class="line">&gt; weight_matrix.matmul(in_features)</span><br><span class="line">tensor([<span class="number">30.</span>, <span class="number">40.</span>, <span class="number">50.</span>])</span><br></pre></td></tr></table></figure><h4 id="Transform-Using-A-PyTorch-Linear-Layer"><a href="#Transform-Using-A-PyTorch-Linear-Layer" class="headerlink" title="Transform Using A PyTorch Linear Layer"></a>Transform Using A PyTorch Linear Layer</h4><p>【使用PyTorch Linear Layer来转换。】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc = nn.Linear(in_features=<span class="number">4</span>, out_features=<span class="number">3</span>, bias=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>【根据源码，在LinearLayer中会有一个3 * 4 的weight matrix】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># torch/nn/modules/linear.py (version 1.0.1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_features, out_features, bias=True)</span>:</span></span><br><span class="line">    super(Linear, self).__init__()</span><br><span class="line">    self.in_features = in_features</span><br><span class="line">    self.out_features = out_features</span><br><span class="line">    self.weight = Parameter(torch.Tensor(out_features, in_features))</span><br><span class="line">    <span class="keyword">if</span> bias:</span><br><span class="line">        self.bias = Parameter(torch.Tensor(out_features))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.register_parameter(<span class="string">'bias'</span>, <span class="literal">None</span>)</span><br><span class="line">    self.reset_parameters()</span><br></pre></td></tr></table></figure><p>Let’s see how we can call our layer now by passing the <code>in_features</code> tensor.</p><p>【直接传tensor来调用该layer】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; fc(in_features)</span><br><span class="line">tensor([<span class="number">-0.8877</span>,  <span class="number">1.4250</span>,  <span class="number">0.8370</span>], grad_fn=&lt;SqueezeBackward3&gt;)</span><br></pre></td></tr></table></figure><p>We can call the object instance like this because PyTorch neural network modules are callable Python objects.</p><p>【因为PyTorch中的module是可以调用的类，即类中有<code>__call__</code> 方法。</p><p>Let’s explicitly set the weight matrix of the linear layer to be the same as the one we used in our other example.</p><p>【可以单独设置linear layer中weight matrix的值】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc.weight = nn.Parameter(weight_matrix)</span><br></pre></td></tr></table></figure><h3 id="Callable-Layers-And-Neural-Networks"><a href="#Callable-Layers-And-Neural-Networks" class="headerlink" title="Callable Layers And Neural Networks"></a>Callable Layers And Neural Networks</h3><p>【可调用的Layers和NN】</p><p>We pointed out before how it was kind of strange that we called the layer object instance as if it were a function.</p><p>【为什么可以将实例作为函数调用？】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; fc(in_features)</span><br><span class="line">tensor([<span class="number">30.0261</span>, <span class="number">40.1404</span>, <span class="number">49.7643</span>], grad_fn=&lt;AddBackward0&gt;)</span><br></pre></td></tr></table></figure><p>What makes this possible is that PyTorch module classes implement another special Python function called <code>__call__()</code>. If a class implements the <code>__call__()</code> method, the special call method will be invoked anytime the object instance is called.</p><p>【如果该类实现了<code>__call()__</code> 方法，那么该类的实例就可以作为函数调用】</p><p>This fact is an important PyTorch concept because of the way the <code>__call__()</code> method interacts with the <code>forward()</code> method for our layers and networks.</p><p>【而PyTorch中该类的<code>__call__</code> 方法是和<code>forward()</code> 方法交互的】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *input, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> hook <span class="keyword">in</span> self._forward_pre_hooks.values():</span><br><span class="line">        hook(self, input)</span><br><span class="line">    <span class="keyword">if</span> torch._C._get_tracing_state():</span><br><span class="line">        result = self._slow_forward(*input, **kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = self.forward(*input, **kwargs)</span><br><span class="line">    <span class="keyword">for</span> hook <span class="keyword">in</span> self._forward_hooks.values():</span><br><span class="line">        hook_result = hook(self, input, result)</span><br><span class="line">        <span class="keyword">if</span> hook_result <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">"forward hooks should never return any values, but '&#123;&#125;'"</span></span><br><span class="line">                <span class="string">"didn't return None"</span>.format(hook))</span><br><span class="line">    <span class="keyword">if</span> len(self._backward_hooks) &gt; <span class="number">0</span>:</span><br><span class="line">        var = result</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> isinstance(var, torch.Tensor):</span><br><span class="line">            <span class="keyword">if</span> isinstance(var, dict):</span><br><span class="line">                var = next((v <span class="keyword">for</span> v <span class="keyword">in</span> var.values() <span class="keyword">if</span> isinstance(v, torch.Tensor)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                var = var[<span class="number">0</span>]</span><br><span class="line">        grad_fn = var.grad_fn</span><br><span class="line">        <span class="keyword">if</span> grad_fn <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> hook <span class="keyword">in</span> self._backward_hooks.values():</span><br><span class="line">                wrapper = functools.partial(hook, self)</span><br><span class="line">                functools.update_wrapper(wrapper, hook)</span><br><span class="line">                grad_fn.register_hook(wrapper)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>The extra code that PyTorch runs inside the <code>__call__()</code> method is why we never invoke the <code>forward()</code> method directly. If we did, the additional PyTorch code would not be executed. As a result, any time we want to invoke our <code>forward()</code> method, we call the object instance. This applies to both layers, and networks because they are both PyTorch neural network modules.</p><p>【因为有<code>__call__()</code> ，所以不需要直接调用<code>forward()</code> 方法。所以，如果任何时候我们想要调用<code>forward()</code> 方法时，我们都调用对象实例。】</p><h2 id="CNN-Forward-Method-PyTorch-Deep-Learning-Implementation"><a href="#CNN-Forward-Method-PyTorch-Deep-Learning-Implementation" class="headerlink" title="CNN Forward Method - PyTorch Deep Learning Implementation"></a>CNN Forward Method - PyTorch Deep Learning Implementation</h2><p>Colab: <a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%203%EF%BC%9ACNN%20Forward%20Method.ipynb">CNN Forward Method</a> </p><p>We created our network by extending the <code>nn.Module</code> PyTorch base class, and then, in the class constructor, we defined the network’s layers as class attributes. Now, we need to implement our network’s <code>forward()</code> method, and then, finally, we’ll be ready to train our model.</p><p>【前面通过继承<code>nn.Module</code> 来构建model，在model的构造器中，定义网络的layer作为model的属性。而构建model的最后一步是实现model中的<code>forward()</code> 方法】</p><p>【步骤】</p><ul><li><p>Prepare the data</p></li><li><p>Build the model</p><ol><li><p>Create a neural network class that extends the <code>nn.Module</code> base class.</p></li><li><p>In the class constructor, define the network’s layers as class attributes.</p></li><li><p><strong>Use the network’s layer attributes as well <code>nn.functional</code> API operations to define the network’s forward pass.</strong></p><p>【用网络的layer属性和nn.functional 库的激活函数等来定义网络的前向传播】</p></li></ol></li><li><p>Train the model</p></li><li><p>Analyze the model’s results</p></li></ul><h3 id="Implementing-The-forward-Method"><a href="#Implementing-The-forward-Method" class="headerlink" title="Implementing The forward() Method"></a>Implementing The <code>forward()</code> Method</h3><p>Colab: <a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%203%EF%BC%9ACNN%20Forward%20Method.ipynb">Neural Network Design 3: CNN Forward Method</a> </p><p>【实现forward()方法】</p><h4 id="Input-Layer-1"><a href="#Input-Layer-1" class="headerlink" title="Input Layer #1"></a>Input Layer #1</h4><p>The input layer of any neural network is determined by the input data.</p><p>【input layer 依赖于输入的数据】</p><p>For this reason, we can think of the input layer as the identity transformation. Mathematically, this is the function, $f(x)=x$ .</p><p>【可以把input layer看作identification transformation】</p><h4 id="Hidden-Convolutional-Layers-Layers-2-And-3"><a href="#Hidden-Convolutional-Layers-Layers-2-And-3" class="headerlink" title="Hidden Convolutional Layers: Layers #2 And #3"></a>Hidden Convolutional Layers: Layers #2 And #3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (2) hidden conv layer</span></span><br><span class="line">t = self.conv1(t)</span><br><span class="line">t = F.relu(t)</span><br><span class="line">t = F.max_pool2d(t, kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (3) hidden conv layer</span></span><br><span class="line">t = self.conv2(t)</span><br><span class="line">t = F.relu(t)</span><br><span class="line">t = F.max_pool2d(t, kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>Each of these layers is comprised of a collection of weights (data) and a collection operations (code). The weights are encapsulated inside the <code>nn.Conv2d()</code> class instance. The <code>relu()</code> and the <code>max_pool2d()</code> calls are just pure operations. </p><p>【每一层都是weights和operations的组合，weights封装在nn.Conv2d实例中，而relu()和max_pool2d()都是单纯的operations】</p><p>For example, we’ll say that the second layer in our network is a convolutional layer that contains a collection of weights, and preforms three operations, a convolution operation, the relu activation operation, and the max pooling operation.</p><p>【只是其中的一种表示：认为卷积层有一组weights（layer中包含的weights），三组操作：卷积操作、relu操作和max pooling 操作。】</p><p>Mathematically, the entire network is just a composition of functions, and a composition of functions is a function itself. So a network is just a function. All the terms like layers, activation functions, and weights, are just used to help describe the different parts.</p><p>【整个网络，其实就是functions的组合。因此，network本身就是一个function。layers, activation functions, weights只是来帮助描述这个function】</p><h4 id="Hidden-Linear-Layers-Layers-4-And-5"><a href="#Hidden-Linear-Layers-Layers-4-And-5" class="headerlink" title="Hidden Linear Layers: Layers #4 And #5"></a>Hidden Linear Layers: Layers #4 And #5</h4><p>Before we pass our input to the first hidden linear layer, we must <code>reshape()</code> or flatten our tensor. This will be the case any time we are passing output from a convolutional layer as input to a linear layer.</p><p>【在将卷积层的输出传递给全连接层之前，需要将他flatten】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (4) hidden linear layer</span></span><br><span class="line">t = t.reshape(<span class="number">-1</span>, <span class="number">12</span> * <span class="number">4</span> * <span class="number">4</span>)</span><br><span class="line">t = self.fc1(t)</span><br><span class="line">t = F.relu(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (5) hidden linear layer</span></span><br><span class="line">t = self.fc2(t)</span><br><span class="line">t = F.relu(t)</span><br></pre></td></tr></table></figure><h4 id="Output-Layer-6"><a href="#Output-Layer-6" class="headerlink" title="Output Layer #6"></a>Output Layer #6</h4><p>The sixth and last layer of our network is a linear layer we call the output layer. When we pass our tensor to the output layer, the result will be the prediction tensor.</p><p>【第六层是输出层，该层的输出是一个有10个元素的tensor】</p><p>Inside the network we usually use <code>relu()</code> as our <a href="https://deeplizard.com/learn/video/m0pIlLfpXWE">non-linear activation function</a>, but for the output layer, whenever we have a single category that we are trying to predict, we use <code>softmax()</code>. The <a href="https://en.wikipedia.org/wiki/Softmax_function">softmax function</a> returns a positive probability for each of the prediction classes, and the probabilities sum to <code>1</code>.</p><p>【前面的层我们都是用relu()来作为非线性函数，但输出层需要得到每一类的预测值，因此使用softmax()】</p><p>【softmax能返回每一类的预测概率，所有类的概率和为1】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, t)</span>:</span></span><br><span class="line">    <span class="comment"># (1) input layer</span></span><br><span class="line">    t = t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (2) hidden conv layer</span></span><br><span class="line">    t = self.conv1(t)</span><br><span class="line">    t = F.relu(t)</span><br><span class="line">    t = F.max_pool2d(t, kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (3) hidden conv layer</span></span><br><span class="line">    t = self.conv2(t)</span><br><span class="line">    t = F.relu(t)</span><br><span class="line">    t = F.max_pool2d(t, kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (4) hidden linear layer</span></span><br><span class="line">    t = t.reshape(<span class="number">-1</span>, <span class="number">12</span> * <span class="number">4</span> * <span class="number">4</span>)</span><br><span class="line">    t = self.fc1(t)</span><br><span class="line">    t = F.relu(t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (5) hidden linear layer</span></span><br><span class="line">    t = self.fc2(t)</span><br><span class="line">    t = F.relu(t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># (6) output layer</span></span><br><span class="line">    t = self.out(t)</span><br><span class="line">    <span class="comment">#t = F.softmax(t, dim=1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure><h1 id="Forward-Propagation-Explained"><a href="#Forward-Propagation-Explained" class="headerlink" title="Forward Propagation Explained"></a>Forward Propagation Explained</h1><h3 id="Forward-Propagation-Explained-1"><a href="#Forward-Propagation-Explained-1" class="headerlink" title="Forward Propagation Explained"></a>Forward Propagation Explained</h3><p><em>Forward propagation</em> is the process of transforming an input tensor to an output tensor. </p><p>【前馈传播是将输入tensor转换为输出tensor的过程。】</p><h3 id="Predicting-With-The-Network-Forward-Pass"><a href="#Predicting-With-The-Network-Forward-Pass" class="headerlink" title="Predicting With The Network: Forward Pass"></a>Predicting With The Network: Forward Pass</h3><p>Before we being, we are going to turn off PyTorch’s gradient calculation feature. This will stop PyTorch from automatically building a computation graph as our tensor flows through the network.</p><p>【在开始之前，我们需要关闭PyTorch的gradient计算。当tensor流过网络图时，这会阻止PyTorch自动构建计算图。】</p><p>The computation graph keeps track of the network’s mapping by tracking each computation that happens. The graph is used during the training process to calculate the derivative (gradient) of the loss function with respect to the network’s weights.</p><p>【计算图通过跟踪计算来跟踪网络图，该计算图在训练过程中用于计算损失函数对权重参数的梯度。】</p><p>Since we are not training the network yet, we aren’t planning on updating the weights, and so we don’t require gradient calculations. We will turn this back on when training begins.</p><p>【因为我们还没有训练网络，所以我们并不打算更新参数，也就不需要梯度计算。】</p><h4 id="Passing-A-Single-Image-To-The-Network"><a href="#Passing-A-Single-Image-To-The-Network" class="headerlink" title="Passing A Single Image To The Network"></a>Passing A Single Image To The Network</h4><p>Let’s continue by creating an instance of our Network class:</p><p>【创建NN实例】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; network = Network()</span><br></pre></td></tr></table></figure><p>Next, we’ll procure a single sample from our training set, unpack the image and the label, and verify the image’s shape:</p><p>【从training set中生成一个单独的例子。】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sample = next(iter(train_set)) </span><br><span class="line">&gt; image, label = sample </span><br><span class="line">&gt; image.shape </span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>])</span><br></pre></td></tr></table></figure><p>Now, there’s a second step we must preform before simply passing this tensor to our network. When we pass a tensor to our network, the network is expecting a batch, so even if we want to pass a single image, we still need a batch.</p><p>【第二步，网络期望传递的tensor是一批，因此需要将单独的例子也打包。】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; pred = network(image.unsqueeze(<span class="number">0</span>)) <span class="comment"># image shape needs to be (batch_size × in_channels × H × W)</span></span><br><span class="line"></span><br><span class="line">&gt; pred</span><br><span class="line">tensor([[<span class="number">0.0991</span>, <span class="number">0.0916</span>, <span class="number">0.0907</span>, <span class="number">0.0949</span>, <span class="number">0.1013</span>, <span class="number">0.0922</span>, <span class="number">0.0990</span>, <span class="number">0.1130</span>, <span class="number">0.1107</span>, <span class="number">0.1074</span>]])</span><br><span class="line"></span><br><span class="line">&gt; pred.shape</span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">&gt; label</span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line">&gt; pred.argmax(dim=<span class="number">1</span>)</span><br><span class="line">tensor([<span class="number">7</span>])</span><br></pre></td></tr></table></figure><p>For each input in the batch, and for each prediction class, we have a prediction value. If we wanted these values to be probabilities, we could just the <code>softmax()</code> function from the <code>nn.functional</code> package.</p><p>【用F.softmax()将预测值转换为概率。】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; F.softmax(pred, dim=<span class="number">1</span>)</span><br><span class="line">tensor([[<span class="number">0.1096</span>, <span class="number">0.1018</span>, <span class="number">0.0867</span>, <span class="number">0.0936</span>, <span class="number">0.1102</span>, <span class="number">0.0929</span>, <span class="number">0.1083</span>, <span class="number">0.0998</span>, <span class="number">0.0943</span>, <span class="number">0.1030</span>]])</span><br><span class="line"></span><br><span class="line">&gt; F.softmax(pred, dim=<span class="number">1</span>).sum()</span><br><span class="line">tensor(<span class="number">1.</span>)</span><br></pre></td></tr></table></figure><h3 id="Neural-Network-Batch-Processing-With-PyTorch"><a href="#Neural-Network-Batch-Processing-With-PyTorch" class="headerlink" title="Neural Network Batch Processing With PyTorch"></a>Neural Network Batch Processing With PyTorch</h3><ul><li>Prepare the data</li><li>Build the model<ul><li><strong>Understand how batches are passed to the network</strong></li></ul></li><li>Train the model</li><li>Analyze the model’s results</li></ul><p>Colab: <a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%204%EF%BC%9APass%20A%20Batch%20of%20Images.ipynb">Pass A Batch of Images</a> </p><h3 id="Using-Argmax-Prediction-Vs-Label"><a href="#Using-Argmax-Prediction-Vs-Label" class="headerlink" title="Using Argmax: Prediction Vs Label"></a>Using Argmax: Prediction Vs Label</h3><p>Colab: <a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%204%EF%BC%9APass%20A%20Batch%20of%20Images.ipynb">Pass A Batch of Images</a> </p><h2 id="CNN-Output-Size-Formula"><a href="#CNN-Output-Size-Formula" class="headerlink" title="CNN Output Size Formula"></a>CNN Output Size Formula</h2><h3 id="CNN-Output-Size-Formula-1"><a href="#CNN-Output-Size-Formula-1" class="headerlink" title="CNN Output Size Formula"></a>CNN Output Size Formula</h3><h4 id="CNN-Output-Size-Formula-Square"><a href="#CNN-Output-Size-Formula-Square" class="headerlink" title="CNN Output Size Formula (Square)"></a>CNN Output Size Formula (Square)</h4><ul><li>Suppose we have an $n\times n$ input.【输入尺寸】</li><li>Suppose we have an $f\times f$ filter.【filter尺寸】</li><li>Suppose we have a padding of $p$ and a stride of $s$ .【padding和stride】</li></ul><p>The output size $O$ is given by this formula: $O = \frac{n-f+2p}{s}+1$ 【输出】</p><h4 id="CNN-Output-Size-Formula-Non-Square"><a href="#CNN-Output-Size-Formula-Non-Square" class="headerlink" title="CNN Output Size Formula (Non-Square)"></a>CNN Output Size Formula (Non-Square)</h4><ul><li>Suppose we have an $n_h×n_w$ input.</li><li>Suppose we have an $f_h×f_w$ filter.</li><li>Suppose we have a padding of $p$ and a stride of $s$.</li></ul><p>The height of the output size $O_h$ is given by this formula:$O_h = \frac{n_h-f_h+2p}{s}+1$</p><p>The width of the output size $O_w$ is given by this formula: $O_w = \frac{n_w-f_w+2p}{s}+1$ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PyTorch框架学习。&lt;/p&gt;
&lt;p&gt;这篇文章主要介绍如何用PyTorch设计实现一个NN。&lt;/p&gt;
&lt;p&gt;colab笔记：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%201%EF%BC%9AThe%20Layers.ipynb&quot;&gt;Neural Network Design 1: The Layers&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%202%EF%BC%9ACallable%20Neural%20Networks.ipynb&quot;&gt;Neural Network Design 2: Callable Neural Networks&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%203%EF%BC%9ACNN%20Forward%20Method.ipynb&quot;&gt;Neural Network Design 3: CNN Forward Method&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Neural%20Network%20Design%204%EF%BC%9APass%20A%20Batch%20of%20Images.ipynb&quot;&gt;Neural Network Design 4: Pass A Batch of Images&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://f7ed.com/categories/PyTorch/"/>
    
    
      <category term="open-classes" scheme="https://f7ed.com/tags/open-classes/"/>
    
      <category term="DEEPLIZARD" scheme="https://f7ed.com/tags/DEEPLIZARD/"/>
    
      <category term="PyTorch" scheme="https://f7ed.com/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>「PyTorch」：3-Data And Data Processing</title>
    <link href="https://f7ed.com/2021/02/27/pytorch-data/"/>
    <id>https://f7ed.com/2021/02/27/pytorch-data/</id>
    <published>2021-02-26T16:00:00.000Z</published>
    <updated>2021-02-28T14:13:35.036Z</updated>
    
    <content type="html"><![CDATA[<p>PyTorch框架学习。</p><p>这篇文章介绍了深度学习中的数据和数据处理的常用类DataSet和DataLoader。</p><p>colab笔记：<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Data%20And%20Data%20Processing.ipynb">Data And Data Processing</a> </p><a id="more"></a><h1 id="Data-Fashion-MNIST"><a href="#Data-Fashion-MNIST" class="headerlink" title="Data-Fashion MNIST"></a>Data-Fashion MNIST</h1><h2 id="Why-Study-A-Dataset"><a href="#Why-Study-A-Dataset" class="headerlink" title="Why Study A Dataset?"></a>Why Study A Dataset?</h2><p>Data is the primary ingredient of deep learning.</p><p>【Data是deep learning的原材料】</p><p>Data focused considerations:</p><ul><li>Who created the dataset?【谁收集的数据集】</li><li>How was the dataset created?【数据集是如何收集的】</li><li>What transformations were used?【数据运用了哪些变换】</li><li>What intent does the dataset have?【数据集的意图是什么】</li><li>Possible unintentional consequences?【还可能有什么其他结果吗】</li><li>Is the dataset biased?【数据集是否是biased】</li><li>Are there ethical issues with the dataset?【数据集会引起道德问题吗】</li></ul><h2 id="What-Is-The-MNIST-Dataset"><a href="#What-Is-The-MNIST-Dataset" class="headerlink" title="What Is The MNIST Dataset?"></a>What Is The MNIST Dataset?</h2><p>The MNIST dataset, Modified National Institute of Standards and Technology database, is a famous dataset of handwritten digits that is commonly used for training image processing systems for machine learning. NIST stands for National Institute of Standards and Technology.</p><p>【MNIST, 全称Modified National Institute of Standards and Technology。著名的手写数据集，用于训练图像处理系统。】</p><p>MNIST is famous because of how often the dataset is used. It’s common for two reasons:</p><ol><li>Beginners use it because it’s easy</li><li>Researchers use it to benchmark (compare) different models.</li></ol><p>【MNIST简单；其次研究者常常用MNIST作为其他模型的基准】</p><p>The dataset consists of <code>70,000</code> images of hand written digits with the following split:</p><ul><li><code>60,000</code> training images</li><li><code>10,000</code> testing images</li></ul><p>【MNIST的组成，60000个training 图像，10000个testing图像】</p><p>MNIST has been so widely used, and image recognition tech has improved so much that the dataset is considered to be too easy. This is why the Fashion-MNIST dataset was created.</p><p>【因为MNIST数据集太过简单了，因此Fashion-MNIST数据集出现了】</p><h2 id="What-Is-Fashion-MNIST"><a href="#What-Is-Fashion-MNIST" class="headerlink" title="What Is Fashion-MNIST?"></a>What Is Fashion-MNIST?</h2><p><em>Fashion-MNIST</em> as the name suggests is a dataset of fashion items. Specifically, the dataset has the following ten classes of fashion items:</p><p>【Fashion-MNIST数据集由许多fashion的物件组成，物件类别如下。】</p><table><thead><tr><th>Index</th><th>Label</th></tr></thead><tbody><tr><td>0</td><td>T-shirt/top</td></tr><tr><td>1</td><td>Trouser</td></tr><tr><td>2</td><td>Pullover</td></tr><tr><td>3</td><td>Dress</td></tr><tr><td>4</td><td>Coat</td></tr><tr><td>5</td><td>Sandal</td></tr><tr><td>6</td><td>Shirt</td></tr><tr><td>7</td><td>Sneaker</td></tr><tr><td>8</td><td>Bag</td></tr><tr><td>9</td><td>Ankle boot</td></tr></tbody></table><p> Fashion-MNIST is based on the assortment on Zalando’s website. Zalando is a German based multi-national fashion commerce company that was founded in 2008.</p><p>【Fashion-MNIST数据集中的数据都是来着Zalando网址上售卖的样图，Zalando创立于2008年，是一家德国跨国时尚公司】</p><p>We’ll see the specific ways that Fashion-MNIST mirrors the original dataset in the paper, but one thing we have already seen is the number of classes.</p><ul><li>MNIST – has 10 classes (one for each digit 0-9)</li><li>Fashion-MNIST – has 10 classes (this is intentional)</li></ul><p>【Fashion-MNIST和MNIST是镜像对应的，比如他们都有10个类别】</p><h4 id="How-Fashion-MNIST-Was-Built"><a href="#How-Fashion-MNIST-Was-Built" class="headerlink" title="How Fashion-MNIST Was Built"></a>How Fashion-MNIST Was Built</h4><p>Unlike the MNIST dataset, the fashion set wasn’t hand-drawn, but the images in the dataset are actual images from Zalando’s website.</p><p>【Fashion-MNNST中所有的图像都来自Zalando的官网的图片，再通过多种变换，变成28*28的图像】</p><h1 id="Extract-Transform-Load-ETL"><a href="#Extract-Transform-Load-ETL" class="headerlink" title="Extract, Transform, Load(ETL)"></a>Extract, Transform, Load(ETL)</h1><p>There are four general steps that we’ll be following as we move through this project:</p><p>【一般分为4步：准备数据；构建模型；训练模型；分析结果】</p><ol><li>Prepare the data</li><li>Build the model</li><li>Train the model</li><li>Analyze the model’s results</li></ol><h2 id="The-ETL-Process"><a href="#The-ETL-Process" class="headerlink" title="The ETL Process"></a>The ETL Process</h2><p>In this post, we’ll kick things off by preparing the data. To prepare our data, we’ll be following what is loosely known as an ETL process.</p><p>【准备数据的过程一般又叫ETL过程：提取、转化、装载】</p><ul><li><p>Extract data from a data source.【从数据源提取数据】</p></li><li><p>Transform data into a desirable format.【转化为便于处理的格式】</p></li><li><p>Load data into a suitable structure.【装载数据，便于读取】</p></li></ul><p>PyTorch包的主要组成：</p><table><thead><tr><th>Package</th><th>Description</th></tr></thead><tbody><tr><td>torch</td><td>PyTorch的顶层包和tensor库</td></tr><tr><td>torch.nn</td><td>包含构建NN的模型和扩展类</td></tr><tr><td>torch.autograd</td><td>PyTorch中支持的Tensor操作</td></tr><tr><td>torch.nn.functional</td><td>包含构建NN的函数接口，像loss function, activation fucntion, convolution operation</td></tr><tr><td>torch.optim</td><td>包含标准的优化，像SGD, Adam</td></tr><tr><td>torch.utils</td><td>包含实用类，像数据集，数据装载器，方便数据预处理</td></tr><tr><td>torchvision</td><td>提供著名的数据集，模型架构和计算机视觉图像转换</td></tr></tbody></table><ul><li><p>torchvision.transforms: An interface that contains common transforms for image processing.</p><p>【一个包含图像转换（用于图像处理）的接口。】</p></li></ul><p>常用包：</p><ul><li><p>pandas:<a href="https://www.pypandas.cn/">https://www.pypandas.cn/</a></p><p>Pandas是一个强大的分析结构化数据的工具集；它的使用基础是Numpy（提供高性能的矩阵运算）；用于数据挖掘和数据分析，同时也提供数据清洗功能。</p></li><li><p>NumPy: <a href="https://www.numpy.org.cn/user/setting-up.html">https://www.numpy.org.cn/user/setting-up.html</a></p><p>NumPy是Python中科学计算的基础包。它是一个Python库，提供多维数组对象，各种派生对象（如掩码数组和矩阵），以及用于数组快速操作的各种API，有包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数，基本统计运算和随机模拟等等。</p></li><li><p>Matplotlib：<a href="https://www.matplotlib.org.cn/">https://www.matplotlib.org.cn/</a></p><p>Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。Matplotlib可用于Python脚本，Python和<a href="http://ipython.org/">IPython</a> Shell、<a href="http://jupyter.org/">Jupyter</a>笔记本，Web应用程序服务器和四个图形用户界面工具包。</p><p>为了简单绘图，该 <code>pyplot</code> 模块提供了类似于MATLAB的界面，尤其是与IPython结合使用时。 对于高级用户，您可以通过面向对象的界面或MATLAB用户熟悉的一组功能来完全控制线型，字体属性，轴属性等。</p></li><li><p>pdb 是Python的调试器。</p></li></ul><h2 id="Preparing-Our-Data"><a href="#Preparing-Our-Data" class="headerlink" title="Preparing Our Data"></a>Preparing Our Data</h2><ol><li>Extract – Get the <a href="https://deeplizard.com/learn/video/EqpzfvxBx30">Fashion-MNIST</a> image data from the source.【获得Fashion-MNIST数据集】</li><li>Transform – Put our data into tensor form.【转换：将我们的数据转换为tensor】</li><li>Load – Put our data into an object to make it easily accessible.【装载：聚合数据为一个对象，方便获取】</li></ol><p>For these purposes, PyTorch provides us with two classes:</p><p>【PyTorch为处理数据所提供的两个类】</p><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td>torch.utils.data.Dataset</td><td>数据集的抽象类</td></tr><tr><td>torch.utils.data.DataLoader</td><td>打包数据集，提供访问底层数据的接口。</td></tr></tbody></table><p>To create a custom dataset using PyTorch, we extend the <code>Dataset</code> class by creating a subclass that implements these required methods. Upon doing this, our new subclass can then be passed to the a PyTorch <code>DataLoader</code> object.</p><p>【创建数据集必须继承Dataset类，继承的子类作为参数传递给DataLoader对象】</p><p>All subclasses of the Dataset class must override <code>__len__</code>, that provides the size of the dataset, and <code>__getitem__</code>, supporting integer indexing in range from <code>0</code> to <code>len(self)</code> exclusive.</p><p>【Dateset的子类必须重写<code>__len__</code> 方法（表示数据集的大小），重写<code>__getitem__</code> （按索引获得特定数据）】</p><h3 id="PyTorch-Torchvision-Package"><a href="#PyTorch-Torchvision-Package" class="headerlink" title="PyTorch Torchvision Package"></a>PyTorch Torchvision Package</h3><p>The <code>torchvision</code> package, gives us access to the following resources:</p><p>【torchvision主要提供一些典型数据集、模型、转换、工具】</p><ul><li>Datasets (like MNIST and Fashion-MNIST)</li><li>Models (like VGG16)</li><li>Transforms</li><li>Utils</li></ul><p>The PyTorch <code>FashionMNIST</code> dataset simply extends the <code>MNIST</code> dataset and overrides the urls.</p><p>【FashionMNIST数据集继承了MNIST数据集，只重写了数据集的url】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FashionMNIST</span><span class="params">(MNIST)</span>:</span></span><br><span class="line">    <span class="string">"""`Fashion-MNIST &lt;https://github.com/zalandoresearch/fashion-mnist&gt;`_ Dataset.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        root (string): Root directory of dataset where ``processed/training.pt``</span></span><br><span class="line"><span class="string">            and  ``processed/test.pt`` exist.</span></span><br><span class="line"><span class="string">        train (bool, optional): If True, creates dataset from ``training.pt``,</span></span><br><span class="line"><span class="string">            otherwise from ``test.pt``.</span></span><br><span class="line"><span class="string">        download (bool, optional): If true, downloads the dataset from the internet and</span></span><br><span class="line"><span class="string">            puts it in root directory. If dataset is already downloaded, it is not</span></span><br><span class="line"><span class="string">            downloaded again.</span></span><br><span class="line"><span class="string">        transform (callable, optional): A function/transform that  takes in an PIL image</span></span><br><span class="line"><span class="string">            and returns a transformed version. E.g, ``transforms.RandomCrop``</span></span><br><span class="line"><span class="string">        target_transform (callable, optional): A function/transform that takes in the</span></span><br><span class="line"><span class="string">            target and transforms it.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    urls = [</span><br><span class="line">        <span class="string">'http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-images-idx3-ubyte.gz'</span>,</span><br><span class="line">        <span class="string">'http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-labels-idx1-ubyte.gz'</span>,</span><br><span class="line">        <span class="string">'http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-images-idx3-ubyte.gz'</span>,</span><br><span class="line">        <span class="string">'http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-labels-idx1-ubyte.gz'</span>,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>Let’s see now how we can take advantage of <code>torchvision</code>.</p><h4 id="PyTorch-Dataset-Class"><a href="#PyTorch-Dataset-Class" class="headerlink" title="PyTorch Dataset Class"></a>PyTorch Dataset Class</h4><p>To get an instance of the FashionMNIST dataset using <code>torchvision</code>, we just create one like so:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">train_set = torchvision.datasets.FashionMNIST(</span><br><span class="line">    root=<span class="string">'./data'</span></span><br><span class="line">    ,train=<span class="literal">True</span></span><br><span class="line">    ,download=<span class="literal">True</span></span><br><span class="line">    ,transform=transforms.Compose([</span><br><span class="line">        transforms.ToTensor()</span><br><span class="line">    ])</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>We specify the following arguments:</p><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>root</td><td>The location on disk where the data is located.【数据集的位置】</td></tr><tr><td>train</td><td>If the dataset is the training set.【是否是训练数据集】</td></tr><tr><td>download</td><td>If the data should be downloaded.【如果数据集不存在，是否下载】</td></tr><tr><td>transform</td><td>A composition of transformations that should be performed on the dataset elements.【变换的组合】</td></tr></tbody></table><h4 id="PyTorch-DataLoader-Class"><a href="#PyTorch-DataLoader-Class" class="headerlink" title="PyTorch DataLoader Class"></a>PyTorch DataLoader Class</h4><p>To create a DataLoader wrapper for our training set, we do it like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_loader = torch.utils.data.DataLoader(train_set</span><br><span class="line">    ,batch_size=<span class="number">1000</span></span><br><span class="line">    ,shuffle=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>【DataLoader，聚合数据集和取样器，提供数据集的迭代器】</p><p>We just pass train_set as an argument. Now, we can leverage the loader for tasks that would otherwise be pretty complicated to implement by hand:</p><p>【DataLoader能让一些手动实现复杂的简单化】</p><ul><li><code>batch_size</code> (1000 in our case)</li><li><code>shuffle</code> (True in our case)</li><li><code>num_workers</code> (Default is 0 which means the main process will be used)</li></ul><h1 id="PyTorch-Datasets-And-DataLoaders"><a href="#PyTorch-Datasets-And-DataLoaders" class="headerlink" title="PyTorch Datasets And DataLoaders"></a>PyTorch Datasets And DataLoaders</h1><h2 id="Working-With-The-Training-Set"><a href="#Working-With-The-Training-Set" class="headerlink" title="Working With The Training Set"></a>Working With The Training Set</h2><p>In this post, we are going to see how we can work with the dataset and the data loader objects that we created in the previous post. </p><h3 id="PyTorch-Dataset"><a href="#PyTorch-Dataset" class="headerlink" title="PyTorch Dataset:"></a>PyTorch Dataset:</h3><p>Suppose we want to see the labels for each image. This can be done like so:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Starting with torchvision 0.2.2</span></span><br><span class="line">&gt; train_set.targets</span><br><span class="line">tensor([<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, ..., <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure><p>If we want to see how many of each label exists in the dataset, we can use the PyTorch <code>bincount()</code> function like so:</p><h4 id="Class-Imbalance-Balanced-And-Unbalanced-Datasets"><a href="#Class-Imbalance-Balanced-And-Unbalanced-Datasets" class="headerlink" title="Class Imbalance: Balanced And Unbalanced Datasets"></a>Class Imbalance: Balanced And Unbalanced Datasets</h4><p>This shows us that the Fashion-MNIST dataset is uniform with respect to the number of samples in each class. This means we have <code>6000</code> samples for each class. As a result, this dataset is said to be balanced. If the classes had a varying number of samples, we would call the set an unbalanced dataset.</p><p>【Fashion-MNIST数据集是均匀分布，即每个class的samples数量相同。均匀分布的数据集被称为是balanced。】</p><p>To read more about the ways to mitigate unbalanced datasets in deep learning, see this paper: <a href="https://arxiv.org/abs/1710.05381">A systematic study of the class imbalance problem in convolutional neural networks.</a> </p><h4 id="Accessing-Data-In-The-Training-Set"><a href="#Accessing-Data-In-The-Training-Set" class="headerlink" title="Accessing Data In The Training Set"></a>Accessing Data In The Training Set</h4><p>【获得数据集中的数据：先将<code>train_set</code> 传递给Python函数<code>iter()</code> 生成迭代器，再将迭代器传递给内置函数<code>next</code> 用来迭代】</p><blockquote><p><code>iter(object)</code> ：</p><ul><li>object：支持迭代的集合对象</li><li>返回值：迭代器对象</li></ul><p><code>next(iterable[, default])</code> :</p><ul><li>常和<code>iter()</code> 一同使用</li><li>返回迭代器中的下一个项目</li></ul></blockquote><p>To access an individual element from the training set, we first pass the <code>train_set</code> object to Python’s <code>iter()</code> built-in function, which returns an object representing a stream of data.</p><p>With the stream of data, we can use Python built-in <code>next()</code> function to get the next data element in the stream of data. </p><p>After passing the sample to the <code>len()</code> function, we can see that the sample contains two items, and this is because the dataset contains image-label pairs. Each sample we retrieve from the training set contains the image data as a tensor and the corresponding label as a tensor.</p><p>【train_set中的sample是一个image-label对，因此sample的len为2】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image,label = sample</span><br><span class="line">print(type(image))</span><br><span class="line">print(type(label))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">torch</span>.<span class="title">Tensor</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">int</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Working-With-Batches-Of-Data"><a href="#Working-With-Batches-Of-Data" class="headerlink" title="Working With Batches Of Data"></a>Working With Batches Of Data</h2><p>We’ll start by creating a new data loader with a smaller batch size of <code>10</code> so it’s easy to demonstrate what’s going on:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">display_loader = torch.utils.data.DataLoader(</span><br><span class="line">    train_set, batch_size=<span class="number">10</span></span><br><span class="line">)</span><br><span class="line">batch = next(iter(display_loader))</span><br><span class="line">len(batch)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>We get a batch from the loader in the same way that we saw with the training set. We use the <code>iter()</code> and <code>next()</code> functions.</p><p>【相较于使用training set，从DataLoader中可以取出a batch of data】</p><p>Checking the length of the returned batch, we get <code>2</code> just like we did with the training set. Let’s unpack the batch and take a look at the two tensors and their shapes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">images, labels = batch</span><br><span class="line">print(<span class="string">'types:'</span>, type(images), type(labels))</span><br><span class="line">print(<span class="string">'shapes:'</span>, images.shape, labels.shape)</span><br><span class="line">types: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">torch</span>.<span class="title">Tensor</span>'&gt; &lt;<span class="title">class</span> '<span class="title">torch</span>.<span class="title">Tensor</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">shapes</span>:</span> torch.Size([<span class="number">10</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>]) torch.Size([<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>The size of each dimension in the tensor that contains the image data is defined by each of the following values:</p><p>(batch size, number of color channels, image height, image width)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grid = torchvision.utils.make_grid(images, nrow=<span class="number">10</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>, <span class="number">15</span>))</span><br><span class="line">plt.imshow(np.transpose(grid, (<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)))</span><br><span class="line">//</span><br><span class="line">grid = torchvision.utils.make_grid(images, nrow=<span class="number">10</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">15</span>))</span><br><span class="line">plt.imshow(grid.permute(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><blockquote><p> plt.imshow(X) : X=(M,N,3) RGB2D图</p><p>而grid返回的应该是（C-H-W），所以要置换一下axes。置换使用np.transpose(grid, (1,2,0))或grid.permute(1,2,0)</p></blockquote><h2 id="Plot-Images-Using-PyTorch-DataLoader"><a href="#Plot-Images-Using-PyTorch-DataLoader" class="headerlink" title="Plot Images Using PyTorch DataLoader"></a>Plot Images Using PyTorch DataLoader</h2><p>Here is another was to plot the images using the PyTorch DataLoader.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PyTorch框架学习。&lt;/p&gt;
&lt;p&gt;这篇文章介绍了深度学习中的数据和数据处理的常用类DataSet和DataLoader。&lt;/p&gt;
&lt;p&gt;colab笔记：&lt;a href=&quot;https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Data%20And%20Data%20Processing.ipynb&quot;&gt;Data And Data Processing&lt;/a&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://f7ed.com/categories/PyTorch/"/>
    
    
      <category term="open-classes" scheme="https://f7ed.com/tags/open-classes/"/>
    
      <category term="DEEPLIZARD" scheme="https://f7ed.com/tags/DEEPLIZARD/"/>
    
      <category term="PyTorch" scheme="https://f7ed.com/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>「Math」:Entropy, Cross-Entropy and DL-Divergence</title>
    <link href="https://f7ed.com/2021/01/16/entropy-and-more/"/>
    <id>https://f7ed.com/2021/01/16/entropy-and-more/</id>
    <published>2021-01-15T16:00:00.000Z</published>
    <updated>2021-01-16T07:13:27.910Z</updated>
    
    <content type="html"><![CDATA[<p>在机器学习中，常用cross-entropy来作为模型的损失函数，这篇文章将阐述信息学中的entropy（熵）是什么，cross-entropy（交叉熵）又是什么，KL-Divergence和entropy、cross-entropy的关系是什么？</p><p>如何具象的理解这些概念？</p><p>在开始阅读这篇文章之前，先提及一下香农对bit的定义，香农认为bit是用来消除信息的不确定性的。</p><p>bit：uncertainty divided by 2.</p><p><a href="https://www.youtube.com/watch?v=ErfnhcEV1O8">原视频</a> 讲的很好，本文只是在此基础上对一些总结，方便理解物质化（马原.jpg）。</p><a id="more"></a><h1 id="公式总概"><a href="#公式总概" class="headerlink" title="公式总概"></a>公式总概</h1><p>bit：用来消除信息的不确定性</p><p>Entropy（熵）： $H(p)=-\sum_i p_i\log(p_i)$ </p><p>度量概率分布的平均信息量（即不确定性）。值越大，不确定性越大。</p><p>Cross-Entropy（交叉熵）： $H(p,q)=-\sum_i p_i\log(q_i)$ </p><p>度量两个分布的相似程度（一般 $p$ 为真实分布，$q$为预测分布），值越大，两个分布越不相似。</p><p>KL-Divergence（KL散度，也叫相对熵） ：$D_{KL}(p|q)=H(p,q)-H(q)$ </p><p>度量交叉熵超过熵的那一部分。</p><h1 id="Entropy-熵"><a href="#Entropy-熵" class="headerlink" title="Entropy-熵"></a>Entropy-熵</h1><p><strong>实例1：</strong></p><p>sunny和rainy的发生的概率都是0.5，天气预报预测明天的天气为sunny，将sunny消息发给用户。</p><p>该条消息不管多长，有用的信息其实只有1个比特，即uncertainty divided by 2.</p><p><strong>实例2：</strong></p><p>有八种不同的天气，发生的概率相同，当天气预报将预测消息发送给用户时。</p><p>该条消息能使得uncertainty divided By 8.即有用信息为3个比特。</p><p><strong>实例3:</strong></p><p>sunny发生的概率为0.75，rainy的概率为0.25，如果天气预测明天的天气：</p><blockquote><p>将这个例子理解为抽球游戏，盒子里有3个红球（表示sunny天气），1个白球（rainy天气）。</p><p>事件 $X$ 表示为在盒子里抽中球的颜色，可得知抽中红球的概率为0.75，抽中白球的概率是0.25。</p><p>抽中哪个球是不确定的，即uncertainty 如果原来是4，即不知道将抽中这四个球中的哪一个。</p><ul><li><p>如果抽中白球，那该信息表示：就是那4个球中的唯一一个白球，uncertainty 从原来的4变为1，即 uncertainty divided by 4.表示该信息，需要有用比特， $\log_2(4)=\log_2(1/0.25)=2$ 个比特来表示。即抽打白球的情况的不确定性更大，需要更多的比特来消除不确定性，来表示白球的发生。所以该条信息中只有2个比特是useful information.</p></li><li><p>如果抽中红球，该信息表示为：是那3个红球中的一个，uncertainty 从原来的4变为3</p><p>（如果和抽中白球的情况统一，最后的确定发生的uncertainty都表示为1，即在没有抽之前，抽到红球的uncertainty为 $1/0.75=4/3$ ）</p><p>即uncertainty divided by 4/3.表示该信息需要有用 $\log_2(4/3)=\log_2(1/0.75)=-\log_2(0.75)=0.41$ 比特来表示。即抽到红球的情况不确定性没有那么大，只需要较少比特即可消除不确定性，来表示红球的发生。所以该条信息中只有0.41个比特是useful information.</p></li></ul><p>这里也可以看出，如果一个事件的发生的概率越小（越不可能发生），即对该事件发生的不确定性越大，但一旦发生了，所携带的信息量就会很大，因为需要用更多的比特来消除不确定性。</p></blockquote><p>回到本例子：</p><ul><li><p>如果预测天气为rainy，将预测消息发给用户，则该条消息包含2比特（$\log_2(1/0.25)=-\log_2(0.25)=2$）的有用信息，即对rainy天气发送的不确定性更大，需要更多的比特来消除不确定性。</p></li><li><p>如果预测天气为sunny，因为在预测之前，用户对sunny发生的可能性就没有那么大，因此只需要0.41比特（$\log_2(1/0.75)=-\log_2(0.75)$)来消除不确定性。</p></li></ul><p>那平均下来，气象局发送的平均信息量为 $0.75\times 0.41+0.25\times2=0.81$ bits.</p><hr><p>因此我们用 $\log_2(1/p)=-\log_2p$ 来表示事件发生时所携带的信息量。（或者说需要这么多信息量来消除事件发生的不确定性）</p><p>用 $-\sum_i{p_i}\log_2{p_i}$ 来表示该事件的平均信息量（概率分布的不确定性），这就是信息熵（Entropy）。</p><p>Entropy：<br>$$<br>H(p)=-\sum_i pi\log_2(p_i)<br>$$<br>熵越大，说明携带的平均信息量越多，即不确定性越强，需要越多的比特来消除不确定性。所以熵是用来衡量不确定性的量。</p><blockquote><p>和化学中衡量混乱程度的熵，是类似的。</p></blockquote><h1 id="Cross-Entropy-交叉熵"><a href="#Cross-Entropy-交叉熵" class="headerlink" title="Cross-Entropy-交叉熵"></a>Cross-Entropy-交叉熵</h1><p><strong>例1：</strong></p><p>从上面的实例2来看，即8中天气发生概率相同，对天气表示进行信息编码，为下图：</p><img src="https://s3.ax1x.com/2021/01/16/sDloKf.png" alt="例1" style="zoom:33%;" /><p>entropy为3bits，而cross-entropy（交叉熵），也就是消息（比特流）的平均长度，为3bits.</p><p><strong>例2：</strong></p><p>但如果8种天气发生的可能性为下图：</p><img src="https://s3.ax1x.com/2021/01/16/sDl5xP.png" alt="例2" style="zoom:33%;" /><p>算出来的entropy为2.23bits，即平均信息量为2.23bits。</p><p>如果仍是用这样的编码，cross-entropy为3bits，就多出一些冗余信息量。</p><p><strong>例3:</strong></p><p>如果换一种编码方式：</p><img src="https://s3.ax1x.com/2021/01/16/sD12LT.png" alt="例3" style="zoom:33%;" /><p>算出来的cross-entropy为 $0.35 \times2+0.35\times2+0.1\times3+…+0.01\times5=2.42$ bits，就非常接近entropy=2.23bits。</p><p>说明这种编码方式冗余量很小，非常接近真实的概率分布所包含的平均信息。</p><p><strong>例4:</strong></p><p>如果天气的概率分布变为下图，entropy不变仍然为2.23bits：</p><img src="https://s3.ax1x.com/2021/01/16/sDl42t.png" alt="例4" style="zoom:33%;" /><p>那么算出来的cross-entropy为 $0.01\times2+0.01\times 2+0.04\times3+…+0.35\times5=4.58$ bits，远大于entropy的值。说明这种编码方式冗余量很大。</p><hr><p>换一种角度看例4，把信息编码认为是预测的概率分布，例4点编码表示的分布如下：</p><img src="https://s3.ax1x.com/2021/01/16/sD1rJs.png" alt="cross-entropy" style="zoom:33%;" /><p>Cross-Entropy：<br>$$<br>H(p,q)=-\sum_i p_i\log(q_i)<br>$$<br>所以cross-entropy可以理解为<strong>信息/比特流的平均长度。</strong></p><p>如果预测的概率分布非常接近真实的概率分布，那比特流的平均长度也会非常接近原分布的平均信息量。</p><p>如果预测的概率分布 $q$ 和真实分布 $p$ 完全一样，那么cross-entropy等于entropy。</p><p>所以cross-entropy可以用来衡量两个概率分布的相似程度。</p><p>用在机器学习中用作评判模型好坏的损失函数，度量模型预测分布和真实分布的相似程度。</p><h1 id="KL-Divergence-KL散度"><a href="#KL-Divergence-KL散度" class="headerlink" title="KL-Divergence-KL散度"></a>KL-Divergence-KL散度</h1><p>而如果预测的概率分布和真实分布不同，那么cross-entropy的值就会大于entropy的值，超过的部分就叫做relative entropy（相对熵），也就是KL-Divergence（Kullback-Leibler Divergence，KL散度）</p><p>即可以得到等式：$\text{Cross-Entropy = Entropy+KL-Divergence}$ </p><p>则KL-Divergence：<br>$$<br>\begin{align}<br>D_{KL}(p|q)=H(p,q)-H(p) &amp;= -\sum_i p_i\ln q_i - \sum_i p_i\ln p_i  \<br>&amp;= -\sum_i p_i \ln \frac{p_i}{q_i} \<br>&amp;= \sum_i p_i \ln \frac{q_i}{p_i}<br>\end{align}<br>$$</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>视频链接：<a href="https://www.youtube.com/watch?v=ErfnhcEV1O8">https://www.youtube.com/watch?v=ErfnhcEV1O8</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在机器学习中，常用cross-entropy来作为模型的损失函数，这篇文章将阐述信息学中的entropy（熵）是什么，cross-entropy（交叉熵）又是什么，KL-Divergence和entropy、cross-entropy的关系是什么？&lt;/p&gt;
&lt;p&gt;如何具象的理解这些概念？&lt;/p&gt;
&lt;p&gt;在开始阅读这篇文章之前，先提及一下香农对bit的定义，香农认为bit是用来消除信息的不确定性的。&lt;/p&gt;
&lt;p&gt;bit：uncertainty divided by 2.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ErfnhcEV1O8&quot;&gt;原视频&lt;/a&gt; 讲的很好，本文只是在此基础上对一些总结，方便理解物质化（马原.jpg）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Information-Theory" scheme="https://f7ed.com/categories/Information-Theory/"/>
    
    
      <category term="Math" scheme="https://f7ed.com/tags/Math/"/>
    
      <category term="Information-Theory" scheme="https://f7ed.com/tags/Information-Theory/"/>
    
  </entry>
  
  <entry>
    <title>「政治」:毛中特</title>
    <link href="https://f7ed.com/2021/01/16/Marxism-in-China/"/>
    <id>https://f7ed.com/2021/01/16/Marxism-in-China/</id>
    <published>2021-01-15T16:00:00.000Z</published>
    <updated>2021-01-16T08:34:18.588Z</updated>
    
    <content type="html"><![CDATA[<p>这学期马原毛概并举，政治知识储备达到巅峰qwq</p><p>看着徐涛老师的政治课复习，做了些许笔记，做个总结分享出来。</p><p>社会主义好，共产主义好！</p><p>八个明确，十四个坚持背的溜溜的orz</p><p>不过，对于毛中特的期末考试来说，这个一定要多听听老师勾的重点！！</p><a id="more"></a><h1 id="马克思主义中国化"><a href="#马克思主义中国化" class="headerlink" title="马克思主义中国化"></a>马克思主义中国化</h1><h3 id="1-马克思主义中国化的内涵"><a href="#1-马克思主义中国化的内涵" class="headerlink" title="1.马克思主义中国化的内涵"></a>1.马克思主义中国化的内涵</h3><ul><li>什么是马克思主义中国化<ol><li>（中国需要：理论指导实践）马克思主义基本理论同中国具体实际和时代特征结合起来，运用马克思主义的立场、观点、方法研究和解决中国革命、建设、改革中的实际问题；</li><li>（理论需要：发展马原理论）就是总结和提炼中国革命、建设、改革的实践经验，从而认识和掌握客观规律，为马克思主义理论宝库添增新的内容；</li><li>（相融性：中国传统文化和理论结果）就是运用中国人民喜闻乐见的民族语言来阐述马克思主义理论，使之成为具有中国特色、中国风格、中国气派的马克思主义。</li></ol></li></ul><blockquote><p>研究一个理论：</p><p>理论的内涵；</p><p>理论的必要性；（为什么要这么做）</p><p>理论的可能性；（有没有实践成功的可能）</p></blockquote><ul><li>必要性：<ol><li>中国需要科学的理论指导革命、建设。</li><li>马克思理论需要和实践结合发展运用。</li></ol></li><li>可能性：<ol><li>中国需要</li><li>理论需要发展</li><li>相融性：中国特色传统文化和马克思主义理论可以相融。</li></ol></li></ul><h3 id="2-马克思主义中国化的历史过程"><a href="#2-马克思主义中国化的历史过程" class="headerlink" title="2.马克思主义中国化的历史过程"></a>2.马克思主义中国化的历史过程</h3><p><em>马克思主义中国化实现了两次历史飞跃</em> </p><ul><li><p>两次飞跃</p><ol><li>第一次历史飞跃发生在新民主主义革命时期，形成了毛泽东思想。</li><li>第二次历史飞跃发生在社会主义进入改革开放的新时期，形成了包括邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想在内的中国特色社会主义理论体系。（邓三科习）</li></ol></li><li><p>毛泽东思想。</p><ol><li>（提出命题）1838年，毛泽东在党的六届六中全会上作的题为《论新阶段》政治报告中，最先提出了“马克思主义中国化”的命题。</li><li>（全党共识）延安整风运动，推进马克思主义中国化，更好地指导中国革命，成为全党共识。</li><li>（写入党章）刘少奇在党的七大上作的关于修改党章的报告中，对“马克思主义中国化”从理论上作了进一步的阐述，指出毛泽东思想是“中国化的马克思主义”。党的七大正式将毛泽东思想确立为党的指导思想并写入党章。</li></ol></li><li><p>中国特色社会主义理论体系</p><p>中国特色社会主义理论体系包括邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想在内的中国特色社会主义理论体系。（邓三科习）</p></li></ul><h1 id="毛泽东思想"><a href="#毛泽东思想" class="headerlink" title="毛泽东思想"></a>毛泽东思想</h1><h2 id="毛泽东思想的形成与发展"><a href="#毛泽东思想的形成与发展" class="headerlink" title="毛泽东思想的形成与发展"></a>毛泽东思想的形成与发展</h2><h3 id="3-毛泽东思想形成发展的历史条件"><a href="#3-毛泽东思想形成发展的历史条件" class="headerlink" title="3.毛泽东思想形成发展的历史条件"></a>3.毛泽东思想形成发展的历史条件</h3><ul><li><p>时代背景：19世纪末20年代初，世界进入帝国主义和无产阶级革命时代。</p><blockquote><p>时代背景：革命与战争</p></blockquote><p><em>1917年俄国十月革命的胜利开辟世界无产阶级社会主义革命的新时代。它使中国反帝反封建的民主革命从旧的世界资产阶级民主革命的一部分，转变为新的世界无产阶级社会主义革命的一部分。</em> </p><blockquote><p>民主革命从世界资产阶级民主革命的一部分变成世界无产阶级革命的一部分。</p></blockquote></li><li><p>实践基础：中国共产党领导人民进行革命和建设的成功实践。</p><blockquote><p>一个理论的出现，是有实践支撑的。</p><p>毛泽东思想的实践基础关于革命和建设实践。</p><p>而中特只有建设。</p></blockquote><p><em>中国共产党成立之后，为人民谋幸福，为中华民族谋复兴，经历了千辛万苦的奋斗历程，有成功的宝贵经验，也有失败的惨痛教训。这些经验教训促使毛泽东为主要代表的中国共产党人更深入地思考中国革命和建设的问题。毛泽东思想正是对这些经验教训进行深刻总结形成的理论成果</em> </p></li></ul><h3 id="4-毛泽东思想形成发展的过程"><a href="#4-毛泽东思想形成发展的过程" class="headerlink" title="4.毛泽东思想形成发展的过程"></a>4.毛泽东思想形成发展的过程</h3><p><em>毛泽东思想是在我国新民主主义革命、社会主义革命和社会主义建设的实践过程中，在总结我国革命和建设正反两方面历史经验的基础上，逐步形成和发展的</em> </p><blockquote><p>新民主主义：1919五四运动-1949新中国成立</p><p>社会主义革命：1949-1956年</p><p>社会主义建设：1956以后</p></blockquote><ol><li><p>第一次国内革命战争时期（大革命）：提出思想</p><ul><li><p>1924-1927</p></li><li><p>《中国社会各阶级分析》《湖南农民运动考察报告》：分析了中国社会各阶级在革命中的地位和作用，<strong>提出了新民主主义革命的基本思想。</strong></p><blockquote><p>以马克思列宁主义为指导思想，和中国实际相结合</p></blockquote></li></ul></li><li><p>土地革命时期：<strong>初步形成</strong></p><ul><li>1927-1937，土地革命初期</li><li>《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》：提出并阐述了农村包围城市、武装夺取政权的思想，标志着毛泽东思想的初步形成。</li><li>毛泽东思想初步形成的标志：提出农村包围城市、武装夺取政权的思想。</li></ul></li><li><p>遵义会议至抗日战争时期：<strong>趋于成熟</strong> </p><ul><li><p>1935-1945</p></li><li><p>《实践论》《矛盾论》：运用马克思主义的认识论和辩证法，系统分析了党内“左”的和右的错误的思想渊源。</p><blockquote><p>”左“的错误：偏离实际的社会主义</p><p>右的错误：偏向资本主义</p></blockquote></li><li><p>《论持久战》</p></li><li><p>《〈共产党人〉发刊词》《中国革命和中国共产党》《新民主主义》：科学阐述新民主主义革命的对象、动力、领导力量、性质和前途等基本问题，提出了新民主主义革命的总路线，制定了新民主主义的具体目标。</p></li><li><p>毛泽东思想<strong>趋于成熟的标</strong>志：新民主主义的系统阐述。</p><p><em>新民主主义革命的系统阐述，实现了马克思主义与中国革命实践相结合的历史性飞跃，标志着毛泽东思想得到多方面展开而趋于成熟。</em></p></li></ul></li></ol><ol start="4"><li><p>党的七大：<strong>正式确立</strong></p><ul><li>1945年党的七大：将毛泽东思想写入党章，确定为党必须长期坚持的指导思想。</li><li>《论联合政府》</li></ul></li><li><p>解放战争时期和中国人民共和国成立后：继续发展</p><ul><li>1946-1949后</li><li>《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》《论十大关系》《关于正确处理人民内部矛盾的问题》《在晋绥(sui)干部上的讲话》</li></ul></li></ol><h3 id="5-毛泽东思想的主要内容"><a href="#5-毛泽东思想的主要内容" class="headerlink" title="5.毛泽东思想的主要内容"></a>5.<em>毛泽东思想的主要内容</em></h3><ol><li>新民主主义革命理论 </li><li>社会主义革命和社会主义建设理论 </li><li>革命军队建设和军事战略理论 </li><li>政策和策略的理论 </li><li>思想政治工作和文化工作的理论 </li><li>党的建设理论</li></ol><h3 id="6-毛泽东思想活的灵魂"><a href="#6-毛泽东思想活的灵魂" class="headerlink" title="6.毛泽东思想活的灵魂"></a>6.毛泽东思想活的灵魂</h3><ul><li><p>提出时间：1981年<strong>党的十一届六中全会</strong>通过《中国共产党中央委员会关于建国以来党的若干历史问题的决议》（<strong>《历史决议》</strong>）指出。</p><p><em>1981年党的十一届六中全会通过《中国共产党中央委员会关于建国以来党的若干历史问题的决议》（《历史决议》）指出：贯穿毛泽东思想各个组成部分的立场、观点和方法，是毛泽东思想的活的灵魂，他们有三个基本方面，即实事求是，群众路线，独立自主</em> </p></li><li><p>毛泽东思想活的灵魂：实事求是、群众路线、独立自主</p><ol><li><p>实事求是：一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。</p><ul><li>党的根本思想路线：实事求是</li></ul></li><li><p>群众路线：一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。</p><p><em>群众路线都是我们党的生命线和根本工作路线，是我们党永葆青春活力和战斗力的重要传家宝</em> </p><ul><li><p>党的根本工作路线：群众路线</p></li><li><p>党的生命线：群众路线</p></li><li><p>党的根本宗旨：全意全意为人民服务，即群众路线</p></li><li><p>党的根本出发点和落脚点：群众路线</p></li><li><p>党区别于其他一切政党的根本标志：群众路线</p><blockquote><p>党区别于其他一切政党的显著标志：优良作风</p></blockquote></li></ul></li><li><p>独立自主：坚持中国的事情必须由中国人民自己处理</p><p><em>坚持独立思考，走自己的路，坚定不移的维护民族独立、捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物</em> </p><ul><li>党的根本政治原则：独立自主</li></ul></li></ol></li></ul><h3 id="7-毛泽东思想的重要意义"><a href="#7-毛泽东思想的重要意义" class="headerlink" title="7.毛泽东思想的重要意义"></a>7.毛泽东思想的重要意义</h3><ol><li>马克思主义中国化的第一个重大理论成果。</li><li>中国革命和建设的科学指南。</li><li>中国共产党和中国人民宝贵的精神财富。</li></ol><ul><li>科学评价毛泽东和毛泽东思想：<ul><li>毛泽东一生为党和人民的事业作出了杰出贡献，《历史决议》对毛泽东和毛泽东思想的历史地位作出了科学的、实事求是的评价，对于统一全党的认识起到了重要作用，得到了全党的拥护。</li><li>毛泽东的功绩是第一位的，错误是第二位的。他的错误是一个伟大的革命家、一个伟大的马克思主义者所犯的错误。</li></ul></li></ul><h2 id="新民主主义革命理论"><a href="#新民主主义革命理论" class="headerlink" title="新民主主义革命理论"></a>新民主主义革命理论</h2><p>毛泽东思想分为三个部分：</p><ul><li>革命：新民主主义革命理论（1919-1949）</li><li>改造：社会主义改造理论（1949-1956）</li><li>建设：社会主义建设初步探索（1956-1976）</li></ul><h2 id="新民主主义革命"><a href="#新民主主义革命" class="headerlink" title="新民主主义革命"></a>新民主主义革命</h2><h3 id="8-近代中国国情和中国革命的时代特征"><a href="#8-近代中国国情和中国革命的时代特征" class="headerlink" title="8.近代中国国情和中国革命的时代特征"></a>8.近代中国国情和中国革命的时代特征</h3><h4 id="近代中国国情"><a href="#近代中国国情" class="headerlink" title="近代中国国情"></a>近代中国国情</h4><ul><li><p>近代中国的<strong>国情</strong>：近代中国已经沦为一个半殖民地半封建社会性质的社会。（或者说是经济发展极不平衡）</p><blockquote><p>毛泽东指出：“认清中国的国情，乃是认清一切革命问题的基本依据。</p></blockquote></li><li><p>主要矛盾：帝国主义和中华民族的矛盾、封建主义和人民大众的矛盾。</p><ul><li>最重要的矛盾：帝国主义和中华民族的矛盾。</li></ul><p><em>在诸多社会矛盾中，占支配地位的主要矛盾是帝国主义和中华民族的矛盾、封建主义和人民大众的矛盾，而帝国主义和中华民族的矛盾，又是各种矛盾中最主要的矛盾</em> </p></li><li><p>根本任务：（反帝反封反官资/反帝反封）推翻帝国主义、封建主义和官僚资本主义的统治。</p><blockquote><p>官僚资本主义，即官僚买办资本主义，和帝国主义封建主义勾结的资本主义。</p></blockquote></li></ul><h4 id="中国革命的时代特征"><a href="#中国革命的时代特征" class="headerlink" title="中国革命的时代特征"></a>中国革命的时代特征</h4><ul><li><p>革命性质：资产阶级民主革命</p><blockquote><p>革命的对象决定了革命的性质，革命对象都是帝国主义和封建主义，因此都是资产阶级民主革命</p></blockquote><ul><li><p>旧民主主义革命：资产阶级领导的资产阶级民主革命</p></li><li><p>新民主主义革命：无产阶级领导的资产阶级民主革命</p><blockquote><p>俄国革命，使得中国的资产阶级民主革命，从属于旧的世界资产阶级民主革命的一部分，转变为属于新的世界资产阶级民主革命的一部分，属于世界无产阶级社会主义革命的一部分。</p></blockquote></li><li><p>爆发标志：1919五四运动，中国资产阶级民主革命进入新民主主义革命。</p><p><em>十月革命影响下，1919年五四运动之后，中国无产阶级开始以独立的政治力量登上历史舞台，由自在阶级变为自为阶级。</em> </p><blockquote><p>自为阶级：意识到压迫。</p></blockquote></li></ul></li><li><p>中国革命要分两步走</p><ol><li>第一步：完成反帝反封建的新民主主义革命任务</li><li>第二步：完成社会主义革命的任务</li></ol></li></ul><h3 id="9-新民主主义革命理论的实践基础"><a href="#9-新民主主义革命理论的实践基础" class="headerlink" title="9.新民主主义革命理论的实践基础"></a>9.新民主主义革命理论的实践基础</h3><blockquote><p>新民主主义革命理论不是凭空出现的，旧的革命失败了，新的实践需要新的理论指导。</p></blockquote><ul><li>实践基础<ol><li>旧民主主义革命 失败呼唤新的革命理论</li><li>新民主主义革命的艰辛探索 奠定了革命理论形成的实践基础。</li></ol></li></ul><h2 id="新民主主义革命理论的内容"><a href="#新民主主义革命理论的内容" class="headerlink" title="新民主主义革命理论的内容"></a>新民主主义革命理论的内容</h2><p>新民主主义革命理论：</p><ol><li>总路线</li><li>总纲领</li><li>总道路</li><li>总经验（三大法宝）</li></ol><h3 id="10-新民主主义革命的总路线"><a href="#10-新民主主义革命的总路线" class="headerlink" title="10.新民主主义革命的总路线"></a>10.新民主主义革命的总路线</h3><blockquote><p>学习一个理论时，先知道是从哪来的，那个会议提出的，再说内容。</p></blockquote><ul><li><p>哪来的</p><ol><li><p>1939年，毛泽东在《中国革命和中国共产党》——第一次提出：”新民主主义革命“的科学概念。</p></li><li><p>1848年，毛泽东在《在晋绥干部上的讲话》——完整表述了总路线的内容</p><ul><li>总路线内容：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命。</li><li>总路线指出了中国革命的对象、动力、领导力量</li><li>总路线是新民主主义革命的指导路线</li></ul></li></ol></li><li><p>总路线：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命。</p></li><li><p>中国革命的问题</p><ul><li>中国革命的首要问题：分清敌友</li><li>中国革命的重要问题：农民问题</li><li>中国革命的中心问题：无产阶级的领导权</li></ul></li></ul><ol><li><p>新民主主义革命的对象</p><p><em>分清敌友，这是革命的首要问题</em> </p><ul><li><p>中国革命的主要敌人：帝国主义、封建主义和官僚资本主义</p><ul><li>首要对象：帝国主义</li><li>又一主要对象：封建主义</li><li>对象之一：官僚资本主义</li></ul></li><li><p>不同时期的不同革命对象：总体上是帝国主义、封建主义和官僚资本主义</p><p><em>不同的历史阶段，随着社会主要矛盾的变化，革命的主要对象不同</em> </p><ul><li>国共合作的大革命时期（1924-1927）：帝国主义支持下的北洋军阀</li><li>土地革命战争时期（1927-1937）：国民党新军阀</li><li>抗日战争时期（1935-1945）：日本帝国主义</li><li>解放战争时期（1946-1949）：美帝国主义支持下的国民党反动派</li></ul></li></ul></li><li><p>新民主主义革命的动力</p><ul><li><p>新民主主义革命的动力：（工农小资民资）无产阶级、农民阶级、城市小资产阶级和民族资产阶级。</p><blockquote><p>在新民主主义革命时期，主要是反帝反封，同时反对勾结帝国主义和封建主义的资本阶级，即官僚资本阶级，但团结不勾结的民族资本阶级。因此是民主资产阶级是动力而不是对象。</p><p>无产阶级，又，工人阶级。</p></blockquote><ul><li><p>中国革命最基本的动力：无产阶级</p></li><li><p>中国革命的主力军：农民</p><p><em>农民问题是中国革命的基本问题，新民主主义革命的实质是党领导下的农民革命，中国革命战争的实质是党领导下的农民战争</em> </p><ul><li>无产阶级最可靠的同盟军：贫雇农</li><li>无产阶级可靠的同盟军：中农</li></ul></li><li><p>无产阶级的可靠同盟者：城市小资产阶级</p></li><li><p>中国革命动力之一：民主资产阶级</p><p><em>具有两面性，革命性和妥协性（摇摆性和软弱性）</em> </p><blockquote><p>一方面收到压迫，具有革命性。一方面经济上和帝国主义封建主义有联系，具有妥协性。</p></blockquote></li></ul></li></ul></li><li><p>新民主主义革命的领导力量</p><p><em>无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题</em> </p><p><em>区分新旧两种不同范畴的民主主义革命的根本标志是，革命的领导权是掌握在无产阶级手中还是资产阶级手中</em> </p><blockquote><p>新民主主义和旧民主主义的革命性质，革命对象，革命任务都相同，因此，区分靠领导者。</p></blockquote><ul><li><p>领导力量：无产阶级</p><p><em>无产阶级及其政党——中国共产党的领导，是中国革命取得胜利的根本保证</em> </p><ul><li>中国革命取得胜利的根本保证：无产阶级的领导——中国共产党的领导。</li></ul></li><li><p>无产阶级的特点和优点：</p><ul><li>一般无产阶级的基本优点（共性）<ol><li>具有先进的生产方式</li><li>没有私人占有的生产资料</li><li>富于组织纪律性</li></ol></li><li>自身的特点和优点（中国共产党特有的）<ol><li>（很惨）从诞生起，就受到外国资本主义、本国封建势力和资产阶级的三重压迫，因此中国无产阶级革命在革命斗争中比任何阶级都来的坚决和彻底。</li><li>（利于团结）分布集中，利于无产阶级队伍的组织和团结</li><li>（和农民亲近）成员大部分处于破产农民，和农民有天然的联系，便于和农民结成亲密的联盟</li></ol></li></ul></li><li><p>无产阶级领导权的实现：与资产阶级争夺领导权的斗争中实现的</p><p><em>无产阶级及其政党对中国革命的领导权不是自然而然得来的，而是在与资产阶级争夺领导权的斗争中实现的</em>  </p><ul><li><p>实现领导权的条件：率领同盟者斗争并取得胜利；给被领导者以物质福利，并进行政治教育</p></li><li><p>实现领导权的关键：建立以工农联盟为基础的广泛统一战线</p></li><li><p>实现领导权的基本策略：保持党在思想上、政治上和组织上的独立性</p></li><li><p>实现领导权的坚强支柱：革命武装力量</p></li><li><p>实现领导权的根本保证：党的建设</p><blockquote><p>中国革命取得胜利的根本保证：无产阶级及其政党——中国共产党的领导</p></blockquote></li></ul></li></ul></li><li><p>新民主主义革命的性质和前途</p><ul><li><p>中国革命的性质：资产阶级民主革命</p><p><em>近代中国半殖民地半封建社会的性质和中国革命的历史任务，决定了中国革命的性质不是无产阶级社会主义革命，而是资产阶级民主主义革命。</em> </p><blockquote><p>1949年以前，都是资产阶级民主主义革命</p></blockquote></li><li><p>新民主主义革命v.s.旧民主主义革命</p><ol><li>（所属）中国新民主主义革命处于社会无产阶级社会主义的时代，是世界无产阶级社会主义革命的一部分。</li><li>（领导力量）革命的领导力量是中国无产阶级及其先锋队——中国共产党。</li><li>（指导思想）革命的指导思想是马克思列宁主义</li><li>（前途）革命的前途是社会主义而不是资本主义</li></ol></li><li><p>新民主主义革命v.s 社会主义革命 区别：</p><table><thead><tr><th>区别</th><th>性质</th><th>对待资本主义</th><th>前途/目的</th></tr></thead><tbody><tr><td>新民主主义革命</td><td>资产阶级民主主义革命</td><td>没收官僚资本，打倒官僚资本阶级；争取和联合民族资产阶级，保护民族工商业。</td><td>各革命阶级联合专政</td></tr><tr><td>社会主义革命</td><td>无产阶级社会主义革命</td><td>消灭资本主义剥削制度；改造小生产的私有制</td><td>无产阶级专政</td></tr></tbody></table><blockquote><p>社会主义革命：1949-1956</p></blockquote></li><li><p>联系——中国革命分两步走：</p><p><em>新民主革命与社会主义革命是互相联系、紧密衔接的，中间不容横插一个资产阶级专政。毛泽东把新民主主义革命和社会主义革命比喻为文章的上篇和下篇。</em> </p><ul><li>第一步：完成反帝反封建的新民主主义革命任务，是社会主义革命的<strong>必要准备</strong>。</li><li>第二步：完成社会主义革命的任务，是民主主义革命的<strong>必然趋势</strong>。</li></ul><p><em>“民主主义革命是社会主义革命的必要准备，社会主义革命是民主主义革命的必然趋势。”只有认清新民主主义革命和社会主义革命的区别，又认清两者的联系，才能正确领导中国革命</em> </p></li><li><p>“左”倾和右倾两种错误思想：</p><ul><li>“左”倾教条主义的“一次革命论“：（只看联系，忽视区别）只看到民主革命和社会主义的联系，混淆了民主革命和社会主义革命的区别。</li><li>右倾的“两次革命论”：（只看区别，忽视联系）只看到了民主革命和社会主义的区别，而没有看到两个革命阶段的联系。（认为民主主义革命后，应该插入一个资产阶级专政，再实现社会主义，右倾。</li></ul><blockquote><p>正确的说法：中国革命分两步走</p></blockquote></li></ul></li></ol><h3 id="11-新民主主义的基本纲领（总纲领）"><a href="#11-新民主主义的基本纲领（总纲领）" class="headerlink" title="11.新民主主义的基本纲领（总纲领）"></a>11.新民主主义的基本纲领（总纲领）</h3><p><em>新民主主义基本纲领是新民主主义革命路线的进一步展开和体现，为新民主主义革命指明了具体的奋斗目标</em></p><ul><li><p>哪来的？</p><ol><li><p>1940年，毛泽东在《新民主主义论》：阐述了新民主主义的政治、经济、文化。</p></li><li><p>（基本纲领）1945年，毛泽东在党的七大所作的政治报告《论联合政府》：进一步把新民主主义的政治、经济和文化与党的基本纲领联系起来，进行了具体阐述。</p><blockquote><p>标志毛泽东思想的成熟。</p></blockquote></li></ol></li></ul><p><em>新民主主义的政治、新民主主义的经济和新民主主义的文化相结合，就是新民主主义的共和国</em> </p><ol><li><p>新民主主义的政治纲领</p><ul><li><p>新民主主义的政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的，以工农联盟为基础的、各革命阶级联合专政的新民主主义共和国。</p><blockquote><p>总路线是：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命</p></blockquote></li><li><p>新民主主义的国体：各革命阶级联合专政</p><blockquote><p>社会主义的国体：人民民主专政</p></blockquote></li><li><p>新民主主义的政体：民主集中制的人民代表大会制度</p><blockquote><p>社会主义的政体：民主集中制的人民代表大会制度（相同）</p></blockquote></li></ul></li><li><p>新民主主义的经济纲领</p><ul><li><p>经济纲领：</p><ol><li>（新民主主义革命的主要内容）没收封建地主阶级的土地归农民所有</li><li>没收官僚资产阶级的垄断资本归新民主主义国家所有</li><li>保护民族工商业</li></ol></li><li><p>新民主主义革命的主要内容：没收封建地主阶级的土地归农民所有</p></li><li><p>新民主主义革命的应有之义：没收官僚资产阶级的垄断资本归新民主主义国家所有</p><p><em>没收官僚资本，包含着新民主主义革命和社会主义革命的双重性质</em> </p><blockquote><p>官僚，代表着反帝反封建，具有民主主义革命性质</p><p>资本，代表反资，具有社会主义革命性质</p></blockquote></li><li><p>新民主主义经济纲领中极具特色的一项：保护民族工商业</p></li></ul></li><li><p>新民主主义的文化纲领</p><ul><li><p>新民主主义文化：民族的科学的大众的文化</p><p><em>新民主主义文化，就是无产阶级领导的人民大众的反帝反封建的文化</em> </p><blockquote><p>考：民族的科学的大众的是什么含义</p></blockquote><ol><li>民族的（反帝）：内容是反对帝国主义压迫，主张中华民族的尊严和独立；形式上是具有鲜明的民族风格、形式和特色，要有中国作风和气派。</li><li>科学的（反封建）：反对一切封建思想和迷信思想，主张实事求是、客观真理及理论和实践结合的一致性。</li><li>大众的：人民大众的文化。</li></ol></li></ul></li></ol><h3 id="12-新民主主义革命的道路（总道路）"><a href="#12-新民主主义革命的道路（总道路）" class="headerlink" title="12.新民主主义革命的道路（总道路）"></a>12.新民主主义革命的道路（总道路）</h3><ul><li><p>哪来的？</p><p><em>1927年大革命失败后，党的工作重心开始转向农村。秋收起义失败后，毛泽东率领队伍奔赴井冈山，创建井冈山革命根据地，把武装斗争的主攻方向首先指向农村</em></p><ol><li><p>土地革命战争时期-《中国的红色政权为什么能够存在》《井冈山的斗争》《星星之火，可以燎原》：提出了“工农武装割据”的思想，初步形成了农村包围城市的革命道路理论。</p><blockquote><p>标志着新民主主义革命道路的形成。</p><p>（土地革命）“工农武装割据”的思想标志着毛泽东思想的初步形成。</p><p>（抗日战争）新民主主义革命理论的系统阐述标志着毛泽东思想趋于成熟。</p><p>（党的七大）将毛泽东思想写入党章标志着毛泽东思想正式确立。</p></blockquote></li><li><p>党的六届六中全会-《战争和战略的问题》：从此把经过长期武装斗争，先占乡村，后取城市，最后夺取全国胜利，作为革命道路确立下来。</p></li></ol></li><li><p>新民主主义革命的道路：农村包围城市，武装夺取政权。</p></li></ul><blockquote><p>分析道路的必要性；分析道路的可能性；分析怎么做的问题</p></blockquote><ol><li><p>新民主主义革命道路形成的依据（必然性/必要性）：<strong>具体国情</strong>（经济发展极不平衡的半殖民地反封建社会）</p><p><em>中国革命必须走农村包围城市，武装夺取政权的道路，是由中国所处的时代特点和具体国情决定的</em> </p><ul><li>首先：在半殖民地半封建的中国社会中，内无民主制度而受封建主义的压迫，外无民族独立而受帝国主义的压迫。</li><li>其次：近代中国是一个农业大国，农民占全国人口的绝大多数，是无产阶级可靠的同盟军和革命的主力军。</li></ul></li><li><p>中国走农村包围城市、武装夺取政权的道路的现实可能性：<strong>具体国情</strong> </p><ul><li><p>（最重要的客观条件：存在缝隙和可能）近代中国是多个帝国主义间接统治的经济落后的半殖民地国家。社会政治经济发展极端不平衡。军阀混战，四分五裂，存在不少统治薄弱环节。</p></li><li><p>（革命的群众基础好）近代中国广大农村深受多重压迫和剥削，人民革命愿望强烈，革命的群众基础好。</p></li><li><p>（客观条件：革命形势发展）全国革命形式继续向前发展，为在农村建设革命根据地提供<strong>客观条件</strong>。</p></li><li><p>（红军是坚强后盾）相当力量正式红军的存在，为农村革命根据地的建设提供<strong>坚强后盾</strong>。</p></li><li><p>（重要的主观条件：党的领导）党的领导为农村革命根据地的建设提供了重要的<strong>主观条件</strong>。</p></li></ul></li><li><p>新民主主义革命道路的内容（怎么做）</p><p><strong>中国革命走农村包围城市、武装夺取政权的道路，根本在于处理好土地革命、武装斗争、农村革命根据地建设三者之间的关系</strong> </p><ul><li>内容：处理好土地革命、武装斗争、农村革命根据地建设三者之间的关系<ul><li>民主革命的基本内容：土地革命</li><li>中国革命的主要形式和强有力保证：武装斗争</li><li>进行武装斗争和开展土地革命的依托：农村革命根据地</li></ul></li></ul></li></ol><h3 id="13-新民主主义革命的三大法宝（总经验）"><a href="#13-新民主主义革命的三大法宝（总经验）" class="headerlink" title="13.新民主主义革命的三大法宝（总经验）"></a>13.新民主主义革命的三大法宝（总经验）</h3><ul><li>哪来的？<ul><li>毛泽东-《〈共产党人〉发刊词》指出：统一战线、武装斗争、党的建设，是中国共产党在中国革命中战胜敌人的三大法宝。</li></ul></li></ul><ol><li><p>统一战线：无产阶级政党策略思想的<strong>重要内容</strong></p><blockquote><p>必要性，可能性，怎么做</p></blockquote><ul><li><p>必要性：</p><ol><li><p>（国情：半殖民地半封建社会阶级状况）中国社会是一个两头小中间大的社会，无产阶级和地主大资产阶级只占少数，最广大的人民是农民、城市小资产阶级以及其他中间阶级。</p><blockquote><p>两个小头：无产阶级和地主大资产阶级</p><p>中间：农民、城市小资产阶级以及其他中间阶级</p></blockquote><p><em>必须把农民、城市小资产阶级以及其他中间阶级都团结起来，建立最广泛的统一战线</em> </p></li><li><p>（中国革命的性质）是由中国革命的长期性、残酷性及其发展的不平衡性决定的。</p></li></ol></li><li><p>可能性：半殖民地半封建社会中有许多矛盾</p><p><em>半殖民地半封建社会的中国社会，诸多矛盾交织在一起，客观上为无产阶级及其政党利用这些矛盾建立和发展统一战线提供可能性</em></p><ul><li>统一战线中的两个联盟：<ol><li>（依靠工农联盟）工人阶级同农民、广大知识分子及其他劳动者的联盟，主要是工农联盟。</li><li>（扩大与民族资产阶级的联盟）工人阶级和非劳动人民的联盟，主要是与民族资产阶级的联盟。</li></ol></li></ul></li><li><p>统一战线的实践经验：</p><ul><li><p>建立巩固的工农联盟</p></li><li><p>（最重要的经验）正确对待资产阶级，尤其是民族资产阶级。在革命斗争中依据革命的需要，对资产阶级既联合又斗争的策略。</p></li><li><p>采取区别对待的方针。在革命进程中，要坚持发展进步势力、争取中间势力、孤立顽固势力的策略方针。</p></li><li><p>坚持独立自主的原则。保持党在政治上、组织上和思想上的独立性。</p></li></ul></li></ul></li><li><p>武装斗争：中国革命的特点和优点</p><ul><li>武装斗争的革命经验：<ul><li>（党的领导）坚持党对军队的绝对领导。<ul><li>建设新型人民军队的<strong>根本原则</strong>：坚持党对军队的绝对领导。</li><li>保持人民军队无产阶级性质和建军宗旨的<strong>根本前提</strong>：党对军队的绝对领导。</li><li>毛泽东建军思想的<strong>核心</strong>：党对军队的核心领导。</li></ul></li><li>（人民军队）建设全心全意为人民服务的人民军队。<ul><li>人民军队的<strong>唯一宗旨</strong>：全心全意为人民服务。</li><li>建设新型人民军队的<strong>基本前提</strong>：全心全意为人民服务。</li><li>人民军队一切行动的根本准则和一切工作的<strong>出发点和归宿</strong>：全心全意为人民服务。</li><li>人民军队立于不败之地的<strong>根本所在</strong>：全心全意为人民服务。</li></ul></li><li>（战略战术）坚持正确的战略战术。</li></ul></li></ul></li><li><p>党的建设：</p><p><em>中国共产党要领导革命取得胜利，必须不断加强党的思想建设、组织建设和作风建设。</em></p><p>加强党的建设的经验：</p><ul><li><p>（首位：思想建设）把党的<strong>思想建设</strong>放在党的建设的首位。</p><blockquote><p>在习近平思想中：政治放在党的建设的首位。</p></blockquote></li><li><p>重视党的<strong>组织建设</strong>。根本是贯彻民主集中制这一根本组织原则。</p></li><li><p>重视党的<strong>作风建设</strong>。</p><p><em>党在领导新民主主义革命的过程中，把党的建设作为一项“伟大的工程”</em> </p><p>优良作风：</p><ol><li>理论联系实际</li><li>密切联系群众</li><li>批判与自我批评相结合。</li></ol><ul><li><p>共产党区别于其他任何政党的显著标志：优良作风。</p><blockquote><p>共产党区别与其他任何政党的根本标志：为人民服务。</p></blockquote></li></ul></li></ul></li></ol><h3 id="14-新民主主义革命理论的意义"><a href="#14-新民主主义革命理论的意义" class="headerlink" title="14.新民主主义革命理论的意义"></a><em>14.新民主主义革命理论的意义</em></h3><ul><li>理论上：丰富了马克思主义理论，开辟了马克思主义中国化的发展道路<ul><li>回答了：中国革命向何处去的问题，以及中国革命的发展阶段问题。</li></ul></li><li>实践上：指导中国革命，于1949年建立中华人民共和国。</li><li>国际上：鼓舞他国，提供实际经验。</li></ul><h2 id="社会主义改造理论"><a href="#社会主义改造理论" class="headerlink" title="社会主义改造理论"></a>社会主义改造理论</h2><h3 id="15-新民主主义社会性质和特点"><a href="#15-新民主主义社会性质和特点" class="headerlink" title="15.新民主主义社会性质和特点"></a>15.新民主主义社会性质和特点</h3><ul><li><p>新民主主义社会：过渡性社会</p><p><em>从中华人民共和国成立（1949）到社会主义改造基本完成（1956），是我国从新民主主义到社会主义的过渡时期</em> </p></li><li><p>这一时期的社会性质(国情）：新民主主义社会</p><p><em>新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会形态</em> </p><blockquote><p>国情变了：之前是半殖民半封建社会，现在是新民主主义社会。</p><p>随之矛盾变了。</p></blockquote></li><li><p>新民主主义社会的<strong>五种经济成分</strong>：</p><ol><li><p>国营经济（社会主义性质）</p></li><li><p>农民和手工业者的个体经济（非社会主义性质）</p></li><li><p>合作社经济（半社会主义性质，过渡形式）</p><p><em>半社会主义性质的合作社经济是个体经济向社会主义集体经济的过渡形式</em></p></li><li><p>私人资本主义经济（非社会主义性质）</p></li><li><p>国家资本主义经济（过渡形式）</p><p><em>国家资本主义经济是私人资本主义经济向社会主义国营经济过渡的形式</em> </p></li></ol></li><li><p>新民主主义社会的<strong>主要经济成分</strong>：</p><ol><li>社会主义经济（国营经济）</li><li>个体经济（农民和手工业者的个体经济）</li><li>资本主义经济（私人资本主义经济）</li></ol></li><li><p>新民主主义社会的<strong>阶级构成</strong></p><p><em>与新民主主义时期的三种不同性质的主要经济成分相联系</em> </p><ol><li><p>工人阶级（社会主义经济-国营经济）</p></li><li><p>农民阶级和其他小资产阶级（个体经济-农民和手工业者的个体经济）</p><p><em>农民和手工业者的个体经济既可以自发走向资本主义，也可以被引导走向社会主义，本身不代表一种独立发展方向</em> </p></li><li><p>民族资产阶级（资本主义经济-私人资本主义经济）</p></li></ol></li><li><p>新民主主义社会的<strong>矛盾</strong></p><p><em>三种基本经济成分与之相联系的三种基本的阶级力量之间的矛盾</em></p><ol><li>社会主义和资本主义两条道路的矛盾。</li><li>（主要矛盾）工人阶级和资产阶级两个阶级的矛盾。</li></ol><blockquote><p>总结——主要矛盾</p><p>新民主主义革命之前的矛盾：（主要矛盾）帝国主义和中华民族的矛盾；封建主义和人民大众的矛盾。</p><p>新民主主义社会的矛盾：社会主义和资本主义的矛盾；<strong>（主要）</strong>工人阶级和资产阶级的矛盾。</p></blockquote></li><li><p>新民主主义社会的特点：</p><ul><li><p>民主资产阶级具有两面性。</p><blockquote><p>在新民主主义革命时，民主资产阶级的两面性为革命性和妥协性。</p></blockquote><ul><li>对抗性矛盾-剥削者与被剥削者：剥削工人的一面</li><li>非对抗性矛盾：接受无产阶级及其政党领导的一面</li></ul></li><li><p>社会主义因素在经济上和政治上占<strong>领导地位</strong>，但非社会主义因素仍有很大比重。</p><blockquote><p>社会主义因素：公有制因素，社会主义经济占领导地位，但不是主体地位（数量上）。</p><p>非社会主义因素：个体经济和资本主义经济。</p><p>在1949-1956，公有制经济是领导地位，而不是主体地位。</p></blockquote></li><li><p>新民主主义社会<strong>属于社会主义体系的</strong>，是逐步过渡到社会主义社会的过渡性质的社会。</p><blockquote><p>属于社会主义体系，但新民主主义社会是一个过渡性社会，不是社会主义社会。</p><p>同理，新民主主义革命是一个资产阶级性质的民主革命，但是属于世界无产阶级社会主义革命的一部分。</p></blockquote></li></ul></li></ul><h3 id="16-党在过渡时期的总路线及其理论依据"><a href="#16-党在过渡时期的总路线及其理论依据" class="headerlink" title="16.党在过渡时期的总路线及其理论依据"></a>16.党在过渡时期的总路线及其理论依据</h3><ul><li><p>党在过渡时期的总路线：“一化三改”</p><p><em>这是一条社会主义建设和社会主义改造同时并举的路线，体现了社会主义工业化和社会主义改造的紧密结合。</em> </p><ul><li><p>（1949-1956）从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。</p></li><li><p>过渡时期的总路线和总任务：”一化三改“</p><ul><li>“一化”：社会主义工业化</li><li>“三改”：对个体农业、手工业和资本主义工商业的社会主义改造。</li></ul></li></ul><blockquote><p>总结——总路线/基本路线</p><p>新民主主义革命的总路线（-1949）：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的路线。</p><p>党在过渡时期的总路线（1949-1956）：一化三改。</p><p>现在的总路线：一个中心，两个基本点。</p></blockquote></li><li><p>过渡时期的必要性</p><p><em>我国由新民主主义社会过渡到社会主义社会，这一过渡时期之所以必要，并且需要一个相当长的时间。</em> </p><ol><li>（经济文化落后）我国经济文化落后，需要一个相当长的时期为社会主义创造经济和文化上的前提。</li><li>（非社会主义因素的比重大）个体农业、手工业和资本主义工商业比重大，需要一个相当长的时期来改造</li></ol></li></ul><h3 id="17-适合中国特点的社会主义改造道路"><a href="#17-适合中国特点的社会主义改造道路" class="headerlink" title="17.适合中国特点的社会主义改造道路"></a>17.适合中国特点的社会主义改造道路</h3><blockquote><p>道路总结：</p><p>新民主主义革命的道路：农村包围城市，武装夺取政权。</p><p>社会主义改造道路：合作化。</p><p>社会主义改造基本完成到现在：中国特色社会主义道路</p></blockquote><ol><li><p>农业的社会主义改造</p><ol><li><p>积极引导农民组织起来，走<strong>互助合作</strong>的<strong>道路</strong>。</p><p><em>土地改革完成后，我国广大农民的生产积极性大大提高。这种积极性体现在两个方面：一是*</em>个体经济的积极性，二是互助合作的积极性。*** </p></li><li><p>遵循自愿互利，典型示范和国家帮助的<strong>原则</strong>。 </p><p><em>以互助合作的优越性吸引农民走互助合作道路。</em></p></li><li><p>正确分析农村的阶级和阶层状况，指定正确的阶级政策。</p><p><em>贫农、雇农和中农</em> </p></li><li><p>坚持积极领导、稳步前进的<strong>方针</strong>，采取循序渐进的<strong>步骤</strong>。</p><ol><li>发展互助组：社会主义萌芽性质。</li><li>建立初级农业生产合作社：半社会主义性质。</li><li>发展高级社：完全的社会主义性质。</li></ol></li></ol><ul><li>农业的社会主义改造道路：互助合作</li><li>农业的社会主义改造原则：自愿互利、典型示范和国家帮助。</li><li>农业的社会主义改造方针：积极领导、稳步前进</li><li>农业的社会主义改造步骤：循序渐进。</li></ul></li><li><p>手工业的社会主义改造</p><ul><li>步骤：<ol><li>办手工业供销小组：社会主义萌芽性质。</li><li>办手工业供销合作社：半社会主义性质。</li><li>建立手工业生产合作社：完全的社会主义</li></ol></li><li>手工业的社会主义改造道路：生产合作。</li><li>手工业的社会主义改造方针：积极领导、稳步前进。</li></ul></li><li><p><strong>资本主义工商业</strong>的社会主义改造</p><ol><li><p>用<strong>和平赎买</strong>的<strong>方法</strong>改造资本主义工商化</p><p><em>所谓赎买，就是国家有偿地将私营企业改变为国营企业，将资本主义私有制改变为社会主义公有制。</em> </p><p><em>赎买的具体方式不是由国家支付一笔巨额补偿资金，而是让资本家在一定年限内从企业经营中获取一部分利润。</em> </p><ul><li><p>对资本主义工商业实行和平赎买的<strong>必要性</strong>：</p><ul><li>（促进国民经济发展）有利于发挥私营工商业在国计民生方面的积极作用，促进国民经济发展。</li><li>（争取和团结民族资产阶级）有利于争取和团结民族资产阶级。</li><li>（发展统一战线）有利于团结各民主党派和各界爱国人士，巩固和发展统一战线。</li><li>有利于发挥民族资产阶级中大多数人的知识、才能、技术专长和管理经验。</li><li>有利于争取和团结那些原来同资产阶级相联系的知识分子为社会主义建设服务。</li></ul></li><li><p>对资本主义工商业实行和平赎买的<strong>可能性</strong>：</p><ul><li><p>民主资产阶级具有两面性。</p><p><em>在社会主义革命时期，民族资产阶级既有剥削工人获取利润的一面，又有拥护宪法、愿意接受社会主义改造的一面。</em></p></li><li><p>中国共产党与民族资产阶级长期保持统一战线的关系。</p><p><em>这就为将工人阶级和民族资产阶级之间存在着的对抗性矛盾转化为非对抗性矛盾，并按照人民内部矛盾来处理提供前提</em> </p></li><li><p>我国已经有了以工人阶级为领导的、工农联盟为基础的人民民主专政的国家政权，建立了强大的社会主义国营经济并掌握了国家的经济命脉，这就造成了私人资本主义在政治上、经济上对社会主义的依赖。</p></li></ul></li></ul></li><li><p>采取从低级到高级的<strong>国家资本主义</strong>的过渡<strong>形式</strong> </p><ul><li><p>步骤：</p><ol><li><p>实行初级形式的国家资本主义：社会主义萌芽性质</p><p><em>国家在私营工业中实行委托加工、计划订货、统购包销，在私营商业中采取委托经销、代销等形式。企业利润按照“四马分肥”的方式分配。</em>  </p></li><li><p>实行个别企业的公私合营：半社会主义性质的企业</p><p><em>国家向私营企业投资入股，企业的生产资料由国家和资本家共同所有，企业利润的分配仍为“四马分肥”。</em> </p></li><li><p>实行全行业的公私合营：完全的社会主义性质，成为社会主义国营性质的企业。</p><p><em>1956年，全行业公私合营进入高潮。这<strong>标志着</strong>国家对资本主义工商业的社会主义改造已基本完成。生产资料为国家所有。</em> </p><ul><li>实行全行业的公私合营<strong>标志着</strong>国家对资本主义工商业的社会主义改造已基本完成。</li></ul><p><em>全行业公私合营后，企业的生产关系已经发生了根本变化，基本上成为社会主义国营性质的企业。</em> </p></li></ol></li></ul></li><li><p>把资本主义工商业者改造为自食其力的社会主义劳动者。</p></li></ol><ul><li>资本主义工商业的社会主义改造方法：和平赎买</li><li>资本主义工商业的改造形式：国家资本主义</li></ul></li></ol><h3 id="18-社会主义改造的历史经验"><a href="#18-社会主义改造的历史经验" class="headerlink" title="18.社会主义改造的历史经验"></a>18.社会主义改造的历史经验</h3><ul><li><p>历史经验</p><p><em>在进行社会主义改造、向社会主义过渡的进程中，中国共产党积累了丰富的历史经验。</em> </p><ol><li>坚持社会主义工业化建设与社会主义改造同时<strong>并举</strong>。</li><li>采取积极引导、逐步过渡的方式。</li><li>用和平方法进行改造。</li></ol></li><li><p>问题</p><p><em>我国的社会主义改造取得了历史性的胜利，也出现了一些失误和偏差</em> </p><p>主要是：</p><ol><li>（社会主义经济模式单一）在社会主义经济模式的选择和理解上过于单一，追求纯粹的单一的社会主义经济成分；</li><li>（公有制实现形式理解简单化）在公有制实现形式的选择和理解上过于简单化，只注意到集体所有制和全民所有制这两种基本形式，而对社会主义改造基本完成以后公有制经济可以和非公有制经济共同发展缺乏认识。</li></ol></li></ul><h3 id="19-社会主义基本制度的确立及其理论依据"><a href="#19-社会主义基本制度的确立及其理论依据" class="headerlink" title="19.社会主义基本制度的确立及其理论依据"></a>19.<em>社会主义基本制度的确立及其理论依据</em></h3><ul><li><p>1956年底，我国对农业、手工业和资本主义工商业的社会主义改造基本完成。</p><ul><li><p>标志着：中国历史长达数千年的阶级剥削制度的结束和社会主义基本制度的确立。</p></li><li><p>社会经济结构发生了根本变化，社会主义经济成分已占绝对优势，社会主义公有制已成为我国社会的经济基础。</p></li><li><p>实现了：我国由新民主主义的国家转变为社会主义国家，我国进入社会主义初级阶段。</p><blockquote><p>国情：</p><ol><li>新民主主义革命时期（1919-1949）：半殖民地半封建社会</li><li>社会主义改造时期（14949-1956）：新民主主义社会，过渡性社会</li><li>社会主义改造基本完成/社会主义基本制度的确立（1956）——至今：社会主义初级阶段</li></ol></blockquote></li></ul></li></ul><h3 id="20-确立社会主义基本制度的重大意义"><a href="#20-确立社会主义基本制度的重大意义" class="headerlink" title="20.确立社会主义基本制度的重大意义"></a><font color='red'>20.确立社会主义基本制度的重大意义</font></h3><ol><li><p>（伟大变革，制度基础）<strong>社会主义基本制度的确立</strong>是中国历史上<strong>最伟大最深刻的变革</strong>，为当代中国一切发展进步奠定了制度基础，也为中国特色社会主义制度的创新和发展提供了重要前提。</p><blockquote><p>推翻了几千年的剥削制度。</p></blockquote></li><li><p>（提高积极性，促进生产力发展）社会主义基本制度的确立，极大的提高了工人阶级和广大劳动人民的积极性、创造性，极大促进了我国社会生产力的发展。</p></li><li><p>社会主义基本制度的确立，使广大劳动人民真正成为国家的主人。</p><blockquote><p>1949新中国成立，使中国人民成为国家的主人。（消灭了帝国主义和封建主义的压迫，但国内还有资产阶级的压迫）</p><p>1956年社会主义基本制度的确立，广大劳动人民成为国家的主人。（消灭了资产阶级的剥削，改造了小生产的私有制）</p></blockquote></li><li><p>（世界社会主义发展史）中国社会主义基本制度的确立，使占世界人口1/4的东方大国进入社会主义社会，这是世界社会主义发展史上的又一历史性的伟大胜利。</p></li><li><p>（马列主义的正确，发展科学社会主义理论）社会主义基本制度的确立，是马克思列宁主义关于社会主义革命理论在中国的正确运用和创造性发展的结果。它不仅再次证明了马克思列宁主义的真理性，而且以其独创性的理论原则和经验总结丰富和发展了科学社会主义理论。</p><p>社会主义建设道路初步探索理论</p></li></ol><blockquote><p>探索理论：1956-1976中正确的理论。</p></blockquote><ol><li>调动一起积极因素为社会主义事业服务的思想</li><li>正确认识和处理社会主义矛盾的思想</li><li>走中国工业化道路的思想</li></ol><h3 id="21-调动一切积极因素为社会主义事业服务的思想"><a href="#21-调动一切积极因素为社会主义事业服务的思想" class="headerlink" title="21.调动一切积极因素为社会主义事业服务的思想"></a>21.调动一切积极因素为社会主义事业服务的思想</h3><ul><li><p>1956年，毛泽东-《论十大关系》的报告：提出调动一切积极因素为社会主义事业服务的思想</p><ul><li>标志着：马克思主义同中国实际的第二次结合的开始。</li></ul></li><li><p>《论十大关系》</p><ul><li>初步总结了我国社会主义建设的经验，明确提出了以苏为鉴，<strong>独立自主</strong>地探索适合中国情况的社会主义建设道路。<ul><li>探索原则：独立自主。</li></ul></li><li>《论十大关系》确定了一个<strong>基本方针</strong>：“努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素全部调用起来”，为社会主义建设服务。<ul><li>基本方针：调动一切积极因素为社会主义事业服务的思想。</li></ul></li></ul></li></ul><h3 id="22-正确认识和处理社会主义社会矛盾的思想"><a href="#22-正确认识和处理社会主义社会矛盾的思想" class="headerlink" title="22.正确认识和处理社会主义社会矛盾的思想"></a>22.正确认识和处理社会主义社会矛盾的思想</h3><ul><li><p>党的八大前后，1957年-毛泽东《关于正确处理人民内部矛盾的问题》的报告：系统论述了社会主义社会矛盾的理论。</p></li><li><p>毛泽东指出，矛盾是普遍存在的，社会主义社会同样<strong>充满着</strong>矛盾，正是这些矛盾推动着社会主义社会不断地向前发展。</p><blockquote><p>考：</p><p>不要把关注点过分关注在一些细节上。</p><p>（说的很有道理，以前做题养成的习惯，太武断的不敢选，但政治就需要方向正确，需要武断一点。）</p><p>比如 农村包围城市，武装夺取政权是中国革命取得胜利的唯一道路，正确。</p></blockquote><ol><li><p>关于社会主义社会的<strong>基本矛盾</strong></p><ol><li><p>“社会主义社会中，基本的矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾”。</p><blockquote><p>一切社会的基本矛盾都是生产关系和生产力之间的矛盾，上层建筑和经济基础的矛盾。</p></blockquote></li><li><p>社会主义社会的基本矛盾是在生产关系和生产力基本适应、上层建筑和经济基础基本适应条件下的矛盾，是在人民根本利益一致基础上的矛盾，是<strong>非对抗性的矛盾</strong>。</p><blockquote><p>在剥削社会，基本矛盾是对抗性矛盾</p></blockquote></li><li><p>社会主义基本矛盾具有“又相适应又相矛盾”的特点，其中，相适应的一面是基本方面，相矛盾的一面是非基本方面。</p><blockquote><p>相适应的是矛盾的主要方面，相矛盾的方面是次要方面。</p></blockquote></li></ol></li><li><p>关于我国社会主义的<strong>主要矛盾</strong>和根本任务</p><p><em>社会主义制度在我国已经基本建立起来了。我国的主要矛盾：</em> </p><ol><li>已经是人民对于 建立先进的工业国 的要求 同 落后的农业国 的现实 之间的矛盾，</li><li>已经是人民对于 经济文化迅速发展 的需要 同 当前经济文化不能满足人民需要的状况 之间的矛盾。</li></ol><blockquote><p>1956年中国进入社会主义初级阶段，主要矛盾有三个阶段：</p><ul><li>毛泽东：人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾，人民对于经济文化迅速发展的需要同经济文化不能满足人民需要的状况之间的矛盾。</li><li>邓小平：人民日益增长的物质文化需要和落后的社会生产力之间的矛盾。</li><li>习近平：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</li></ul></blockquote></li><li><p>关于社会主义社会存在<strong>两种不同性质矛盾</strong>的理论</p><ul><li><p>社会主义社会的矛盾（在政治上的划分）：敌我矛盾和人民内部矛盾</p><ul><li><p>敌我矛盾（<strong>对抗性矛盾</strong>）：这是根本利益对立基础上的矛盾。</p><p><em>人民同 反抗社会主义革命、敌视和破坏社会主义建设 的社会势力和社会集团 的矛盾。</em></p></li><li><p>人民内部矛盾（<strong>非对抗性矛盾</strong>）：人民根本利益一致基础上的矛盾。</p><p><em>包括工人阶级内部的矛盾，农民阶级内部的矛盾，知识分子内部的矛盾，工农两个阶级之间的矛盾，工人、农民同知识分子之间的矛盾，政府和人民群众之间的矛盾等等</em> </p></li></ul></li><li><p>毛泽东强调不同性质矛盾的转化问题：两类不同性质的矛盾的存在是客观的，但不是固定不变的，在一定条件下，两类不同性质的矛盾可以互相转化。</p></li></ul></li><li><p>关于正确处理两类不同性质社会矛盾的<strong>基本方法</strong> </p><ul><li>解决敌我矛盾，是分清敌我的问题，采用专政的方法。</li><li>解决人民内部矛盾，是分清是非的问题，采用民主的方法。</li></ul><blockquote><p>所以我国的国体叫：人民民主专政</p></blockquote></li><li><p>关于正确处理人民内部矛盾的方针</p><ul><li>总方针：用<strong>民主</strong>的方法解决人民内部矛盾</li></ul><ol><li>政治思想领域的人民内部矛盾：实行“团结—批评—团结”的方针，坚持说服教育、讨论的方法。</li><li>物质利益、分配方面的人民内部矛盾：实行统筹兼顾、适当安排的方针，兼顾国家、集体和个人三方面的利益。</li><li>人民群众和政府机关的矛盾：坚持民主集中制原则，努力克服政府机关的官僚主义，也要加强对群众的思想教育。</li><li>科学文化领域里的矛盾：实行“百花齐放、百家争鸣”的方针。</li><li>共产党派和民主党派的矛盾：实行 坚持 社会主义道路和共产党领导的 前提下“长期共存、互相监督”的方针。</li><li>民族之间的矛盾：实行民族平等、团结互助的方针，着重反对大汉族主义，也要反对地方民族主义。</li></ol></li><li><p>毛泽东强调，关于正确处理人民内部矛盾的问题就是社会主义国家政治生活的<strong>主题</strong></p><ul><li>社会主义国家政治生活的主题：正确处理人民内部矛盾的问题</li><li>这一论断的根本着眼点，在于调用一切积极因素，团结一切可以团结的力量，把全党的注意力转到社会主义建设上来。</li></ul></li></ol></li></ul><h3 id="23-走中国工业化道路的思想"><a href="#23-走中国工业化道路的思想" class="headerlink" title="23.走中国工业化道路的思想"></a>23.走中国工业化道路的思想</h3><ul><li><p>毛泽东-《论十大关系》中论述的第一大关系：重工业、轻工业和农业的关系。</p></li><li><p>毛泽东-《关于正确处理人民内部矛盾的问题》：明确提出<strong>中国工业化道路的问题</strong>，主要是指重工业、轻工业和农业的发展关系的问题，要走一条有别于苏联的中国工业化道路。</p></li><li><p>毛泽东提出了<strong>以农业为基础，以工业为主导</strong>，以<strong>农轻重为序</strong>发展国民经济的总方针。</p><ul><li>总方针：农轻重为序。</li><li>基础：农业</li><li>主导：工业</li></ul></li><li><p>如何走中国工业化道路</p><p><em>走中国工业化道路的思想，是党探索我国社会主义建设道路的一个重要思想，对于加快我国社会主义建设事业发展具有重大意义。</em> </p><ol><li><p>必须明确战略目标和战略步骤</p><blockquote><p>“两步走”</p></blockquote></li><li><p>必须采取正确的经济建设方针</p></li><li><p>必须发展科学技术和文化教育</p></li><li><p>必须重视知识分子工作</p></li><li><p>必须调整和完善所有制结构</p></li><li><p>必须积极探索适合我国情况的经济体制和运行机制</p></li></ol></li></ul><h3 id="24-社会主义建设道路初步探索的意义"><a href="#24-社会主义建设道路初步探索的意义" class="headerlink" title="24.社会主义建设道路初步探索的意义"></a>24.社会主义建设道路初步探索的意义</h3><p><em>党领导人民探索社会主义建设道路，历经艰辛和曲折，在理论和实践上取得一系列重要成果</em> </p><ul><li><p>意义：</p><ol><li>巩固和发展了我国社会主义制度</li><li>为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础</li><li>丰富了科学社会主义的理论和实践</li></ol></li><li><p>教训：</p><ol><li><p>必须把马克思主义和中国<strong>实际</strong>相结合，探索<strong>符合中国特色</strong>的社会主义建设道路</p></li><li><p>必须正确认识社会主义社会的主要矛盾和根本任务，集中力量<strong>发展生产力</strong></p></li><li><p>必须从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成</p></li><li><p>必须发展社会主义<strong>民主</strong>，健全社会主义法制</p></li><li><p>必须坚持党的民主集中制和<strong>集体领导制度</strong>，加强执政党建设</p><blockquote><p>领导班子</p></blockquote></li><li><p>必须坚持对外开放，不能关起门来搞建设，借鉴和吸收人类文明成果建设社会主义。</p></li></ol></li><li><p>改革开放前后两个历史时期及其关系：</p><p><em>我们党领导人民进行社会主义建设，有改革开放前和改革开放后两个历史时期</em> </p><blockquote><p>社会主义建设：</p><p>改革开放前的时期：1956-1978</p><p>改革开放后的时期：1978-至今</p></blockquote><ul><li><p>这是两个相互联系又有重大区别的时期，但<strong>本质上</strong>都是：我们党领导人民进行社会主义建设的实践探索。</p><p><em>中国特色社会主义是在改革开放历史新时期开创的，但也是在新中国已经建立起社会主义基本制度、并进行了20多年建设的基础上开创的</em> </p><ul><li>改革开放前的社会主义实践探索为改革开放后的社会主义实践探索<strong>积累了经验并准备了条件</strong></li><li>改革开放后的社会主义实践探索是对前一个时期探索的坚持、改革和发展</li></ul><blockquote><p>所有不能否定两个时期的关系</p><p>不能说改革开放时期前的社会主义实践探索是正确的，改革开放时期后的是错误的；</p><p>也不能说改革开放时期前的是错误的，改革开放时期后的才是正确的。</p></blockquote></li></ul></li></ul><h1 id="中国特色社会主义理论体系"><a href="#中国特色社会主义理论体系" class="headerlink" title="中国特色社会主义理论体系"></a>中国特色社会主义理论体系</h1><p>中国特色社会主义理论体系</p><ul><li>邓小平理论（重点）、“三个代表”重要思想、科学发展观</li><li>习近平新时代新思想<ul><li>新时代的新思想及其历史地位</li><li>新时代中国特色社会主义的总任务</li><li>新时代中国特色社会主义的布局</li><li>新时代中国特色社会主义的内在条件和领导核心</li></ul></li></ul><h2 id="邓小平理论"><a href="#邓小平理论" class="headerlink" title="邓小平理论"></a>邓小平理论</h2><h3 id="25-邓小平理论的形成条件"><a href="#25-邓小平理论的形成条件" class="headerlink" title="25.邓小平理论的形成条件"></a>25.邓小平理论的形成条件</h3><ol><li><p><strong>和平与发展</strong>成为时代主题是邓小平理论形成的时代背景</p><p><em>现在世界上真正大的问题，带全球性的战略问题，一个是和平问题，一个是经济问题或者说是发展问题。和平问题是东西问题，发展问题是南北问题。概括起来，就是东西南北四个字。</em> </p><ul><li><p>南北问题是<strong>核心问题</strong>。</p><blockquote><p>东方主要是社会主义，西方主要是资本主义。</p></blockquote></li></ul></li><li><p>社会主义建设的经验教训是邓小平理论形成的<strong>历史根据</strong></p></li><li><p>改革开放和现代化建设的实践 是邓小平理论形成的<strong>现实依据</strong> （实践基础）</p><p><em>习近平指出：邓小平同志留给我们的最重要的思想和政治遗产，就是他带领党和人民开创的中国特色社会主义，就是他创立的邓小平理论。</em> </p><p>邓小平同志留下的最重要的思想和政治遗产：</p><ul><li>带领党和人民开创的中国特色社会主义</li><li>创立的邓小平理论</li></ul></li></ol><h3 id="26-邓小平理论的形成过程"><a href="#26-邓小平理论的形成过程" class="headerlink" title="26.邓小平理论的形成过程"></a>26.邓小平理论的形成过程</h3><ol><li><p>1978年党的十一届三中全会，<strong>重新确立</strong>了解放思想、实事求是的思想路线。</p></li><li><p>1982<strong>党的十二大</strong>后，“中国特色社会主义”成为我们党的全部理论和实践创新主题</p><p><em>邓小平在党的十二大开幕词中明确指出：“把马克思主义的普遍真理同我国的具体实际结合起来，走自己的道路，建设有中国特色的社会主义，这就是我们总结长期历史经验得出的基本结论。</em> </p><ul><li>”中国特色社会主义“成为我们党的全部理论和实践创新<strong>主题</strong>：党的十二大。</li></ul></li><li><p>1987年<strong>党的十三大</strong> （重要！！！）</p><ul><li><strong>第一次</strong>比较系统的论述了我国社会主义初级阶段理论</li><li>明确概括和全面阐述了党的“一个中心、两个基本点”的基本路线</li><li>从马克思主义哲学、政治经济学和科学社会主义等方面，<strong>第一次</strong>对中国特色社会主义理论的主要内容作了系统概括。</li><li>这也是党第一次对中国特色社会主义理论进行系统概括，<strong>标志着</strong>邓小平理论<strong>轮廓</strong>的形成<ul><li>邓小平理论轮廓的形成：党的十三大</li><li>邓小平理论轮廓形成的标志：党的十三大第一次对中国特色社会主义理论进行系统概括</li></ul></li></ul></li><li><p>1992年<strong>邓小平南方谈话</strong>：针对人们思想中普遍存在的疑惑，重申了深化改革、加速发展的必要性和重要性。</p><ul><li>邓小平理论走向成熟：1992年南方谈话</li></ul></li><li><p>1992年党的十四大：第一次比较系统的初步回答了中国这样的经济文化比较落后的国家如何建设社会主义、如何巩固和发展社会主义的一系列基本问题，用新的思想、观点，继承和发展了马克思主义。</p></li><li><p>1997年<strong>党的十五大</strong></p><ul><li>正式提出“邓小平理论”这一概念</li><li>郑重把邓小平理论同马克思列宁主义、毛泽东思想一起，确立为党的思想并写入党章。</li></ul></li></ol><h3 id="27-邓小平理论回答的基本问题"><a href="#27-邓小平理论回答的基本问题" class="headerlink" title="27.邓小平理论回答的基本问题"></a>27.邓小平理论回答的基本问题</h3><p><em>什么是社会主义、怎样建设社会主义，是邓小平在领导改革开放和现代化建设这一新的革命过程中，不断提出和反复思考的<strong>首要的基本理论问题</strong>。</em> </p><ul><li><p>首要基本理论问题：什么是社会主义，怎样建设社会主义？</p><blockquote><p>总结：每一代领导人回答的问题</p><p>毛泽东-毛泽东思想：什么是马克思主义，怎么对待马克思主义。</p><p>邓小平-邓小平理论：什么是社会主义，怎样建设社会主义。</p><p>江泽民-三个代表重要思想：建设什么样的党，怎样建设党。</p><p>胡锦涛-科学发展观：实现什么样的发展，怎样发展。</p><p>习近平-习近平新时代思想：新时代我们坚持和发展什么样的中国特色社会主义，怎样坚持和发展中国特色社会主义。</p></blockquote></li><li><p>1992年年初，邓小平在<strong>南方谈话</strong>中对社会主义本质作了总结下理论概括，“社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。</p><ul><li><p><strong>社会主义的本质</strong>：解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。</p><ul><li><p>这一科学概括，既包括了社会主义社会的生产力问题，又包括了以社会主义生产关系为基础的社会关系问题。 </p></li><li><p>根本任务：解放生产力，发展生产力</p></li><li><p>根本目标：共同富裕</p><blockquote><p>解放生产力，发展生产力：社会主义社会的生产力问题</p></blockquote></li></ul></li></ul><blockquote><p>消灭剥削，消除两极分化：社会主义生产关系为基础的社会关系问题</p><p>共同富裕：目标</p></blockquote><ul><li><p>这一科学概括，为我们坚持公有制又完善和发展公有制指出来明确的方向。</p><p><em>邓小平说：在改革中，我们始终坚持<strong>两条根本原则</strong>，一是以社会主义公有制经济为主体，一是共同富裕。</em> </p><p>两条根本原则：</p><ol><li>以社会主义公有制经济为主体</li><li>共同富裕</li></ol></li></ul></li></ul><h3 id="28-邓小平理论的主要内容"><a href="#28-邓小平理论的主要内容" class="headerlink" title="28.邓小平理论的主要内容"></a>28.邓小平理论的主要内容</h3><ol><li><p>解放思想、实事求是的<strong>思想路线</strong> </p><p><em>解放思想，实事求是，是我们党的思想路线。</em> </p><blockquote><p>我们党现在的思想路线：</p><ol><li>一切从实际出发：前提</li><li>理论联系实际：途径/方法</li><li><strong>实事求是：实质/核心</strong> （最重要）</li><li>在实践中检验和发展真理：检验条件/目的</li></ol></blockquote><ul><li><p>邓小平理论的活的灵魂：解放思想、实事求是</p></li><li><p>邓小平理论的精髓：解放思想、实事求是</p><blockquote><p>对比：</p><p>毛泽东思想的活的灵魂：实事求是、群众路线、独立自主</p><p>毛泽东思想的精髓：实事求是</p></blockquote></li></ul></li><li><p>社会主义初级阶段理论（国情论）</p><ul><li><p><strong>党的十三大前夕</strong>，邓小平指出：“我们党的十三大要阐述中国社会主义是处在一个什么阶段，就是处在初级阶段，是初级阶段的社会主义。社会主义本身是共产主义的初级阶段，而我们中国又处在社会主义的初级阶段，就是不发达的阶段。一切都要从这个实际出发，根据这个实际来制订规划。”</p><ul><li><strong>意味着把社会主义初级阶段作为事关全局的国情加以把握。</strong> </li></ul><blockquote><p>总结——关于社会主义初级阶段理论</p><ol><li>进入社会主义初级阶段：1956年三大改造完成</li><li>使用社会主义初级阶段这个词语：十一届六中全会</li><li>将社会主义初级阶段作为国情：十三大前夕</li><li>第一次比较系统的论述来我国社会主义初级阶段理论：党的十三大</li></ol></blockquote></li><li><p><strong>党的十三大</strong>，系统论述了社会主义初级阶段理论。</p><ul><li><p>社会主义初级阶段：就是指我国<strong>在生产力落后、商品经济不发达条件下</strong>建设社会主义必然要经历的特定阶段，即从我国进入社会主义到基本实现社会主义现代化的整个历史阶段。</p><blockquote><p>因为我国是在生产力落后、商品经济不发达条件下建设社会主义，所以要经历初级阶段。</p><p>但像挪威等高度发达的国家，如果进入社会主义，就不需要经历初级阶段。</p></blockquote></li><li><p>社会主义初级阶段的论断包括<strong>两层含义</strong></p><blockquote><p>量变质变规律</p></blockquote><ol><li>我国已经进入社会主义社会，必须坚持而不能离开社会主义。（定性，质）</li><li>我国的社会主义社会还处在不发达的阶段，必须正视而不能超越初级阶段。（定量）</li></ol></li></ul></li></ul></li><li><p>党的基本路线</p><p><em>党的十三大报告提出了党在社会主义初级阶段的基本路线：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗。</em>  </p><blockquote><p>考：戴帽子</p></blockquote><ol><li><p>建设“富强、民主、文明的社会主义现代化国家”。这是基本路线规定的党在社会主义初级阶段的<strong>奋斗目标。</strong></p></li><li><p>“一个中心、两个基本点”。这是基本路线<strong>最主要的内容</strong>，是实现社会主义现代化奋斗目标的<strong>基本途径。</strong></p><blockquote><p>一个中心：经济建设为中</p><p>两个基本点：坚持四项基本原则，坚持改革开放。</p><p>四项基本原则：坚持社会主义道路，坚持无产阶级专政，坚持中国共产党的领导，坚持马列主义、毛泽东思想这四项基本原则，是我们的立国之本。</p></blockquote></li><li><p>“领导和团结各国各族人民”。这是实现社会主义现代化奋斗目标的<strong>领导力量和依靠力量。</strong> </p></li><li><p>“自立根生，艰苦创业”。这是我们党的优良传统，也是实现社会主义初级阶段奋斗目标的<strong>根本立足点。</strong> </p><blockquote><p>辨析：出发点、落脚点和立足点</p><p>出发点=落脚点：为了什么而做。（一般是“人”本身）</p><p>立足点：做的时候依靠什么（一般是独立自主）</p></blockquote></li></ol><ul><li>如何坚持党的基本路线？<ol><li>必须紧紧围绕经济建设这一中心</li><li>必须把<strong>坚持四项基本原则</strong>同<strong>坚持改革开放</strong>结合起来，正确处理改革开放和四项基本原则的关系。</li></ol></li><li>社会主义初级阶段基本路线的意义（重要性）<ul><li>党的基本路线，是党和国家的生命线，人民的幸福线。</li></ul></li><li>党的十七大：把“和谐”与“富强、民主、文明”一起写入了基本路线。</li><li>党的十九大：提出“为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗”。<ul><li>“美丽”纳入了基本路线，而且将“现代化国家”提升为“现代化强国”</li><li>扩展了党的基本路线的内涵，提升了社会主义初级阶段的奋斗目标。</li></ul></li></ul></li><li><p>社会主义<strong>根本任务</strong>的理论（主要矛盾-&gt;任务）</p><p>生产力是社会发展的最根本的决定性因素，社会主义的<strong>根本任务</strong>是发展生产力。</p><p>（矛盾：人民日益增长的物质文化需要和落后的生产力之间的矛盾）</p><blockquote><p>辨析：总任务和根本任务</p><p>新时代的<strong>总任务</strong>：中华民族的伟大复兴和实现社会主义现代化强国。</p></blockquote></li><li><p>“三步走”战略</p><p><em>党的十三大把邓小平“三步走”的发展战略构想确定下来</em> </p><ol><li>第一步，从1981年到1990年实现国民生产总值比1980年翻一番，解决人民的温饱问题</li><li>第二步，从1991年到20世纪末，使国民生产总值再翻一番，达到小康水平。</li><li>第三步，到21世纪中叶，国民生产总值再翻两番，达到中等发达国家水平，<strong>基本</strong>实现现代化。</li></ol><blockquote><p>辨析现在的战略：</p><ol><li>到2035年，基本实现现代化。</li><li>到20世纪中叶，实现现代化强国。</li></ol></blockquote></li><li><p>改革开放理论</p><ul><li><p>改革的性质（改革是什么）：改革是社会主义制度的自我完善和发展。</p><p>（完整论述如下）</p><p><em>改革作为一次新的革命，<strong>不是也不允许否定和抛弃我们建立起来的社会主义基本制度</strong>，<strong>它是社会主义制度的自我完善和发展</strong>。改革不是一个阶级推翻另一个阶级那种原来意义上的革命，也不是原有经济体制的细枝末节的修补，而是<strong>对体制的根本性变革</strong>。他的实质和目标，是要从根本上改变束缚我国生产力发展的经济体制，建立充满生机和活力的社会主义新经济体制，同时相应地改革政治体制和其他方面的体制，以实现中国的社会主义现代化。</em> </p><blockquote><p>改革开放理论：不允许否定社会主义基本制度，是对体制的根本变革。</p><p>社会主义制度是完善，而体制是根本变革。</p></blockquote></li><li><p>改革是社会主义社会发展的直接（重要）动力</p><blockquote><p>社会主义发展的根本动力：基本矛盾，仍然是生产关系和生产力、上层建筑和经济基础之间的矛盾。</p></blockquote></li><li><p>判断改革和各方面工作是非得失（判断标准）</p><ol><li>（生产力）是否有利于发展社会主义社会的生产力</li><li>（综合国力）是否有利于增强社会主义国家的综合国力</li><li>（生活水平）是否有利于提高人民的生活水平</li></ol></li><li><p>对外开放的要求</p><ol><li><p>开发的范围：</p><blockquote><p>邓小平理论中改革开放的格局：全方位、宽领域、多层次</p></blockquote><ul><li>（全方位）包括对发达国家的开发，也包括对发展中国家对开发，是对世界所有国家的开发。</li><li>（宽领域）不仅是经济领域的开发，还包括科技、教育、文化等领域的开发。</li><li>（多层次）</li></ul></li><li><p>学习的内容：</p><ul><li>实行对外开放要正确对待资本主义社会创造的现代文明成果。</li></ul></li><li><p>开放的原则：</p><ul><li>对外开放要高度珍惜并坚决维护中国人民经过长期奋斗得来的<strong>独立自主权利</strong></li></ul></li></ol></li><li><p>改革开放是决定当代中国命运的关键抉择，<strong>是当代中国发展进步的活力之源</strong>，是党和人民事业大踏步赶上时代的重要法宝，是坚持和发展中国特色社会主义、<strong>实现中华民族伟大复兴的必由之路</strong>。</p></li></ul></li><li><p>社会主义市场经济理论</p><ul><li><p>改革开放后的一个很长时期内，我国<strong>经济体制改革的核心问题</strong>：如何正确认识和处理计划与市场（政府与市场）的关系。</p></li><li><p><strong>党的十四大</strong>：确立了建设社会主义<strong>市场经济体制的改革目标</strong></p><p><em>党的十四大根据给个开放实践发展的要求和邓小平关于社会主义也可以搞市场经济的思想，特别是南方谈话的精神，确立了建设社会主义市场经济体制的改革目标。</em></p></li><li><p>社会主义经济理论的要点：</p><ol><li>计划经济和市场经济不是划分社会主义制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义。</li><li>计划和市场都是<strong>经济手段</strong>，对经济活动的调节各有优势和长处，社会主义实行市场经济要把两者结合起来。</li><li>市场经济作为资源配置的一种方式本身不具有制度属性，可以和不同的社会制度结合起来，从而表现出不同的性质。坚持社会主义制度与市场经济的结合，是社会主义市场经济的特色所在、优势所在。</li></ol><blockquote><p>社会主义是制度，是性质。</p><p>计划经济和市场经济是体制，是手段。</p><p>但当市场经济和社会主义结合起来后，变成社会主义市场经济，就和纯粹的市场经济有所不同。</p></blockquote></li></ul></li><li><p><em>“两手抓，两手都要硬”</em></p><p><em>一手抓物质文明，一手抓精神文明。</em> </p></li><li><p>“一国两制”</p><ul><li>“和平统一、一国两制”构想的基本<strong>内容</strong>：<ol><li>坚持一个中国，这是“和平统一、一国两制”的核心，是发展两岸关系和实现和平统一的基础。</li><li>两制并存，在祖国统一的前提下，国家的主体部分实行社会主义制度，同时在台湾、香港、澳门保持原有的社会制度和生活方式长期不变。</li><li>高度自治，祖国完全统一，台湾、香港、澳门作为特别行政区，享有不同于中国其他省、市、自治区的高度自治权，台湾、香港、澳门同胞各种合法权益将得到切实尊重和维护。</li><li>尽最大努力争取和平统一，但不承诺放弃使用武力。</li><li>解决台湾问题，实现祖国统一，寄希望于人民。</li></ol></li><li>：一国两制“伟大构想的提出是从解决台湾问题开始的，台湾问题是国内战争遗留下来的问题，属于中国的内政，不容许外国干涉。</li><li>”一国两制“伟大构想是在实践中首先运用与解决香港问题、澳门问题。</li></ul></li><li><p><em>中国问题的关键在于党</em> </p></li></ol><h3 id="邓小平理论的历史地位"><a href="#邓小平理论的历史地位" class="headerlink" title="邓小平理论的历史地位"></a>邓小平理论的历史地位</h3><ol><li>马克思列宁主义、毛泽东思想的基础和发展</li><li>中国特色社会主义理论体系的开篇之作</li><li>改革开放和社会主义现代化建设的科学指南</li></ol><h2 id="”三个代表“重要思想"><a href="#”三个代表“重要思想" class="headerlink" title="”三个代表“重要思想"></a>”三个代表“重要思想</h2><h3 id="30-”三个代表“重要思想的形成条件"><a href="#30-”三个代表“重要思想的形成条件" class="headerlink" title="30.”三个代表“重要思想的形成条件"></a><em>30.”三个代表“重要思想的形成条件</em></h3><ol><li>”三个代表“重要思想是在对冷战结束后国际局势科学判断的基础上形成的</li><li>”三个代表“重要思想是在科学判断党的历史方位和总结历史经验的基础上提出来的 </li><li>”三个代表“重要思想是在建设中国特色社会主义伟大实践的基础上形成的</li></ol><h3 id="31-“三个代表”重要思想形成的过程"><a href="#31-“三个代表”重要思想形成的过程" class="headerlink" title="31.“三个代表”重要思想形成的过程"></a><em>31.“三个代表”重要思想形成的过程</em></h3><p><em>江泽民指出：“我提出这个问题，是经过长时期思考的。在实行改革开放和发展社会主义市场经济的条件下，<strong>‘建设一个什么样的党，怎样建设党’</strong>，是一个重大的现实问题，直接关系到我们党的和国家的前途命运。</em> </p><ul><li>（写入党章）十六大：将“三个代表”重要思想与马克思列宁主义、毛泽东思想和邓小平理论一道确立为党必须长期坚持的指导思想，并写入党章。</li></ul><h3 id="32-“三个代表”重要思想的核心观点"><a href="#32-“三个代表”重要思想的核心观点" class="headerlink" title="32.“三个代表”重要思想的核心观点"></a><em>32.“三个代表”重要思想的核心观点</em></h3><p><em>”中国共产党必须始终代表中国先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益。“这是对“三个代表“重要思想的集中概括。</em>  </p><ol><li>始终代表中国先进生产力的发展要求</li><li>始终代表中国先进文化的前进方向</li><li>始终代表中国最广大人民的根本利益</li></ol><h3 id="33-“三个代表”重要思想的主要内容"><a href="#33-“三个代表”重要思想的主要内容" class="headerlink" title="33.“三个代表”重要思想的主要内容"></a>33.“三个代表”重要思想的主要内容</h3><ol><li><p>发展是党执政兴国的第一要务</p></li><li><p>建设社会主义<strong>市场</strong>经济体制</p><ul><li><p>所有制：</p><ul><li><p>建设社会主义市场经济体制，必须坚持和完善公有制为主体、多种所有制经济共同发展的<strong>社会主义基本经济制度</strong>。</p></li><li><p>必须毫不动摇鼓励、支持和引导<strong>非公有制经济发展。</strong></p></li><li><p>个体、私营等各种形式的非公有制经济是社会主义<strong>市场</strong>经济的重要组成部分，对充分调动社会各方面的积极性、加快生产力发展具有重要作用。</p><blockquote><p>所有制上：社会主义经济是公有制，资本主义经济是私有制。</p><p>而中国特色社会主义的特色所在，为既有公有制，又有私有制，是<strong>社会主义市场经济</strong>（不是单纯的社会主义经济）。</p><table><thead><tr><th></th><th>社会主义社会</th><th>中国特色社会主义社会</th><th>资本主义社会</th></tr></thead><tbody><tr><td>所有制</td><td>公有制</td><td>公有制+私有制</td><td>私有制</td></tr><tr><td>分配制</td><td>按劳分配</td><td>按劳分配+按要素分配</td><td>按要素分配</td></tr><tr><td>政治</td><td>专政</td><td>人民民主专政</td><td>民主</td></tr></tbody></table></blockquote></li><li><p>进一步探索公有制特别是国有制的<strong>多种有效实现形式</strong>。</p><blockquote><p>所有制的实现形式：有单一制和混合制，这里指混合制，公有制和私有制都有。</p></blockquote><p><em>大力推进企业的体制、技术和管理创新，积极推行股份所有制，按照“产权清晰、权责明确、政企分开、管理科学”的要求，实行规范的公司制改革，完善法人治理结构，建立符合市场经济规律和我国国情的企业领导体制和管理制度。</em></p></li></ul></li><li><p>分配制：完善按劳分配为主体、多种分配方式并存的分配制度。</p></li><li><p>建立和完善社会保障体系。</p><p><em>要建立健全同经济发展水平相适应的社会保障体系，完善城镇职工基本养老保险制度和基本医疗保险制度，完善失业保险制度和城市居民最低生活保障制度，探索建立农村养老、医疗保险和最低生活保障制度。</em> </p></li></ul></li><li><p>全面建设小康社会（小小三步）</p><blockquote><p>考点：重点在新时代的两步走和邓小平的大三步</p><p>邓小平的大三步的最后一步，“三个代表”重要思想将其切为小三步。</p></blockquote><p>党的十五大报告中初步勾画了实现第三步战略目标的蓝图（五十年）：</p><ol><li>（十年）21世纪第一个十年实现国民生产总值比2000年翻一番</li><li>（十年）再经过十年的努力，到建党一百年时，使国民经济更加发展，各项制度更加完善</li><li>（三十年）到21世纪中叶新中国成立一百年时，基本实现现代化，建成富强民主文明的社会主义国家。</li></ol></li><li><p>建设社会主义<strong>政治文明</strong></p><p><em>党的十六大报告中，江泽民把社会主义物质文明、政治文明、精神文明一起确立为社会主义现代化全面发展的三大基本目标</em>  </p><ul><li><p>依法治国的<strong>内涵</strong>：就是<strong>广大人民群众在党的领导</strong>下，依照<strong>宪法和法律规定</strong>，通过各种途径和形式<strong>管理国家事务，管理经济文化事业，管理社会事务</strong>，保证国家各项工作都依法进行，逐步实现社会主义民主的制度化、法律化，使这种制度和法律不因领导人的改变而改变，不因领导人看法和注意力的改变而改变。</p><ul><li>主体：党领导下的人民群众</li><li>依据：宪法和法律法规</li><li>客体：管理国家事务，管理经济文化事业，管理社会事务</li><li>目标：…</li></ul></li><li><p>依法治国的<strong>意义</strong>：党领导人民治理国家的基本方略，是发展社会主义市场经济的客观需求，是社会文明进步的重要标志，是国家长治久安的<strong>重要保障</strong>。 </p><blockquote><p>总结：一般来说</p><p>根本保证：党的领导</p><p>重要保障：依法治国</p><p>战略支撑：国防军队</p></blockquote></li></ul></li><li><p>推进党的建设新的伟大工程</p></li></ol><h3 id="34-“三个代表”重要思想的历史地位"><a href="#34-“三个代表”重要思想的历史地位" class="headerlink" title="34.“三个代表”重要思想的历史地位"></a>34.“三个代表”重要思想的历史地位</h3><blockquote><p>历史地位即评价</p></blockquote><ol><li>中国特色社会主义理论体系的接续发展</li><li>加强和改进党的建设，推进中国特色社会主义事业的强大理论武器</li></ol><h2 id="科学发展观"><a href="#科学发展观" class="headerlink" title="科学发展观"></a>科学发展观</h2><h3 id="35-科学发展观的形成条件"><a href="#35-科学发展观的形成条件" class="headerlink" title="35.科学发展观的形成条件"></a><em>35.科学发展观的形成条件</em></h3><ol><li>（21世纪）科学发展观是在深刻把握我国基本国情和新的阶段性特征的基础上形成和发展的</li><li>科学发展观是在深入总结改革开放以来特别是党的十六大以来实践经验的基础上形成和发展的</li><li>科学发展观是在深刻分析国际形势、顺应世界发展趋势、借鉴外国发展经验的基础上形成和发展的</li></ol><h3 id="36-科学发展观的形成过程"><a href="#36-科学发展观的形成过程" class="headerlink" title="36.科学发展观的形成过程"></a><em>36.科学发展观的形成过程</em></h3><ul><li>十七大：<ul><li>提出了“中国特色社会主义理论体系”的科学概念。</li><li>把科学发展观与邓小平理论、“三个代表”重要思想一道作为中国特色社会主义理论体系的重要组成部分</li><li>并把科学发展观与马克思列宁主义、毛泽东思想、邓小平理论和“三个代表“重要思想一道写入党章。</li></ul></li><li>十八大：将科学发展观作为党的指导思想</li></ul><blockquote><p>总结：中国特色社会主义</p><p>十二大：“中国特色社会<strong>主义</strong>”成为我们党的全部理论和实践创新主题</p><p>十三大：第一次对”中国特色社会<strong>主义理论</strong>“的主要内容做了系统概括</p><p>十七大：提出了“中国特色社会<strong>主义理论体系</strong>”的科学概念</p></blockquote><h3 id="37-科学发展观的科学内涵"><a href="#37-科学发展观的科学内涵" class="headerlink" title="37.科学发展观的科学内涵"></a><em>37.科学发展观的科学内涵</em></h3><p><em>科学发展观，第一要义是发展，核心立场是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾。</em> </p><blockquote><p>考：戴帽子</p></blockquote><ol><li>推动经济社会<strong>发展</strong>是科学发展观的<strong>第一要义</strong></li><li><strong>以人为本</strong>是科学发展观的<strong>核心立场</strong></li><li><strong>全面协调可持续</strong>是科学发展观的<strong>基本要求</strong></li><li><strong>统筹兼顾</strong>是科学发展观的<strong>根本方法</strong></li></ol><h3 id="38-科学发展观的主要内容"><a href="#38-科学发展观的主要内容" class="headerlink" title="38.科学发展观的主要内容"></a><em>38.科学发展观的主要内容</em></h3><ol><li><p>加快转变经济发展方式</p></li><li><p>发展社会主义民主政治</p></li><li><p>推进社会主义文化强国建设</p></li><li><p>构建社会主义和谐社会</p><ul><li><p>构建社会主义和谐社会的<strong>总要求</strong>：人与自然和谐相处、民主法治、公平正义、安定有序、充满活力、诚信友爱</p><blockquote><p>谐音：人民公安充满爱</p></blockquote></li></ul></li><li><p>推进生态文明建设</p></li><li><p>全面提高党的建设科学化水平</p></li></ol><h3 id="39-科学发展观的重要意义"><a href="#39-科学发展观的重要意义" class="headerlink" title="39.科学发展观的重要意义"></a>39.科学发展观的重要意义</h3><blockquote><p>评价</p></blockquote><ol><li>中国特色社会主义理论体系的接续发展</li><li>发展中国特色社会主义必须长期坚持的指导思想</li></ol><h2 id="习近平新时代中国特色社会主义思想"><a href="#习近平新时代中国特色社会主义思想" class="headerlink" title="习近平新时代中国特色社会主义思想"></a>习近平新时代中国特色社会主义思想</h2><h3 id="40-新时代的内涵和意义"><a href="#40-新时代的内涵和意义" class="headerlink" title="40.新时代的内涵和意义"></a><em>40.新时代的内涵和意义</em></h3><ul><li><p>经过长期努力，中国特色社会主义进入新时代，这是我国发展新的<strong>历史方位</strong>。</p><p><em>这个新时代，是中国特色社会主义新时代，而不是别的什么新时代。</em> </p><blockquote><p>历史方位变了，但历史阶段没变，仍然是社会主义初级阶段</p></blockquote></li><li><p>新时代的内涵</p><ol><li>（时代节点）这个新时代是承前启后、继往开来，在新的历史条件下继续夺取中国特色社会主义伟大胜利的新时代。</li><li>（小康社会、现代化强国）这个新时代是决胜全面建成小康社会、进而全面建设社会主义现代化强国的时代。</li><li>（全体人民）这个新时代是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代。</li><li>（中华民族）这个新时代是全体中华儿女戮力同心、奋力实现中华民族伟大复兴中国梦的时代。</li><li>（国际、人类）这个新时代是我国日益走进世界舞台中央、不断为人类作出更大贡献的时代。</li></ol></li><li><p>新时代的意义</p><ol><li>第一，从<strong>中华民族复兴的历史进程</strong>来看，中国特色社会主义进入新时代，意味着近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来到伟大飞跃，迎来了实现中华民族伟大复兴的光明前景。</li><li>第二，从<strong>科学社会主义发展进程</strong>来看，中国特色社会主义进入新时代，意味着科学社会主义在21世纪的中国焕发出强大的生机活力，在世界上高高举起了中国特色社会主义伟大旗帜。</li><li>第三，从<strong>人类文明进程</strong>来看，中国特色社会主义进入新时代，意味着中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献了中国智慧和中国方案。</li></ol></li></ul><h3 id="41-社会主要矛盾的变化及其依据"><a href="#41-社会主要矛盾的变化及其依据" class="headerlink" title="41.社会主要矛盾的变化及其依据"></a>41.社会主要矛盾的变化及其依据</h3><blockquote><p>我国在社会主义改造后，即1956年，进入社会主义初级阶段。</p><p>三个时期提出了不同的主要矛盾论述。</p></blockquote><ul><li><p>1956年社会主义改造基本完成后，<strong>党的八大</strong>指出：我们国内的主要矛盾</p><ol><li><strong>已经是人民对于建立先进工业国的要求同落后的农业国的现实之间的矛盾，</strong></li><li><strong>已经是人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾</strong> </li></ol></li><li><p>1981年<strong>十一届六中全会</strong>通过的《历史决议》对我国主要矛盾作了科学表述：</p><p>在社会主义改造基本完成以后，我国所要解决的主要矛盾，是<strong>人民日益增长的物质文化需要同落后的社会生产之间的矛盾</strong></p></li><li><p>党的<strong>十九大</strong>明确指出，我国社会主要矛盾已经转化为</p><p><strong>人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾</strong> </p><ul><li>主要依据：<ol><li>经过改革开放40年的发展，我国社会生产力水平总体显著提高，很多方面进入世界前列。</li><li>（综合需求）人民生活水平显著提高，对美好生活的向往更加强烈，不仅对物质文化提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长。</li><li>影响满足人民美好生活需要的因素很多，但主要是发展的不平衡不充分问题</li></ol></li></ul></li><li><p>我国社会主要矛盾的变化，没有改变我们对我国社会主义所处<strong>历史阶段</strong>的判断。</p><blockquote><p>历史阶段没有变，历史方位变了。</p></blockquote><ol><li>我国仍处于并长期处于社会主义初级阶段的<strong>基本国情没有变</strong></li><li>我国是世界最大发展中国家的<strong>国际地位没有变</strong></li></ol></li></ul><h3 id="42-习近平新时代中国特色社会主义思想的主要内容"><a href="#42-习近平新时代中国特色社会主义思想的主要内容" class="headerlink" title="42.习近平新时代中国特色社会主义思想的主要内容"></a>42.习近平新时代中国特色社会主义思想的主要内容</h3><p><em>习近平新时代中国特色社会主义思想是党和人民实践经验和集体智慧的结晶，其主要创立者是习近平。</em> </p><ul><li><p><strong>坚持和发展中国特色社会主义</strong>，是改革开放以来我们党全部理论和实践的<strong>鲜明主题</strong>，也是习近平新时代中国特色社会主义思想的<strong>核心要义</strong>。</p><p><em>历史已经并将继续证明，只有社会主义才能救中国，只有坚持和发展中国特色社会主义才能实现中华民族伟大复兴。</em> </p><ul><li>党的全部理论和实践的鲜明主题：坚持和发展中国特色社会主义</li><li>习近平新时代中国特色社会主义思想的核心要义：坚持和发展中国特色社会主义</li></ul></li></ul><p><em>”八个明确“和“十四个坚持“体现了习近平新时代中国特色社会主义思想理论和实践的统一</em> </p><blockquote><p>不一定要一字不拉的背下，而是作为分析题的材料，记住一部分。</p></blockquote><ul><li><p>党的十九大概括“八个明确”——习近平新时代中国特色社会主义<strong>思想内涵</strong>。</p><ul><li>“八个明确”：指导思想层面的表述，重点讲是怎么看<ul><li>回答：新时代坚持和发展什么样的中国特色社会主义的问题</li></ul></li></ul><ol><li><p>明确坚持和发展中国特色社会主义，<strong>总任务</strong>是实现社会主义现代化和中华民族伟大复兴，</p><p>在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国。</p></li><li><p>明确新时代我国社会<strong>主要矛盾</strong>是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，</p><p>必须坚持以人民为中心的发展思想，不断促进人的全面发展、全体人民共同富裕。</p></li><li><p>明确中国特色社会主义事业<strong>总体布局</strong>是“五位一体”、<strong>战略布局</strong>是“四个全面”，</p><p>强调坚定道路自信、理论自信、制度自信、文化自信。</p></li><li><p>明确<strong>全面深化改革的总目标</strong>是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化。</p></li><li><p>明确全面推进<strong>依法治国的总目标</strong>是建设中国特色社会主义法治体系、建设社会主义法治国家。</p></li><li><p>明确党在新时代的<strong>强军目标</strong>是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队。</p></li><li><p>明确中国特色<strong>大国外交</strong>要推动构建新型国际关系，推动构建人类命运共同体。</p></li><li><p>明确中国特色社会主义<strong>最本质的特征</strong>是中国共产党领导，中国特色社会主义制度的<strong>最大优势</strong>是中国共产党的领导，</p><p>党是最高政治领导力量，提出新时代党的建设总要求，突出政治建设在党的建设中的重要地位。</p></li></ol></li><li><p>党的十九大概括为”十四个坚持“，即新时代中国特色社会主义<strong>基本方略</strong>。</p><ul><li>“十四个坚持”：行动纲领层面的表述，重点讲是怎么办<ul><li>回答：新时代怎样坚持和发展中国特色社会主义的问题</li></ul></li></ul><ol><li><p>（领导核心）坚持党对一切工作的领导。</p></li><li><p>（主体）坚持以人民为中心。</p><p><em>人民是历史的创造者，是决定党和国家前途命运的根本力量。</em> </p></li><li><p>（改革）坚持全面深化改革。</p><p><em>只有社会主义才能救中国，只有改革开放才能发展中国、发展社会主义、发展马克思主义。</em> </p></li><li><p>（经济）坚持新发展理论。</p></li><li><p>（政治）坚持人民当家作主。</p></li><li><p>（政治）坚持全面依法治国。</p><p><em>全面依法治国是中国特色社会主义的本质要求和<strong>重要保障</strong>。</em> </p><blockquote><p>总结：</p><p>根本保证：选党的领导。</p><p>重要保障：选依法治国。</p><p>战略支撑：选军队国防。</p></blockquote></li><li><p>（文化）坚持社会主义核心价值体系。</p><p><em>文化自信是一个国家、一个民族发展中<strong>更基本</strong>、更深层、更持久的力量。</em> </p><blockquote><p>文化自信是根本</p></blockquote></li><li><p>（社会民生）坚持在发展中保障和改善民生。</p></li><li><p>（生态）坚持人和自然和谐共生。</p></li><li><p>（安全）坚持总体国家安全观。</p></li><li><p>（战略支撑）坚持党对人民军队的绝对领导</p><p><em>建设一支听党指挥、能打胜仗、作风优良的人民军队，是实现“两个一百年”奋斗目标、实现中华民族伟大复兴的<strong>战略支撑</strong>。</em> </p></li><li><p>（一国两制）坚持“一国两制”和推进祖国统一。</p><p><em>保持香港、澳门长期繁荣稳定，实现祖国完全统一，是实现中华民族伟大复兴的必然要求。必须把维护中央对香港、澳门特别行政区全面管治权和保障特别行政区高度自治权有机结合起来。</em> </p></li><li><p>（外交）坚持推动构建人类命运共同体。</p></li><li><p>（党建）坚持全面从严治党。</p></li></ol></li></ul><h3 id="43-习近平新时代中国特色社会主义思想的重要意义"><a href="#43-习近平新时代中国特色社会主义思想的重要意义" class="headerlink" title="43.习近平新时代中国特色社会主义思想的重要意义"></a>43.习近平新时代中国特色社会主义思想的重要意义</h3><blockquote><p>评价</p></blockquote><ol><li><p>马克思主义中国化的<strong>最新成果</strong> </p><p><em>习近平新时代中国特色社会主义思想与马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观既一脉相承又与时俱进，是马克思主义中国化的新飞跃，是当代中国马克思主义、21世纪马克思主义。</em> </p><ul><li>为什么：<ol><li>习近平新时代中国特色社会主义思想开辟了马克思主义新境界。</li><li>习近平新时代中国特色社会主义思想开辟了中国特色社会主义新境界。</li><li>习近平新时代中国特色社会主义思想对人类文明进步具有重要意义。</li></ol></li></ul></li><li><p>新时代的精神旗帜</p><ul><li>党的十九大：通过党章修正案，将习近平新时代中国特色社会主义思想确立为党的指导思想。</li><li>十三届全国人大一次会议：把这一思想载入宪法。</li></ul></li><li><p>实现中华民族伟大复兴的<strong>行动指南</strong> </p><blockquote><p>考：习近平新时代中国特色社会主义思想是根本指引，是根本遵循，是思想武器。</p><p>思想，不能作为根本途径（中国特色社会主义道路）或者根本保证（党的领导）。</p></blockquote><p><em>习近平新时代中国特色社会主义思想是党和国家必须长期坚持的指导思想。</em> </p><ol><li>习近平新时代中国特色社会主义思想，是党的意志、国家的意志和人民意志的集中体现，为新时代坚持和发展中国特色社会主义提供了<strong>根本指引</strong>。</li><li>习近平新时代中国特色社会主义思想为新时代治国理政提供了<strong>根本遵循</strong>。</li><li>习近平新时代中国特色社会主义思想为全面从严治党、把党建设成为中国特色社会主义事业的坚强领导核心提供了强大的<strong>思想武器</strong>。</li></ol></li></ol><h3 id="44-实现中华民族伟大复兴的中国梦"><a href="#44-实现中华民族伟大复兴的中国梦" class="headerlink" title="44.实现中华民族伟大复兴的中国梦"></a>44.实现中华民族伟大复兴的中国梦</h3><ul><li><p>坚持和发展中国特色社会主义的<strong>总任务</strong>：是<strong>实现社会主义现代化和中华民族伟大复兴</strong>，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国。</p><ul><li><p>中特社会主义的总任务（简述）：实现社会主义现代化强国和中华民族伟大复兴。</p><blockquote><p>辨析：</p><p>邓小平思想中，中特社会的根本任务是：发展生产力。</p></blockquote></li><li><p><strong>中国梦</strong>是中华民族伟大复兴的形象表达。</p></li></ul></li><li><p>中国梦的<strong>科学内涵</strong> ：<strong>国家富强、民族振兴、人民幸福</strong> </p><ul><li><p>中国梦的本质是：<strong>国家富强、民族振兴、人民幸福</strong></p><blockquote><p>考：戴帽子</p></blockquote><ol><li><p><strong>国家富强、民族振兴</strong>是人民幸福的<strong>基础和保障</strong>。</p><p><em>中国近代以来的屈辱历史已经证明，民族不独立、国家不富强，人民的生存根本得不到保证，更谈不上人民幸福。</em></p></li><li><p><strong>人民幸福</strong>是国家富强、民族振兴的<strong>题中之义和必然要求</strong>。</p><p><em>民为邦本、本固邦宁，国家的富强、民族的振兴都要以人民的权利得到保障、利益得到实现、幸福得到满足为条件。</em> </p></li><li><p><strong>人民幸福</strong>是国家富强、民族振兴的<strong>根本出发点和落脚点</strong>。</p></li></ol></li></ul></li><li><p><em>中国梦的伟大意义</em></p><ol><li>中国梦归根到底是人民的梦。</li><li>中国梦是国家的梦、民族的梦，也是每一个中国人的梦。</li><li>中国梦与世界各国人民的美好梦想相通。</li></ol></li><li><p>中国梦的实现？（怎么做）</p><blockquote><p>考：</p><p>问怎么做？不是问你个人的观点，而是站在国家领导人的角度，站在国家的角度，会怎么做？</p><p>顶层的抽象的设计，再加以展开。（材料：十四个坚持，八个明确）</p></blockquote><ol><li>实现中国梦必须走中国道路，这就是中国特色社会主义道路。</li><li>实现中国梦必须弘扬中国精神，这就是以爱国主义为核心的民族精神和以改革创新为核心的时代精神。</li><li>实现中国梦必须凝聚中国力量，这就是全国各族人民大团结的力量。</li></ol></li></ul><h3 id="45-建成社会主义现代化强国的战略安全"><a href="#45-建成社会主义现代化强国的战略安全" class="headerlink" title="45.建成社会主义现代化强国的战略安全"></a>45.建成社会主义现代化强国的战略安全</h3><ol><li><p>开启全面建设社会主义现代化强国的新征程</p><ul><li><p><strong>“两个一百年”的奋斗目标</strong>，即到建党100年时建成惠及十几亿人口的<strong>更高水平的小康社会</strong>；即到新中国成立100年时基本实现现代化，<strong>建成社会主义现代化强国</strong>。</p><p><em>习近平在党的十九大报告中提出，我们要全面建成小康社会，实现第一个百年奋斗目标，然后在乘势而上开启全面建设社会主义现代化国家新征程，向第二个百年奋斗目标进军。</em> </p></li><li><p>全面建设社会主义现代化国家的进程<strong>分两个阶段</strong></p><blockquote><p>新两步，也是江泽民小三步中的最后一步的30年。</p></blockquote><ol><li>第一个阶段，从2020年到2035年，在全面建成小康社会的基础上，再奋斗15年，<strong>基本实现</strong>社会主义现代化。</li><li>第二个阶段，从2035年到本世纪中叶，在基本实现现代化的基础上，再奋斗15年，把我国<strong>建成</strong>富强民主文明和谐美丽的社会主义现代化强国。</li></ol><blockquote><p>第一个阶段时基本实现现代化，相较于邓小平思想的第三步在21世纪中叶基本实现现代化提前15年。</p><p>区别：第一个阶段时基本实现，第二个阶段时建成。</p></blockquote></li></ul></li><li><p>从2020年到2035年，<strong>基本实现</strong>社会主义现代化的目标要求</p><blockquote><p>考：这15年，大多都是各方面都在提高，都是基本实现，模糊的说法，主要记明确的说法。</p></blockquote><ul><li><p>经济建设方面：各方面都提高</p><ul><li><p>跻身创新型国家<strong>前列</strong> </p><blockquote><p>2020年：创新型国家行列</p></blockquote></li><li><p>经济发展实现由数量和规模扩张向质量和效益提升的<strong>根本转变</strong></p></li></ul></li><li><p>政治建设方面：各方面都提高</p></li><li><p>文化建设方面：各方面都提高</p></li><li><p>民生和社会建设方面：各方面都提高</p><ul><li>我国进入高收入国家<strong>行列</strong></li></ul></li><li><p>生态文化建设方面：各方面提高</p><ul><li>生态环境<strong>根本好转</strong> </li></ul></li></ul></li><li><p>2035年到<strong>本世纪中叶</strong>，<strong>建成</strong>社会主义现代化强国目标</p><blockquote><p>考：这是15年大多都是实现，建成，主要记基本实现。</p></blockquote><ul><li><p>经济方面：我国将拥有高度的物质文明</p><ul><li>建成富强的社会主义现代化强国</li></ul></li><li><p>政治方面：我国将拥有高度的政治文明</p><ul><li>建成民主的社会主义现代化强国</li></ul></li><li><p>精神文化方面：我国将拥有高度的精神文明</p><ul><li>建成文明的社会主义现代化强国</li></ul></li><li><p>民生和社会建设方面：我国将拥有高度的社会文明</p><ul><li>全体人民共同富裕<strong>基本实现</strong></li><li>建成和谐的社会主义现代化强国</li></ul></li><li><p>生态文明方面：我国将拥有高度的生态文明</p><ul><li>建成美丽的社会主义现代化强国</li></ul></li></ul></li></ol><h1 id="总体布局：”五位一体“"><a href="#总体布局：”五位一体“" class="headerlink" title="总体布局：”五位一体“"></a>总体布局：”五位一体“</h1><blockquote><p>新时代中国特色社会主义怎么做的问题？</p></blockquote><h2 id="建设现代化经济体系：经济"><a href="#建设现代化经济体系：经济" class="headerlink" title="建设现代化经济体系：经济"></a>建设现代化经济体系：经济</h2><h3 id="46-贯彻新发展理念"><a href="#46-贯彻新发展理念" class="headerlink" title="46.贯彻新发展理念"></a><font color='red'>46.贯彻新发展理念</font></h3><p><em>党的十八届五中全会坚持以人民为中心的发展思想，鲜明提出了创新、协调、开发、绿色、共享新发展理念。</em> </p><p><em>新发展理念是中国共产党关于发展理论的重大升华，是习近平新时代中国特色社会主义<strong>经济思想</strong>的主要内容。</em> </p><ul><li>党的十八届五中全会坚持以人民为中心的发展思想，鲜明提出了创新、协调、绿色、开放、共享的新发展理念。<ul><li>创新注重的是解决<strong>发展动力问题</strong></li><li>协调注重的是解决<strong>发展不平衡问题</strong></li><li>绿色注重的是解决<strong>人与自然和谐问题</strong></li><li>开放注重的是解决<strong>发展内外联动问题</strong></li><li>共享注重的是社会公平正义问题</li></ul></li></ul><h4 id="创新"><a href="#创新" class="headerlink" title="创新"></a><font color='red'>创新</font></h4><ul><li><p>创新是引领发展的<strong>第一动力</strong> </p></li><li><p>创新的必要性：</p><ul><li>发展动力决定发展速度、效能、可持续性。坚持创新，是应对发展环境变化、增强发展动力、把握发展主动权，更好引领新常态的根本之策。</li><li>对我国这么大体量的经济体来讲，如果动力问题解决不好，要实现经济持续健康发展是难以做到的。抓住了创新，就抓住了牵动经济社会发展全局的关键。</li></ul></li><li><p>创新的要求：</p></li><li><p>坚持创新新发展，就是要把创新摆在国家发展全局的核心位置，不断推进理论创新、制度创新、科技创新、文化创新等各方面创新，让创新贯穿党和国家的一切工作，让创新在全社会蔚然成风。</p></li><li><p>措施（怎么做）：</p><ol><li><p>深入实施<strong>科教兴国战略、人才强国战略</strong>、创新驱动发展战略，努力实现到2035年跻身创新型国家前列的目标。</p></li><li><p>加强国家创新体系建设，强化战略科技力量，<strong>推动创新和经济社会发展深度融合</strong>，塑造更多依靠创新驱动、更多发挥先发优势的引领型发展。</p><blockquote><p>创新落地到应用中。</p></blockquote></li><li><p>强化<strong>基础研究、应用基础研究</strong>和战略科技力量，推动重大科技创新取得新进展。</p><blockquote><p>核心基础的研究，比如芯片、发动机。</p></blockquote></li><li><p>建立以<strong>企业为主体、市场为导向</strong>、产学研深度融合的技术创新体系，促进科技成果转化。</p></li><li><p>倡导创新文化，<strong>强化知识产权保护</strong>，提升大众创新、万众创业水平。</p></li><li><p>实行更加积极、更加开放、更加有效的人才政策，培养和造就一大批具有国际水平的<strong>人才</strong>和高水平创新团队。</p></li></ol></li></ul><h4 id="协调"><a href="#协调" class="headerlink" title="协调"></a>协调</h4><ul><li>协调是持续健康发展的<strong>内在要求</strong> </li><li>协调既是发展手段又是发展目标，同时还是评价发展的标准和尺度；协调发展既要着力破解难题、补齐短板，又要考虑巩固和厚植原有优势；协调发展不是搞平均主义，而是更注重发展机会公平、更注重资源配置均衡；协调发展就是要找出短板，在补齐短板上多用力，通过补齐短板挖掘发展潜力、增强发展后劲。</li><li>坚持协调发展，要着力推动<strong>区域</strong>协调发展、<strong>城乡</strong>协调发展、<strong>物质文化和精神文明</strong>协调发展，推动<strong>经济</strong>建设和<strong>国防</strong>建设融合发展。<ul><li>区域协调发展</li><li>城乡协调发展</li><li>物质文化和精神文明协调发展</li><li>经济建设和国防建设融合发展</li></ul></li></ul><h4 id="绿色"><a href="#绿色" class="headerlink" title="绿色"></a>绿色</h4><ul><li>绿色是永续发展的<strong>必要条件</strong></li></ul><h4 id="开放"><a href="#开放" class="headerlink" title=" 开放"></a><font color='red'> 开放</font></h4><ul><li><p>开放是国家繁荣发展的<strong>必由之路</strong> </p></li><li><p>开发的必要性：</p><ul><li><p>改革开放40年的实践启示我们：开放带来进步，封闭必然落后。</p></li><li><p>中国的发展离不开世界，世界的繁荣也需要中国。我们统筹国内国际两个大局，坚持对外开放的<strong>基本国策</strong>。 </p><blockquote><p>总结：</p><p>基本国策有：对外开放、一国两制、节约资源、保护环境</p></blockquote></li><li><p>实行积极主动的开放政策，形成<strong>全方位、多层次、宽领域</strong>的全面开放新<strong>格局</strong>，为我国创造了良好国际环境、开拓了广阔发展空间。</p></li><li><p>中国扩大开放的举措，是根据中国改革发展客观需要作出的自主选择，这有利于推动经济高质量发展，有利于满足人民对美好生活的向往，有利于世界和平、稳定、发展。</p></li></ul></li><li><p>开放发展的要求：</p><ul><li>开放就是要顺应经济全球化潮流，充分运用人类社会创造的先进科学技术成果和有益管理经验。</li><li>坚持开放发展，就要奉行<strong>互利共赢</strong>的开放战略，坚持内外需协调、进出口平衡、引进来和走出去<strong>并重</strong>、引资和引技<strong>并举</strong>，发展更高层的开放型经济，积极参与全球经济治理和巩固产品供给，提高我国在全球经济治理中的<strong>制度性话语权</strong>，构建广泛的利益共同体。</li></ul></li></ul><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a><font color='red'>共享</font></h4><ul><li><p>共享是中国特色社会主义的<strong>本质要求</strong> </p></li><li><p>共享的内涵：</p><ol><li><p>全民共享。</p><p>共享发展是人人享有、各得其所、不是少数人共享、一部分人共享。</p></li><li><p>全面共享。</p><p>共享发展就要共享国家经济、政治、文化、社会、生态文明各方面建设成果，全面保障人民在各方面的合法权益。</p></li><li><p>共建共享。</p><p>只有共建才能共享，共建的过程也是共享的过程。</p></li><li><p>渐进共享。</p><p>共享发展必将有一个从低级到高级、从不均衡到均衡到过程，即使达到很高的水平也会有差别。</p></li></ol></li></ul><h3 id="47-深化供给侧结构性改革"><a href="#47-深化供给侧结构性改革" class="headerlink" title="47.深化供给侧结构性改革"></a>47.深化供给侧结构性改革</h3><ul><li><p>贯彻新发展理念、建设现代化经济体系必须坚持供给侧结构性改革。</p><p>坚持质量第一、效益优先，以供给侧结构性改革<strong>为主线</strong>，推动经济发展质量变革、效率变革、动力变革，提高全要素生产率。</p><blockquote><p>以前经济不好时，政府通过刺激需求侧推动经济，需求侧就是让人花钱的一侧：</p><p>消费：让百姓花钱</p><p>投资：让政府花钱</p><p>出口：让外国人花钱</p><p>通过刺激需求侧推动经济发展的特点是：短期调控；关注经济总量增长。</p><p>但只刺激需求侧，经济体量是不健康的。</p><p>而供给侧结构改革，是改善生产要素、生产者、生产产业比例等，从供给的角度，特点是长期调控，关注经济结构。</p></blockquote><ol><li><p>推进<strong>增长动能转化</strong>，以加快发展先进制造业为重点全面提升实体经济。</p></li><li><p>深化要素市场配置改革，实现由以价取胜向<strong>以质取胜</strong>的转变。</p></li><li><p>加大<strong>人力资本</strong>培育力度，更加注重调动和保护人的积极性。</p></li><li><p>持续推进<strong>“三去一降一补”</strong>，优化市场供求结构。</p><p>坚持去产能、去库存、去杠杆、降成本、补短板、优化存量资源配置，扩大优质增量供给。</p><blockquote><p>产能，是我有生产的能力，但需求没有这么多，于是产能过剩。</p><p>杠杆，经济学名词，将接到的货币追加到用于投资的现有资金上，以小博大。</p></blockquote></li></ol></li></ul><h3 id="48-建设现代化经济体系及其主要任务"><a href="#48-建设现代化经济体系及其主要任务" class="headerlink" title="48.建设现代化经济体系及其主要任务"></a>48.建设现代化经济体系及其主要任务</h3><blockquote><p>考：</p><p>题目选项有两种，一种完全是书上原话，一种是改编书上原话。</p><p>对选项中，如果选项是很确定的表述，说死的表述，比如完全转向，已经形成，那就看书上是否有原话。</p><p>如果选项是含糊的表述，比如进一步提高，不断优化，一般正确。</p></blockquote><h4 id="1-提出背景"><a href="#1-提出背景" class="headerlink" title="1.提出背景"></a>1.提出背景</h4><p><em>中国特色社会主义进入新时代，需要建设现代化经济体系。</em> </p><h4 id="2-现代化经济体系的构成"><a href="#2-现代化经济体系的构成" class="headerlink" title="2.现代化经济体系的构成"></a>2.现代化经济体系的构成</h4><blockquote><p>六个体系，一个体制</p></blockquote><ol><li>要建设创新引领、协同发展的产业体系</li><li>要建设统一开放、竞争有序的市场体系</li><li>要建设体现效率、促进公平的收入分配体系</li><li>要建设彰显优势、协调联动的城乡区域发展体系</li><li>要建设资源节约、环境友好的绿色发展体系</li><li>要建设多元平衡、安全高效的全面开放体系</li><li>要建设充分发挥市场作用、更好发挥政府作用的经济体制。</li></ol><h4 id="3-建设现代化经济体系的主要任务"><a href="#3-建设现代化经济体系的主要任务" class="headerlink" title="3.建设现代化经济体系的主要任务"></a><font color='red'>3.建设现代化经济体系的主要任务</font></h4><blockquote><p>怎么建设现代化经济体系</p></blockquote><h5 id="第一，大力发展实体经济。"><a href="#第一，大力发展实体经济。" class="headerlink" title="第一，大力发展实体经济。"></a><font color='red'>第一，大力发展实体经济。</font></h5><blockquote><p>实体经济也是分析题热点。</p><p>实体经济，就是能做出实物的商品和服务。</p></blockquote><ul><li>实体经济是一国经济的立身之本，是财富创造的根本源泉，是国家强盛的重要支柱，是现代化经济体系的坚实基础。</li><li>推动资源要素向实体经济集聚、政策措施向实体经济倾斜、工作力量向实体经济加强，营造脚踏实地、勤劳创业、实业致富的发展环境和社会氛围。</li><li>必须不断推进工业现代化，强化实体经济吸引力和竞争力，加大重要领域改革力度，推动实现经济发展由数量和规模扩张向质量和效益提升转变。</li></ul><h5 id="第二，加快实施创新驱动发展策略。"><a href="#第二，加快实施创新驱动发展策略。" class="headerlink" title="第二，加快实施创新驱动发展策略。"></a><font color='red'>第二，加快实施创新驱动发展策略。</font></h5><blockquote><p>创新也是分析题热点。</p><p>前面有说创新的必要性和要求，这里是怎么做的问题。</p></blockquote><ol><li><p>深入实施<strong>科教兴国战略、人才强国战略</strong>、创新驱动发展战略，努力实现到2035年跻身创新型国家前列的目标。</p></li><li><p>加强国家创新体系建设，强化战略科技力量，<strong>推动创新和经济社会发展深度融合</strong>，塑造更多依靠创新驱动、更多发挥先发优势的引领型发展。</p><blockquote><p>创新落地到应用中。</p></blockquote></li><li><p>强化<strong>基础研究、应用基础研究</strong>和战略科技力量，推动重大科技创新取得新进展。</p><blockquote><p>核心基础的研究，比如芯片、发动机。</p></blockquote></li><li><p>建立以<strong>企业为主体、市场为导向</strong>、产学研深度融合的技术创新体系，促进科技成果转化。</p></li><li><p>倡导创新文化，<strong>强化知识产权保护</strong>，提升大众创新、万众创业水平。</p></li><li><p>实行更加积极、更加开放、更加有效的人才政策，培养和造就一大批具有国际水平的<strong>人才</strong>和高水平创新团队。</p></li></ol><h5 id="第三，激发各类市场主体活力。"><a href="#第三，激发各类市场主体活力。" class="headerlink" title="第三，激发各类市场主体活力。"></a>第三，激发各类市场主体活力。</h5><h5 id="第四，积极推进城乡区域协调发展。"><a href="#第四，积极推进城乡区域协调发展。" class="headerlink" title="第四，积极推进城乡区域协调发展。"></a>第四，积极推进城乡区域协调发展。</h5><h5 id="第五，着力发展开放型经济。"><a href="#第五，着力发展开放型经济。" class="headerlink" title="第五，着力发展开放型经济。"></a><font color='red'>第五，着力发展开放型经济。</font></h5><blockquote><p>分析题热点</p></blockquote><ol><li><p>提高现代化经济体系的国际竞争力，更好利用全球资源和市场，继续积极推进<strong>“一带一路</strong>”框架下的国际交流合作。</p></li><li><p>要在开放的范围和层次上进一步拓展，更要在开放的思想观念、结构布局、体制机制上进一步拓展。</p><p>有序放宽市场准入，全面实行准入前国民待遇加<strong>负面清单</strong>管理模式，继续<strong>精简</strong>负面清单，抓紧完善外资相关法律，<strong>加强知识产权保护</strong>。</p><blockquote><p>负面清单：上面的事情不能做，其他都能做。</p><p>精简负面清单，更开放。</p></blockquote></li><li><p>促进贸易平衡，更加注重提升出口质量和附加值，积极扩大进口，<strong>下调</strong>部分产品进口关税。大力发展服务贸易。继续推进自由贸易试验区改革试点。有效引导支持对外投资。</p><blockquote><p>出口：是把我们的东西卖给别人，是赚钱。</p><p>进口：是去买别人的东西，是花钱。</p><p>出口&gt; 进口，是贸易顺差。</p><p>我国长期处在贸易顺差，因此要平衡，所以要鼓励进口，下调进口关税。</p></blockquote></li></ol><h5 id="第六，加快完善社会主义市场经济体制。"><a href="#第六，加快完善社会主义市场经济体制。" class="headerlink" title="第六，加快完善社会主义市场经济体制。"></a>第六，加快完善社会主义市场经济体制。</h5><blockquote><p>现代化经济体系的相关战略</p></blockquote><h4 id="4-实施乡村振兴战略"><a href="#4-实施乡村振兴战略" class="headerlink" title="4.实施乡村振兴战略"></a>4.实施乡村振兴战略</h4><ul><li><p>实施乡村振兴战略的<strong>目标要求</strong>：</p><ul><li><strong>总目标</strong>是加快推进农业现代化</li><li><strong>总方针</strong>是坚持农业农村优先发展</li><li><strong>总要求</strong>是产业兴旺、生态宜居、乡风文明、治理有效、生活富裕</li><li><strong>制度保障</strong>是建立健全城乡融合发展体制机制和政策体系</li></ul></li><li><p>乡村振兴战略的<strong>具体举措</strong>：</p><ul><li><p>巩固和完善<strong>农村基本经营制度</strong>，深化农村土地制度改革，完善承包地<strong>“三权“分置</strong>制度。保持土地承包关系稳定并长久不变，第二轮土地承包到期后再延长30年。</p><blockquote><p>农村基本经营制度是乡村振兴战略的基石。</p><p>三权，是所有权（国家）、承包期（农民）和经营权（公司）。</p></blockquote></li><li><p>深化农村集体产权制度改革，保障农村财产权益，壮大集体经济。</p></li><li><p>确保国家粮食安全，把中国人的饭碗牢牢端在自己手中。</p></li><li><p>构建现代农业产业体系、生产体系、经营体系，健全农业社会化服务体系，实现小农弄和现代农业发展有机衔接。</p></li><li><p>促进农村一二三产业融合发展，健全自治、法治、德治相结合的乡村治理体系。</p></li></ul></li></ul><h4 id="5-坚持和完善社会主义基本经济制度"><a href="#5-坚持和完善社会主义基本经济制度" class="headerlink" title="5.坚持和完善社会主义基本经济制度"></a>5.坚持和完善社会主义基本经济制度</h4><ul><li>党的十九届四中全会提出：<strong>公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制</strong>等<strong>社会主义基本经济制度</strong> ，既体现了社会主义制度优越性，又同我国社会主义初级阶段社会生产力发展水平相适应，是党和人民的伟大创造。</li></ul><ol><li><p>所有制层面：</p><ul><li><p>必须坚持<strong>“两个毫不动摇”</strong>，即毫不动摇 巩固和发展 公有制经济，毫不动摇 鼓励、支持、引导 非公有制经济发展。</p></li><li><p>公有制经济和非公有制经济都是社会主义<strong>市场</strong>经济的重要组成部分，都是我国经济社会发展的重要基础。</p></li><li><p>公有制经济财产权不可侵犯，非公有制经济财产权同样不可侵犯；国家保护各种所有制经济产权和合法利益，坚持权利平等、机会平等、规则平等，废除对非公有制经济各种形式的不合理规定，消除各种隐形壁垒，激发非公有制经济活力和创造力。</p></li></ul><p><em>2018年11月1日，习近平在民营企业座谈会上的讲话中指出：基本经济制度是我们必须长期坚持的制度。</em>  </p><ul><li><p><strong>民营经济</strong>是我国经济制度的<strong>内在要素</strong>，民营企业和民营企业家是我们自己人。</p></li><li><p>民营经济是社会主义市场经济发展的<strong>重要成果</strong>，是推进社会主义市场经济发展的<strong>重要力量</strong>，是<strong>推进供给侧结构性改</strong>革、推动高质量发展、<strong>建设现代化经济体系的重要主体</strong>，也是我们党长期执政、团结带领全国人民实现“两个一百年”奋斗目标和中华民族伟大复兴中国梦的<strong>重要力量</strong>。</p><blockquote><p>民营经济是推进供给侧结构性改革、推进高质量发展、建设现代化经济体系的重要主体。</p></blockquote></li></ul></li><li><p>分配制层面：</p><ul><li>必须坚持按劳分配为主体、多种分配方式并存。</li><li>坚持多劳多得，着重保护劳动所得，增加劳动者特别是一线劳动者劳动报酬，提高劳动报酬在<strong>初次分配中</strong>的比重。</li><li>健全以税收、社会保障、转移支付等为主要手段等<strong>再分配调节机制</strong>，强化税收调节，完善直接税制度并逐步提高其比重。</li><li>重视发挥第三次分配作用，发展慈善等社会公益事业。</li></ul></li><li><p>加快完善社会主义市场经济体制。（邓小平理论主要内容之一）</p></li></ol><h4 id="6-处理好政府和市场的关系"><a href="#6-处理好政府和市场的关系" class="headerlink" title="6.处理好政府和市场的关系"></a>6.处理好政府和市场的关系</h4><ul><li><p>经济体制改革是全面深化改革的<strong>重点</strong>，其<strong>核心问题</strong>是处理好政府和市场的关系，使<strong>市场</strong>在资源配置中<strong>起决定性</strong>作用和更好发挥政府作用</p><blockquote><p>经济体制改革的核心问题：处理好政府和市场的关系。</p><p>邓小平思想中是：处理好计划和市场的关系，都正确。</p></blockquote></li><li><p>市场的作用：市场配置资源是<strong>最有效率</strong>的形式。</p></li><li><p>政府的作用：主要是保持宏观经济稳定，加强和优化公共服务，保障公平竞争，加强市场监管，维护市场秩序，推动可持续发展，促进共同富裕，弥补市场失灵。</p></li><li><p>举措：要坚持使市场在资源配置中<strong>起决定性</strong>作用，完善市场机制，打破行业垄断、进入壁垒、地方保护等。要更好更科学发挥政府作用。</p></li></ul><h2 id="发展社会主义民主政治：政治"><a href="#发展社会主义民主政治：政治" class="headerlink" title="发展社会主义民主政治：政治"></a>发展社会主义民主政治：政治</h2><h3 id="49-坚持中国特色社会主义政治发展道路"><a href="#49-坚持中国特色社会主义政治发展道路" class="headerlink" title="49.坚持中国特色社会主义政治发展道路"></a>49.坚持中国特色社会主义政治发展道路</h3><blockquote><p>如何坚持中国特色社会主义政治发展道路</p></blockquote><ol><li><p>走中国特色社会主义政治发展道路，必须坚持<strong>党的领导、人民当家作主、依法治国</strong>有机统一。 </p><blockquote><p>考：戴帽子</p></blockquote><ul><li>党的领导：人民当家作主和依法治国的<strong>根本保证。</strong></li><li>人民当家作主：社会主义民主政治的<strong>本质特征。</strong></li><li>依法治国：党领导人民治理国家的<strong>基本方式。</strong></li></ul></li><li><p>走中国特色社会主义政治发展道路，必须坚持正确政治方向。</p></li></ol><h3 id="50-健全人民当家作主制度体系"><a href="#50-健全人民当家作主制度体系" class="headerlink" title="50.健全人民当家作主制度体系"></a>50.健全人民当家作主制度体系</h3><h4 id="1-国体"><a href="#1-国体" class="headerlink" title="1.国体"></a>1.国体</h4><ul><li><p>国体：人民民主专政</p><ul><li>（完整版）我国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家，国家一切权力属于人民。</li></ul><blockquote><p>国体：社会各阶级在国家的地位，国家政权掌握在哪个阶级手中。（国家是谁的）</p><p>人民民主专政的本质：无产阶级专政。</p></blockquote></li></ul><h4 id="2-政体"><a href="#2-政体" class="headerlink" title="2.政体"></a><font color='red'>2.政体</font></h4><ul><li><p>政体：人民代表大会制度</p><blockquote><p>政体：统治阶级实现其阶级统治的具体组织形式，统治阶级采取什么样的形式去组织自己的政权，实现自己的统治。（统治阶级如何管理国家）</p></blockquote></li><li><p>人民代表大会制度的性质</p><blockquote><p>考：</p><p>人民代表大会制度是什么？如何认识人大？为什么说人大是…?</p></blockquote><ol><li>人民代表大会制度是我国<strong>根本</strong>政治制度，</li><li>是符合中国国情、体现中国社会主义国家性质、能够保证人民当家作主的根本政治制度和最高实现形式</li><li>是党在国家政权中充分发扬民主、贯彻群众路线的最好实现形式。</li><li>人民代表大会制度是坚持党的领导、人民当家作主、依法治国有机统一的根本政治制度安排，必须长期坚持、不断完善。</li></ol></li><li><p>怎么做？措施？</p><ol><li>要支持和保证人民通过人民代表大会行使国家权力。</li><li>发挥人大及其常委会在立法工作中的主导作用，健全人大组织制度和工作制度，</li><li>支持和保证人大依法行使立法权、监督权、决定权、任免权，更好发挥人大代表作用，</li><li>使各级人大及其常委会成为全面担负起宪法法律赋予的各项职责的工作机关，成为同人民群众保持密切联系的代表机关</li></ol></li></ul><blockquote><p>辨析：</p><ol><li>人民代表大会制度是政体，是制度。而人民代表大会是机关，是机构</li><li>人民代表大会是分层次的，有全国人民代表大会，管理国家事务；也有地方人民代表大会，管理地方事务。</li><li>人民代表大会民主是间接民主，通过选举一个代表来行使我的权力。</li></ol></blockquote><h4 id="3-基本政治制度"><a href="#3-基本政治制度" class="headerlink" title="3.基本政治制度"></a>3.基本政治制度</h4><ol><li><p>中国共产党领导的多党合作和政治协商制度</p><ul><li><p>中国共产党领导的多党合作和政治协商制度：是我国的一项<strong>基本政治制度</strong> </p><ul><li>中国共产党领导的多党合作和政治协商制度是中国共产党、中国人民和各民主党派、无党派人士的伟大政治创造，是从中国土壤生长出来的新型<strong>政党制度</strong>。</li></ul></li><li><p><strong>人民政协</strong>：是具有中国特色的制度安排，是社会主义协商民主的重要渠道和专门协商<strong>机构</strong> </p><blockquote><p>政协制度是制度，政协是机构。</p></blockquote><ul><li>人民政协工作要聚焦党和国家中心任务，围绕<strong>团结和民主</strong>两大主题</li></ul></li></ul><blockquote><p>考点：</p></blockquote><ul><li><p>坚持和完善中国共产党领导的多党合作和政治协商制度。</p><ul><li>贯彻<strong>长期共存、互相监督、肝胆相照、荣辱与共</strong>的方针 </li></ul></li><li><p>在新时代，加强和改进政协工作的<strong>总体要求</strong>：以新时代中国特色社会主义思想为指导，增强“四个意识”、坚定“四个自信”，做到“两个维护”，把坚持和发展中国特色社会主义作为巩固共同思想政治基础的<strong>主轴</strong>，把服务实现“两个一百年”奋斗目标作为<strong>工作主线</strong>，把加强思想政治引领、广泛凝聚共识作为<strong>中心环节</strong>，坚持团结和民主两大<strong>主题</strong>。</p><blockquote><p>四个意识：政治意识、核心意识、大局意识、看齐意识</p><p>四个自信：理论自信、道路自信、制度自信、文化自信（根本）</p><p>两个维护：维护习近平的地位；维护党中央的地位</p></blockquote><ul><li>主轴 ：坚持和发展中国特色社会主义</li><li>工作主线：服务实现“两个一百年”</li><li>中心环节：加强思想政治引领、广泛凝聚共识</li><li>主题：团结和民主</li></ul></li></ul></li><li><p>民族区域自治制度</p><ul><li>民族区域自治制度的<strong>核心</strong>：保障少数民族当家作主，管理本民族、本地方事务的权力。</li><li>处理民族问题的<strong>基本原则</strong>：维护祖国统一，反对民族分裂，坚持民族平等、民族团结、<strong>各民族共同繁荣。</strong><ul><li>处理民族问题的出发点和落脚点：各民族共同繁荣</li></ul></li><li>中华民族共同体：<ul><li>是祖国统一的基础</li><li>是民族团结的必要条件</li><li>是实现中华民族伟大复兴的重要条件</li></ul></li></ul></li><li><p>基层群众自治制度</p><ul><li><p>完善基层群众自治制度，发展基层民主，是社会主义民主政治建设的基础。</p></li><li><p>我国的<strong>基础自治组织</strong>：农村村民委员会、城市居民委员会、企业职工代表大会</p><blockquote><p>考：基层群众自治制度管理基层的事情，全国人大才管国家的事情。</p></blockquote></li><li><p>职能：<strong>自我管理、自我服务、自我教育、自我监督</strong></p></li><li><p>基础群众自治制度：是直接民主</p><blockquote><p>与之相对的人大是间接民主。</p></blockquote></li></ul></li></ol><h4 id="4-发挥社会主义协商民主的重要作用"><a href="#4-发挥社会主义协商民主的重要作用" class="headerlink" title="4.发挥社会主义协商民主的重要作用"></a><font color='red'>4.发挥社会主义协商民主的重要作用</font></h4><blockquote><p>重点：</p></blockquote><ul><li><p>社会主义<strong>协商民主</strong>的<strong>内涵</strong>：有事好商量，众人的事情由众人商量，是人民民主的真谛。社会主义协商民主是在中国共产党的领导下，人民内部各方面围绕改革发展稳定重大问题和涉及群众利益的实际问题，<strong>在决策前和决策实施中</strong>，开展广泛协商，努力形成共识的重要民主形式。</p><blockquote><p>协商民主是在决策前和决策实施中。</p><p>决策之后是监督。</p></blockquote></li><li><p>协商民主的重要性：协商民主是中国社会主义民主政治的<strong>特有形式和独特优势</strong>，是实现党的领导的重要方式，丰富了民主的形式，拓展了民主的渠道，丰富了民主的内涵。</p></li><li><p>发展社会主义协商民主的<strong>举措</strong>：</p><ul><li>发展协商民主，必须推进协商民主广泛、多层制度化发展，统筹推进政党协商、人大协商、政府协商、政协协商、人民团体协商、基层协商及社会组织协商。</li><li>构建程序合理、环节完整的协商民主体系，完善协商于决策之前和决策实施之中的落实机制，丰富有事好商量、众人的事众人商量的制度化实施。</li></ul></li></ul><h3 id="51-巩固和发展爱国统一战线"><a href="#51-巩固和发展爱国统一战线" class="headerlink" title="51.巩固和发展爱国统一战线"></a>51.巩固和发展爱国统一战线</h3><ul><li><p>爱国统一战线的构成：由中国共产党领导的，有各个民主党派和各人民团体参与的，包括全体社会主义劳动者、社会主义事业的建设者、拥护社会主义的爱国者、拥护祖国统一和致力于中华民族伟大复兴的爱国者的广泛的爱国统一战线。</p><ul><li>这个统一战线是党的事业取得胜利的重要法宝，将继续巩固和发展。</li></ul></li><li><p>巩固和发展爱国统一战线的<strong>举措</strong>：</p><ol><li><p>（党派）坚持长期共存、互相监督、肝胆相照、荣辱与共，支持民主党派按照中国特色社会主义参政党要求更好履行职能。</p><blockquote><p>中国共产党领导的多党合作和政治协商的方针：长期共存、互相监督、肝胆相照、荣辱与共。</p></blockquote></li><li><p>（民族）深化民族团结进步教育，铸牢<strong>中华民族共同体</strong>意识。</p></li><li><p>（宗教）全面贯彻党的宗教工作基本方针，坚持我国宗教的中国化方向，积极引导宗教与社会主义社会相适应。</p></li><li><p>牢牢把握大团结大联合的主题。</p></li></ol></li></ul><h3 id="52-坚持“一国两制”，推进祖国统一"><a href="#52-坚持“一国两制”，推进祖国统一" class="headerlink" title="52.坚持“一国两制”，推进祖国统一"></a>52.坚持“一国两制”，推进祖国统一</h3><ul><li>“一国两制”是解决历史遗留的<strong>香港、澳门</strong>问题的最佳方案，也是香港、澳门回归后保持长期繁荣稳定的最佳制度。<ul><li>处理这两个特别行政区的事务是<strong>中国内政。</strong></li><li>总结澳门“一国两制”成功实践，可以获得的重要经验：<ol><li>始终坚定“一国两制”<strong>制度自信</strong></li><li>始终准确把握“一国两制”正确方向</li><li>始终强化“一国两制”使命担当</li><li>始终筑牢“一国两制”社会政治基础</li></ol></li></ul></li></ul><ol><li><p>全面贯彻“一国两制方针</p><blockquote><p>问：怎么推进“一国两制”</p></blockquote><p>举措：</p><ol><li>必须始终准确把握”一国“和”两制“的关系<ul><li>“一国两制”是一个完整的概念，<strong>“一国”</strong>是实行“两制‘<strong>的前提和基础</strong>，”两制“从属和派生与”一国“，并统一与”一国之内。</li><li>“一国两制”的提出首先<strong>是为了</strong>实现和维护国家统一。</li></ul></li><li>必须始终依照宪法和基本法办事</li><li>必须始终聚焦发展这个第一要务</li><li>必须始终维护和谐稳定的社会环境</li></ol></li></ol><ol start="2"><li><p>扎实推进祖国和平统一进程（台湾问题）</p><ul><li><p>解决台湾问题、实现祖国完全统一，是全体中华儿女共同愿望，是中华民族<strong>根本利益所在</strong>，是新时代中国共产党、中国政府的三大<strong>历史任务</strong>之一。</p><ul><li>中华民族的根本利益所在：解决台湾问题，实现祖国完全统一。</li><li>中国共产党、中国政府的三大历史任务：祖国统一、社会主义现代化、世界和平</li></ul></li><li><p>举措：</p><ol><li><p>坚持“和平统一、一国两制”方针。</p></li><li><p>推动两岸关系和平发展。</p></li><li><p>坚持一个中国原则和“九二共识”。</p><p><em>“九二共识”是两岸关系对“两岸同属一个中国”这一客观事实和现状的共同确认，是两岸双方授权认可的。</em> </p><ul><li>一个中国原则是两岸关系的<strong>政治基础</strong></li><li>“九二共识”<strong>体现</strong>一个中国原则</li></ul></li><li><p>坚决反对和遏制任何形式的“台独”。</p></li><li><p>秉持和践行“两岸一家亲”理念。</p></li><li><p>携手同心共圆民族复兴中国梦。</p></li></ol></li><li><p>台湾问题是中国的<strong>内政</strong>，事关中国核心利益和中国人民民族感情，不容任何外来干涉。</p></li></ul></li></ol><h2 id="推动社会主义文化繁荣昌盛：文化"><a href="#推动社会主义文化繁荣昌盛：文化" class="headerlink" title="推动社会主义文化繁荣昌盛：文化"></a>推动社会主义文化繁荣昌盛：文化</h2><h3 id="53-牢牢掌握意识形态工作领导权"><a href="#53-牢牢掌握意识形态工作领导权" class="headerlink" title="53.牢牢掌握意识形态工作领导权"></a>53.牢牢掌握意识形态工作领导权</h3><blockquote><p>意识形态：</p><p>马哲唯物史观里的社会意识中的社会意识形式下的意识形态，即和阶级、经济有关的意识形式。</p><p>意识形态：社会科学</p><p>非意识形态：自然科学</p></blockquote><ul><li>意识形态<strong>重要性</strong>：意识形态关乎旗帜、关乎道路、关乎国家政治安全，决定文化前进方向和道路。</li><li>如何掌握意识形态的工作的领导权：<ol><li>掌握意识形态工作领导权，要旗帜鲜明坚持马克思主义指导地位。</li><li>掌握意识形态工作领导权，要加快构建中国特色哲学社会科学。</li><li>掌握意识形态工作领导权，要坚持正确的舆论导向。</li><li>掌握意识形态工作领导权，要建设网络空间。</li><li>掌握意识形态工作领导权，要落实要意识形态工作责任制。</li></ol></li></ul><h3 id="54-培育和践行社会主义核心价值观"><a href="#54-培育和践行社会主义核心价值观" class="headerlink" title="54.培育和践行社会主义核心价值观"></a>54.培育和践行社会主义核心价值观</h3><ul><li><p>核心价值观的重要性：核心价值观是一个民族赖以维系的精神纽带，是一个国家共同的思想道德基础。</p></li><li><p>核心价值观的基本内容：</p><p><strong>回答了</strong>我们要建设什么样的国家、建设什么样的社会、培育什么样的公民的重大问题</p><ul><li>国家层面：富强、民主、文明、和谐</li><li>社会层面：自由、平等、公正、法治</li><li>公民层面：爱国、敬业、诚信、友善</li></ul></li><li><p>社会主义核心价值体系：</p><ul><li>马克思主义指导思想</li><li>中国特色社会主义共同理想</li><li>以爱国主义为核心的民族精神和以改革创新为核心的时代精神、</li><li>社会主义荣辱价值观。</li></ul></li><li><p>社会主义核心价值观和社会主义核心价值体系的关系：对立统一</p><ul><li>社会主义核心价值观是社会主义核心价值体系的<strong>内核凝练和集中表达</strong></li><li>联系：二者方向一致，都体现社会主义意识形态的本质要求。</li><li>区别：二者各有侧重，相比于社会主义核心价值体系，社会主义核心价值观更加突出核心要素、更加注重凝练表达、更加强化实践导向。</li></ul></li><li><p>如何培育和践行社会主义核心价值观：（怎么做）</p><ol><li><p>要把社会主义核心价值观融入社会生活各个方面</p></li><li><p>要坚持全民行动、干部带头，从家庭做起、从娃娃抓起</p></li><li><p>要立足中华优秀传统文化和革命文化</p></li><li><p>要必须发扬中国人民在长期奋斗中培育、继承、发展起来的<strong>伟大民族精神</strong> </p><ul><li><p>伟大民族精神：</p><blockquote><p>考：故事体现了什么精神</p></blockquote><ul><li>伟大创造精神：四大发明</li><li>伟大奋斗精神：开辟北大荒</li><li>伟大团结精神：共抗外敌</li><li>伟大梦想精神：神话故事，女娲补天、盘古开天</li></ul></li></ul></li></ol></li></ul><h3 id="55-坚定文化自信，建设社会主义文化强国"><a href="#55-坚定文化自信，建设社会主义文化强国" class="headerlink" title="55.坚定文化自信，建设社会主义文化强国"></a>55.坚定文化自信，建设社会主义文化强国</h3><ul><li><p><strong>文化强国</strong>：是指一个国家具有强大的文化力量。这种力量及表现为具有高度文化素养的国民，也表现为发达的文化产业，还表现为强大的文化软实力。</p><blockquote><p>目标是2020建设文化强国。</p></blockquote></li><li><p>如何建设文化强国：（怎么做）</p><ol><li><p>必须培养高度的文化自信</p></li><li><p>必须大力发展文化事业和文化产业</p><ul><li><p>文化事业 v.s 文化产业</p><table><thead><tr><th>公益性文化事业</th><th>经营性文化产业</th></tr></thead><tbody><tr><td>政府主导</td><td>市场主导</td></tr><tr><td>基本文化需求</td><td>多样化的文化需求</td></tr><tr><td>社会效益</td><td>经济效益</td></tr></tbody></table><blockquote><p>如果经济效益和社会效益冲突，以社会效益为首。</p></blockquote></li></ul></li><li><p>必须提高国家文化软实力</p></li></ol></li></ul><h2 id="坚持在发展中保障和改善民生：民生"><a href="#坚持在发展中保障和改善民生：民生" class="headerlink" title="坚持在发展中保障和改善民生：民生"></a>坚持在发展中保障和改善民生：民生</h2><h3 id="56-提高保障和改善民生水平"><a href="#56-提高保障和改善民生水平" class="headerlink" title="56.提高保障和改善民生水平"></a><font color='red'>56.提高保障和改善民生水平</font></h3><ol><li>优先发展教育事业。<ul><li>建设教育强国是中华民族伟大复兴的基础工程，必须把教育事业放在优先位置。</li></ul></li><li>提高就业质量和人民收入水平。<ul><li>就业是最大的民生。要坚持<strong>就业优先</strong>策略和积极就业策略，实现更高质量和更充分就业。</li></ul></li><li>加强社会保障体系建设。<ul><li>社会保障体系发挥<strong>兜底作用</strong>，保障全社会成员基本生存与生活需要，要全面建成<strong>覆盖全民</strong>、<strong>城乡统筹</strong>、<strong>权责清晰</strong>、<strong>保障适度</strong>、<strong>可持续的多层次</strong>社会保障体系。</li><li>全面实施全民参保计划。</li></ul></li><li>坚决打赢脱贫攻坚战。<ul><li>消除贫困、改善民生、逐步实现共同富裕，是社会主义的本质要求，是我们党的重要使命。</li><li>确保到2020年我国现行标准下农村贫困人口实现脱贫，贫困县全部摘帽，解决区域性整体贫困，做到脱真贫、真脱贫。</li></ul></li><li>实施健康中国战略。<ul><li>人民健康是民族昌盛和国家富强的重要标志。</li></ul></li></ol><h3 id="57-加强和创新社会治理"><a href="#57-加强和创新社会治理" class="headerlink" title="57.加强和创新社会治理"></a>57.加强和创新社会治理</h3><blockquote><p>社会管理：是单向的、机械的</p><p>社会治理：是系统化的、双向的</p></blockquote><ol><li>创新社会治理体系<ul><li>坚持完善党委领导、政府负责、社会协同、公众参与、法治保障的社会治理体系，提高社会治理社会化、法治化、智能化、专业化水平，推进社会治理精细化，打造<strong>共建共治共享</strong>的社会治理格局</li><li>社会治理格局：共建共治共享</li></ul></li><li>改进社会治理方式<ul><li>治理和管理一字之差，体现的是系统治理、依法治理、源头治理、综合施策。</li><li>坚持系统治理，加强党委领导，发挥政府主导作用，鼓励和支持社会各方面参与。</li></ul></li><li>加强预防和化解社会矛盾机制建设<ul><li>正确处理人民内部矛盾特别是涉及广大人民群众切身利益的矛盾，是保持社会安定团结良好局面的关键。</li><li>健全重大决策社会稳定风险评估机制，要将风险评估列为必经的前置程序和刚性门槛。</li></ul></li><li>加强社会心理服务体系建设</li><li>加强<strong>社区治理</strong>体系建设<ul><li>社区是党和政府联系、服务居民群众的“最后一公里”，社会治理的重心要向基层下移落到城乡社区。</li><li>尽可能把资源、服务、管理放到社区，使社区有职有权有物，更好为群众提供精准高效的服务和管理。</li></ul></li></ol><h3 id="58-坚持总体国家安全观"><a href="#58-坚持总体国家安全观" class="headerlink" title="58.坚持总体国家安全观"></a>58.坚持总体国家安全观</h3><ul><li>总体国家安全观是坚持国家利益至上，以人民安全为<strong>宗旨</strong>，以政治安全为<strong>根本</strong>，以经济安全为<strong>基础</strong>，以军事、文化、社会安全为<strong>保障</strong>，以促进国际安全为<strong>依托</strong>。</li><li>措施：<ol><li>完善国家安全体系</li><li>健全公安安全体系</li><li>推进平安中国建设</li><li>加强国家安全能力建设</li><li>加强国家安全教育</li></ol></li></ul><h2 id="建设美丽中国：生态文明"><a href="#建设美丽中国：生态文明" class="headerlink" title="建设美丽中国：生态文明"></a>建设美丽中国：生态文明</h2><h3 id="59-坚持人与自然和谐共生"><a href="#59-坚持人与自然和谐共生" class="headerlink" title="59.坚持人与自然和谐共生"></a>59.坚持人与自然和谐共生</h3><ul><li>生态文明的<strong>核心</strong>：是坚持人与自然和谐共生</li><li>面对资源约束趋紧、环境污染严重、生态系统退化的严峻形势，必须树立<strong>尊重自然、顺应自然、保护自然</strong>的<strong>生态文明理念</strong>，维护人与自然之间形成的生命共同体。<ul><li>生态文明理念：尊重自然、顺应自然、保护自然</li><li>尊重自然：人与自然相处时应秉持的<strong>首要态度</strong></li><li>顺应自然：人与自然相处时应遵循的<strong>基本原则</strong></li><li>保护自然：人与自然相处时应承担的<strong>重要责任</strong> </li></ul></li></ul><h3 id="60-形成人与自然和谐发展新格局"><a href="#60-形成人与自然和谐发展新格局" class="headerlink" title="60.形成人与自然和谐发展新格局"></a>60.形成人与自然和谐发展新格局</h3><ul><li>如何形成人与自然和谐发展新格局：（怎么做）<ol><li>把节约资源放在首位</li><li>坚持保护优先、<strong>自然恢复</strong>为主<ul><li>实行最严格的生态环境保护制度：<ul><li>在环保工作中，把预防为主、源头治理放在<strong>首位</strong>；</li><li>在生态系统保护和修复中，把利用自然力修复生态系统放在<strong>首位</strong></li></ul></li></ul></li><li>着力推进绿色发展、循环发展、低碳发展</li><li>形成节约资源和保护环境的空间格局、产业结构、生产方式、生活方式</li></ol></li></ul><h3 id="61-坚持和完善生态文明制度体系，促进人与自然和谐"><a href="#61-坚持和完善生态文明制度体系，促进人与自然和谐" class="headerlink" title="61.坚持和完善生态文明制度体系，促进人与自然和谐"></a>61.坚持和完善生态文明制度体系，促进人与自然和谐</h3><ul><li><p>习近平强调，要加快构建生态文明体系，加快建设：</p><ol><li>以生态价值观念<strong>为准则</strong>的<strong>生态文化体系</strong></li><li>以产业生态化和生态产业化<strong>为主体</strong>的<strong>生态经济体系</strong></li><li>以改善生态环境质量<strong>为核心</strong>的<strong>目标责任体系</strong></li><li>以治理体系和治理能力现代化<strong>为保障</strong>的生态文明<strong>制度体系</strong> </li><li>以生态系统良性循环和环境风险有效防控<strong>为重点</strong>的<strong>生态安全体系</strong></li></ol><ul><li>要通过加快构建生态文明体系，确保到2035年，生态环境质量实现根本好转，美丽中国目标基本实现</li></ul></li><li><p>坚持和完善生态文明制度体系</p><ol><li>实行最严格的生态环境保护制度</li><li>全面建设资源高效利用制度</li><li>健全生态保护和修复制度</li><li>严明生态环境保护责任制度</li></ol></li><li><p>加快生态文明体制改革：用制度保障生态环境、推进生态文明建设。</p><blockquote><p>书上措施：</p></blockquote><ol><li>推进绿色发展</li><li>着力解决突出环境问题</li><li>加大生态系统保护力度</li><li>改革生态环境监管体制</li></ol></li></ul><h1 id="战略布局：四个全面"><a href="#战略布局：四个全面" class="headerlink" title="战略布局：四个全面"></a>战略布局：四个全面</h1><p>战略目标：</p><ul><li>全面小康：引领性地位</li></ul><p>战略举措：</p><ul><li>全面改革：突破性、先导性环节（动力）</li><li>全面法治：重要组成部分</li><li>全面建党：重要组成部分</li></ul><h2 id="全面建成小康社会"><a href="#全面建成小康社会" class="headerlink" title="全面建成小康社会"></a>全面建成小康社会</h2><h3 id="62-全面建成小康社会"><a href="#62-全面建成小康社会" class="headerlink" title="62.全面建成小康社会"></a>62.全面建成小康社会</h3><ul><li><p><strong>全面</strong>建成<strong>小康</strong>社会，最重要、更难做到的事“全面”。“小康”讲的是发展水平，<strong>“全面”</strong>讲的是发展的平衡性、协调性、可持续性。</p><ol><li><p>全面小康，覆盖的<strong>领域</strong>要全面，是“五位一体”全面进步的小康。</p></li><li><p>全面小康，覆盖的<strong>人口</strong>要全面，是惠及全体人民的小康。</p></li><li><p>全面小康，覆盖的<strong>区域</strong>要全面，是城乡区域共同发展的小康。</p></li></ol></li><li><p>目标要求：</p><ol><li>经济保持中高速增长。<ul><li>到2020年国内生产总值和城乡居民人均收入比2010年翻一番。</li></ul></li><li>创新驱动成效显著<ul><li>2020年迈进创新型国家和人才强国行列。</li></ul></li><li>发展协调性明显增强</li><li>人民生活水平和质量普遍提高</li><li>国民素质和社会文明程度显著提高</li><li>生态环境质量总体改善</li><li>各方面制度更加成熟更加定型。<ul><li>国家治理体系和治理能力现代化取得重大进展，各领域基础性制度体系基本形成。</li></ul></li></ol></li><li><p>怎么做？</p><blockquote><p>三个攻坚战，一个发展</p></blockquote><p><em>到2020年是全面建成小康社会的决胜期。</em> </p><ol><li><p>坚决打好防范化解<strong>重大风险</strong>攻坚战。</p><p><em>防止外部风险演化为内部风险，防止经济金融风险演化为政治社会风险，防止个体风险演化为系统性风险。</em> </p><blockquote><p>包括金融、地方债务、信息安全等</p></blockquote></li><li><p>坚决打好精准脱贫攻坚战。</p><p><em>坚持精准扶贫、精准脱贫基本方略，坚持<strong>专项扶贫、行业扶贫、社会扶贫</strong>等“三位一体”大扶贫格局。</em> </p><blockquote><p>专项扶贫：立一个项目来扶贫</p><p>行业扶贫：发展旅游业、特产等</p><p>社会扶贫：社会救助项目</p></blockquote></li><li><p>坚决打好污染防治攻坚战</p></li><li><p>确保经济社会持续健康发展</p></li></ol></li></ul><h2 id="全面深化改革"><a href="#全面深化改革" class="headerlink" title="全面深化改革"></a>全面深化改革</h2><h3 id="63-坚定不移地全面深化改革"><a href="#63-坚定不移地全面深化改革" class="headerlink" title="63.坚定不移地全面深化改革"></a>63.坚定不移地全面深化改革</h3><ul><li>全面深化改革作为“四个全面”战略布局中<strong>具有突破性和先导性的关键环节</strong>。（动力）</li></ul><blockquote><p>1978年：进入改革时期</p><p>35年。</p><p>2013年：（十八届三中全会）进入全面改革时期</p></blockquote><ul><li><p>全面深化改革的<strong>必要性</strong>？（为什么要坚定不移地全面深化改革）</p><ul><li>全面深化改革，是顺应当今世界发展大势的必然选择。</li><li>全面深化改革，是解决中国现实问题的根本途径。</li><li>全面深化改革，关系党和人民事业前途命运，关系党的执政基础和执政地位。</li></ul></li><li><p>全面深化改革的<strong>基本原则</strong>（怎么做？）</p><ol><li><p>全面深化改革必须坚持党对改革的集中统一领导</p><p><em>党是改革的倡导者、推动者、领导者，改革能否顺利推进，关键取决于党，取决于党的领导。</em></p></li><li><p>全面深化改革必须坚持改革沿着中国特色社会主义方向前进。</p><p><em>我国改革开放之所以能取得巨大成功，关键是我们把党的基本路线作为党和国家的生命线，始终坚持把以经济建设为中心同四项基本原则、改革开放这两个基本点统一于中国特色社会主义伟大实践，坚定不移走中国特色社会主义道路。改革是社会主义制度自我完善和发展，不是对社会主义制度改弦易张。</em> </p></li><li><p>全面深化改革必须坚持改革有<strong>利于维护社会公平正义、增进人民福祉</strong>方向前进。</p><p><em>促进社会公平正义、增进人民福祉是全面深化改革的<strong>出发点和落脚点</strong>，是坚持党全心全意为人民服务根本宗旨的必然要求。</em> </p><ul><li><p>改革的根本目的、出发点和落脚点：促进社会主义公平正义、增进人民福祉。</p><blockquote><p>根本目的 = 归宿 = 出发点 = 落脚点</p></blockquote></li></ul></li><li><p>全面深化改革必须坚持<strong>社会主义市场经济</strong>改革方向。</p><p><em>我国社会主义市场经济体制已经初步建立，要继续朝着加快完善社会主义市场经济体制的目标努力，着力健全使<strong>市场在资源配置中起决定性作用</strong>和更好发挥<strong>政府作用</strong>的制度体系。</em></p></li></ol></li><li><p>总结：</p><ul><li><strong>改革开放</strong>是我们党的一次伟大觉醒，正是这个伟大觉醒孕育了我们党从理论到实践的伟大创造。</li><li><strong>改革开放</strong>是中国人民和中华民族发展史上一次伟大革命，正是这个伟大革命推动力中国特色社会主义事业的伟大飞跃！40年的实践充分证明<ul><li>改革开放是党和人民踏步赶上时代的重要法宝</li><li>改革开放是坚持和发展中国特色社会主义的必由之路</li><li>改革开放是决定当代中国命运的关键一招</li><li>改革开放也是决定实现“两个一百年”奋斗目标、实现中华民族伟大复兴的关键一招</li></ul></li></ul></li></ul><h3 id="64-形成全面开放新格局"><a href="#64-形成全面开放新格局" class="headerlink" title="64.形成全面开放新格局"></a><font color = 'red'>64.形成全面开放新格局</font></h3><blockquote><p>开放是热点。</p></blockquote><ol><li><p>对外开放的重要性</p><ul><li><p>对外开始是我国的<strong>基本国策</strong> </p><blockquote><p>基本国策：对外开放、一国两制、节约资源、保护环境</p></blockquote></li><li><p>全面开放是实现国家繁荣富强的<strong>根本出路</strong></p></li></ul></li><li><p>全面开放的<strong>新格局</strong> </p><blockquote><p>都对。</p></blockquote><ul><li><p>邓小平的全面开放新格局：<strong>全方位、宽领域、多层次</strong></p></li><li><p>党的十九大强调，要以“一带一路”建设为重点，坚持引进了和走出去并重，遵循<strong>共商共建共享</strong>原则，加强创新能力开放合作，形成海陆内外联动、东西双向互济的<strong>开放格局</strong>。</p><ul><li>全面开放的新格局：海陆内外联动、东西双向互济。</li></ul><blockquote><p>辨析：</p><p>一带一路的建设原则：共商共建共享</p><p>全球治理观：共商共建共享</p><p>社会治理格局：共建共治共享</p></blockquote></li></ul></li><li><p><strong>如何形成</strong>全面开放的新格局（怎么做？）</p><ul><li>坚持<strong>主动开放。</strong><ul><li>把开放作为发展的内在要求，更加积极主动地扩大对外开放。</li><li>开放的<strong>核心是</strong>解决发展内外联动的问题，<strong>目标</strong>是提高对外开放质量、发展更高层次的开放型经济。</li></ul></li><li>坚持<strong>双向开放。</strong><ul><li>把引进来与走出去更好结合起来，拓展经济发展空间。</li></ul></li><li>坚持<strong>全面开放。</strong><ul><li>推动形成陆海内外联动、东西双向互济的开放格局。</li></ul></li><li>坚持<strong>公平开放。</strong><ul><li>构建公平竞争的内外资发展环境。</li></ul></li><li>坚持<strong>共赢开放。</strong><ul><li>推动经济全球化朝着惠普共赢方向发展。</li></ul></li><li>坚持<strong>包容开放。</strong><ul><li>探索求同存异、包容共生的国际发展合作新途径。</li></ul></li></ul></li><li><p>如何促进更高水平的<strong>对外开放</strong>（怎么做？）</p><p><em>2019年4月26日，习近平在第二届“一带一路”国际合作高峰论坛开幕式上的主旨演讲指出“中国将采取一系列重大改革开放举措，加强制度性、结构性安排，促进更高水平对外开放。</em></p><ul><li>更广领域扩大外资市场准入。</li><li>更大力度加强知识产权保护国际合作。</li><li>更大规模增大商品和服务<strong>进口</strong>。</li><li>更加有效实施国际宏观经济政策协调。</li><li>更加重视对外开放政策贯彻落实。</li></ul></li></ol><h3 id="65-全面深化改革的总目标和主要任务"><a href="#65-全面深化改革的总目标和主要任务" class="headerlink" title="65.全面深化改革的总目标和主要任务"></a>65.全面深化改革的总目标和主要任务</h3><ul><li><p>党的十八届三中全会通过了《中共中央关于全面深化改革若干重大问题的决定》，提出全面深化改革的<strong>总目标</strong>是<strong>完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化</strong>。</p><blockquote><p>辨析：</p><p>全面深化改革的根本目的：维护社会公平正义、增进人民福祉方向前进。</p></blockquote><ul><li>根本方向：完善和发展中国特色社会主义制度</li><li>实现途径：推进国家治理体系和治理能力现代化</li></ul></li><li><p>坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化的总体目标是，</p><ul><li>（2020）到我们党成立一百年时，在各方面制度更加成熟更加定型上取得明显成效；</li><li>到2035年，各方面制度更加完善，<strong>基本实现</strong>国家治理体系和治理能力现代化；</li><li>（21世纪中叶）到新中国成立一百年时，<strong>全面实现</strong>国家治理体系和治理能力现代化，使中国特色社会主义制度更加巩固、优越性充分展现。</li></ul></li><li><p>国家治理体系和国家治理能力</p><ul><li><p>国家治理体系：在党领导下管理国家的制度体系。</p><p><em>包括经济、政治、文化、社会、生态文明和党的建设等各领域体制机制、法律法规安排，即一整套紧密相连、相互协调的国家制度。</em> </p></li><li><p>国家治理能力：运用国家制度管理社会各方面事务的能力。</p><p><em>包括改革发展稳定、内政外交国防、治党治国治军等各个方面。</em> </p></li><li><p>关系：国家治理体系和治理能力是一个国家的制度和制度执行能力的集中体现，两者相辅相成。</p><ul><li>治理国家，制度是起根本性、全局性、长远性作用等，但没有有效的治理能力，再好的制度也难以发挥作用。</li><li>同时，又不能把国家治理体系和国家治理能力等同起来，不是国家治理体系越完善，国家治理能力就越强。</li><li>必须把国家治理体系和治理能力结合在一起，把两者当作一个相辅相成的有机整体，通过好的国家治理体系提高治理能力，通过提高国家治理能力充分发挥国家治理体系的效能。 </li></ul></li></ul></li><li><p>党的十九届四中全会通过了《中共中央关于坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化若干重大问题的决定》，紧紧围绕“坚持和巩固什么、完善和发展什么”这个重大政治问题，从十三个方面总结了<strong>我国国家制度和国家治理体系的显著优势</strong></p><ul><li>中国特色社会主义道路自信、理论自信、制度自信、文化自信的基本依据：国家制度和国家治理能力的显著优势  </li></ul><blockquote><p>一共十三个方面，截取四个重点。（毛中特24）</p></blockquote><ul><li><strong>坚持党的集中统一</strong>，坚持党的科学理论，保持政治稳定，确保国家<strong>始终沿着社会主义方向前进的显著优势。</strong></li><li><strong>坚持人民当家作主</strong>，发展人民民主，密切联系群众，<strong>紧紧依靠人民推动国家发展的显著优势。</strong></li><li>坚持公有制为主体、多种所有制经济共同发展和按劳分配为主体、多种分配方式并存，把社会主义制度和市场经济有机结合起来，不断<strong>解放和发展社会主义生产力的显著优势。</strong><ul><li>基本经济制度：坚持公有制为主体、多种所有制经济共同发展和按劳分配为主体、多种分配方式并存，把社会主义制度和市场经济有机结合。</li></ul></li><li>坚持以人民为中心的发展思想，不断保障和改善民生、增进人民福祉，<strong>走共同富裕道路的显著优势。</strong></li></ul></li><li><p><em>坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化的重点内容</em></p><blockquote><p>十三点，和显著优势基本相同。</p></blockquote></li></ul><h3 id="66-正确处理全面深化改革中的重大关系"><a href="#66-正确处理全面深化改革中的重大关系" class="headerlink" title="66.正确处理全面深化改革中的重大关系"></a>66.正确处理全面深化改革中的重大关系</h3><p><em>全面深化改革要攻坚涉险，必须坚持正确的思想方法，不断探索和把握全面深化改革的内在规律，特别是要把握和处理好全面深化改革中的一些重大关系。</em> </p><ol><li><p>处理好解放思想和实事求是的关系</p></li><li><p>处理好顶层设计和摸着石头过河的关系</p><blockquote><p>上下联动</p></blockquote></li><li><p>处理好整体推进和重点突破的关系</p></li><li><p>处理好胆子要大、步子要稳的关系</p></li><li><p>处理好改革、发展、稳定的关系</p><blockquote><p>动态平衡</p></blockquote><p><em>改革、发展、稳定是我国社会主义现代化建设的三个重要支点</em></p><ul><li>改革是经济社会发展的强大<strong>动力</strong>，发展是解决一切经济社会问题的<strong>关键</strong>，稳定是改革发展的<strong>前提</strong> </li><li>坚持把改革的力度、发展的速度和社会可承受的程度统一起来，把改善人民生活作为正确处理改革、发展、稳定关系的结合点，在保持社会稳定中推进改革发展，通过改革发展促进社会稳定。</li></ul></li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="全面依法治国"><a href="#全面依法治国" class="headerlink" title="全面依法治国"></a>全面依法治国</h2><h3 id="67-全面依法治国方略的形成发展"><a href="#67-全面依法治国方略的形成发展" class="headerlink" title="67.全面依法治国方略的形成发展"></a>67.全面依法治国方略的形成发展</h3><blockquote><p>形成步骤</p></blockquote><ul><li><p><strong>党的十八届四中全会</strong>通过了《关于全面推进依法治国若干重大问题的决定》，<strong>明确提出全面推进依法治国</strong>，加快建设法治中国，开启了中国特色社会主义法治道路的新征程。</p></li><li><p><strong>党的十九大</strong>明确提出，全面依法治国是中国特色社会主义的<strong>本质要求和重要保障</strong>。 </p><blockquote><p>重要保障：依法治国</p><p>根本保证：党的领导</p></blockquote></li></ul><h3 id="68-中国特色社会主义法治道路"><a href="#68-中国特色社会主义法治道路" class="headerlink" title="68.中国特色社会主义法治道路"></a>68.中国特色社会主义法治道路</h3><blockquote><p>怎么做？</p></blockquote><ol><li><p>坚持中国共产党的领导。</p><ul><li><strong>党的领导和依法治国</strong>是<strong>高度统一的。</strong></li><li>党的领导是社会主义法治最<strong>根本的保证</strong>。必须坚持党领导立法、保证执法、支持司法、带头守法，把依法治国同依法执政统一起来。</li></ul></li><li><p>坚持人民在全面依法治国中的主体地位。</p></li><li><p>坚持法律面前人人平等。</p></li><li><p>坚持依法治国和以德治国相结合。</p><p><em>一方面发挥好法律的规范作用，以法治体现道德理念、强化法律对道德建设的促进作用，同时充分发挥好道德的教化作用，以道德滋养法治精神、强化道德对法治文化的支撑作用。</em> </p><ul><li>法律：<strong>规范</strong>作用。</li><li>道德：<strong>教化</strong>作用。</li><li>法律对道德：<strong>促进</strong>作用。</li><li>道德对法律：<strong>支撑</strong>作用。</li></ul></li><li><p>坚持从中国实际出发。</p></li></ol><h3 id="69-深化依法治国实践的重点任务"><a href="#69-深化依法治国实践的重点任务" class="headerlink" title="69.深化依法治国实践的重点任务"></a>69.深化依法治国实践的重点任务</h3><ul><li>全面依法治国，总目标：建设中国特色社会主义法治体系，建设社会主义法治国家。</li></ul><ol><li>推进中国特色社会主义法治体系建设<ul><li>首先要完善以宪法为核心的中国特色社会主义<strong>法律体系</strong></li><li>其次要建立严密的<strong>法治监督体系</strong></li><li>再次要进一步健全<strong>法治保障体系</strong></li><li>最后要加强<strong>党内法规制度建设</strong> </li></ul></li><li>深化依法治国实践<ul><li>健全保证宪法全面实施的体制机制</li><li>完善立法体制机制</li><li>健全社会公平正义法治保障制度</li><li>加强对法律实施的监督</li></ul></li></ol><h2 id="全面从严治党"><a href="#全面从严治党" class="headerlink" title="全面从严治党"></a>全面从严治党</h2><h3 id="70-新时代党的建设总要求"><a href="#70-新时代党的建设总要求" class="headerlink" title="70.新时代党的建设总要求"></a>70.新时代党的建设总要求</h3><ul><li><p>党面临长期性和复杂性的考验：执政考验、改革开放考验、市场经济考验、外部环境考验</p></li><li><p>党面临的尖锐性和严峻性危险：精神懈怠危险、能力不足危险、脱离群众危险、消极腐败危险</p></li><li><p>新时代党的建设<strong>总要求</strong>：坚持和加强党的全面领导，坚持党要管党、全面从严治党，以加强党的长期执政能力建设、先进性和纯洁性建设<strong>为主线</strong>，以党的政治建设<strong>为统领</strong>，以坚定理想信念宗旨<strong>为根基</strong>，以调动全党积极性、主动性、创造性<strong>为着力点</strong>，全面推进<strong>党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设</strong>贯穿其中，深入推进反腐败斗争，不断提高党的建设治理，把党建设成为始终走在时代前列、人民衷心拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义执政党。</p><ul><li><p>主线：加强党的长期执政能力建设、先进性和纯洁性建设</p></li><li><p>统领：党的政治建设</p></li><li><p>根基：坚定理想信念宗旨</p></li><li><p>着力点：调动全党积极性、主动性、创造性</p></li><li><p>党的六大建设：政治建设（首位）、思想建设、组织建设、作风建设、纪律建设、制度建设</p><blockquote><p>政治建设：立场问题，衷心度</p><p>思想建设：马克思</p></blockquote></li><li><p>新时代党的建设的<strong>根本方针</strong>：“坚持党要管党、全面从严治党”</p><ul><li>“全面”是基础。“严”是关键。“治”是要害。</li></ul></li><li><p>新时代党的<strong>建设目标</strong>：“把党建设成为始终走在时代前列、人民衷心拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义执政党。</p></li></ul></li></ul><h3 id="71-把党的政治建设摆在首位"><a href="#71-把党的政治建设摆在首位" class="headerlink" title="71.把党的政治建设摆在首位"></a>71.把党的政治建设摆在首位</h3><ul><li><strong>党的十九大</strong>首次把党的政治建设纳入党的建设总体布局，并强调“以党的政治建设为统领”<strong>“把党的政治建设摆在首位</strong>”，凸显党的政治建设的极端重要性，这是党的建设理论和实践的重大创新。 </li><li>把党的政治建设摆在首位的<strong>原因</strong> <ol><li>旗帜鲜明讲政治是我们党作为马克思主义政党的根本要求。</li><li>党的政治建设是党的<strong>根本性建设</strong>，决定党的建设方向和效果。</li><li>注重抓党的政治建设是党的十八大以来全面从严治党的成功经验。</li></ol></li><li>党的政治建设的首要任务：保证全党服从中央，坚持党中央权威和集中统一领导。</li></ul><h3 id="72-全面从严治党永远在路上"><a href="#72-全面从严治党永远在路上" class="headerlink" title="72.全面从严治党永远在路上"></a>72.全面从严治党永远在路上</h3><ol><li>加强党的思想建设。<ul><li>党的<strong>基础性建设</strong>：思想建设。</li><li>我们党永葆先进性、纯洁性的<strong>根本保证</strong>：坚持以科学理论引领、用科学理论武装。</li></ul></li><li>加强党的组织建设。<ul><li>党的组织建设主要包括民主集中制建设、党的基层组织建设、干部队伍建设和党员队伍建设等内容。</li></ul></li><li>持之以恒正风肃纪。<ul><li>作风建设的<strong>核心</strong>：保持党同人民群众的血肉联系。</li><li>我们党的最大<strong>政治优势</strong>：密切联系群众。</li></ul></li><li>将制度建设贯穿党的各项建设之中。<ul><li>制度问题带有根本性、全局性、稳定性、长期性，加强制度建设是全面从严治党的长远之策、根本之策。</li></ul></li><li>深化标本兼治，夺取反腐败斗争压倒性胜利。<ul><li>廉政建设和反腐败斗争，是从严治党的重中之重。人民群众最痛恨腐败现象，腐败是我们党面临的最大威胁。</li></ul></li></ol><h1 id="新时代的内外条件和领导核心"><a href="#新时代的内外条件和领导核心" class="headerlink" title="新时代的内外条件和领导核心"></a>新时代的内外条件和领导核心</h1><ul><li>新时代的内外条件和领导核心<ul><li>内：军队国防</li><li>外：中国外交</li><li>领导核心：党的建设</li></ul></li></ul><h2 id="全面推进国防和军队现代化"><a href="#全面推进国防和军队现代化" class="headerlink" title="全面推进国防和军队现代化"></a>全面推进国防和军队现代化</h2><h3 id="73-习近平的强军思想"><a href="#73-习近平的强军思想" class="headerlink" title="73.习近平的强军思想"></a>73.习近平的强军思想</h3><ul><li><p>习近平强军思想深刻<strong>回答了</strong>：“新时代建设一支什么样的强大人民军队、怎样建设强大人民军队”的时代课题。</p><ul><li>新时代的<strong>强军目标</strong>：建设一支听党指挥、能打胜仗、作风优良的人民军队，必须同国家现代化进程相一致，力争到2035年基本实现国防和军队现代化，到本世纪中叶把人民军队建成世界一流军队。</li><li>人民军队<strong>建军之本、强军之魂</strong>：党对军队绝对领导。</li><li>我军<strong>鲜明特色和政治优势</strong>：作风优良。</li><li>强军的必由之路：改革。</li><li>兴国之举、强军之策：军民融合。</li></ul></li><li><p>坚持党对人民军队的绝对领导</p><ul><li><p>党对军队的领导是中国特色社会主义的<strong>本质特征</strong>，是党和国家的重要政治优势。</p><blockquote><p>党（对一切）的领导是中国特色社会主义的本质特征。</p></blockquote></li><li><p>党的领导是人民军队战无不胜的<strong>根本保证</strong>。</p></li><li><p>党对军队的领导的根本原则和制度，<strong>发端于</strong>南昌起义，<strong>奠基于</strong>三湾改编，<strong>定型于</strong>古田会议，是人民军队完全区别于一切旧军队的政治特征和根本优势。</p><ul><li>人民军队完全区别于一切旧军队的<strong>政治特征和根本优势。</strong> </li></ul></li><li><p>党对军队的领导，其基本内容：军队必须完全地无条件地置于中国共产党的领导之下，在思想上政治上行动上始终与党中央、中央军委保持高度一致，坚决维护党中央、中央军委权威，任何时候任何情况下都坚决听从党中央、中央军委指挥。</p></li></ul></li><li><p>建设世界一流军队</p><ul><li><p>十九大对全面推进国防和军队现代化做出新的战略安排：</p><ul><li>到2020年，国防和军队建设基本实现机械化，信息化建设取得重大进展；</li><li>到2035年，基本实现国防和军队现代化；</li><li>到本世纪中叶，把人民军队全面建成世界一流军队</li></ul></li><li><p>怎么做：</p><ol><li>牢固树立战斗力这个唯一的<strong>根本的标准</strong> </li><li><em>坚持政治建军、改革强军、科技兴军、依法治军</em></li><li><em>构建中国特色现代军事力量体系</em></li><li><em>深入推进练兵备战</em> </li></ol></li></ul></li></ul><h3 id="74-推进军民融合深度发展"><a href="#74-推进军民融合深度发展" class="headerlink" title="74.推进军民融合深度发展"></a>74.推进军民融合深度发展</h3><ul><li><p>坚持富国和强军相统一</p><ul><li><p>必要性：</p><ul><li><p>坚持富国和强军相统一是我们党的一贯主张。</p></li><li><p>坚持富国和强军相统一是经济建设和国防建设协调发展规律的内在要求</p><blockquote><p>经济为国防提供支撑，国防为经济提供保障</p></blockquote></li></ul></li><li><p>途径：走军民融合式发展路子，是实现富国和强军统一的重要途径。</p></li></ul></li><li><p>加快形成军民融合深度发展格局：全要素、宽领域、高效益</p><ol><li>坚持全国一盘棋。军民融合是<strong>国家战略</strong> 。</li><li><em>健全体制机制。在国家层面，成立中央军民融合发展委员会。</em></li><li><em>强化战略规划。</em></li><li><em>突出重点领域</em></li><li><em>军政军民团结是实现富国和强军相统一的重要政治保障，是我党我军特有的政治优势。</em></li></ol></li></ul><h2 id="中国特色外交"><a href="#中国特色外交" class="headerlink" title="中国特色外交"></a>中国特色外交</h2><h3 id="75-世界正处于大发展大变革大调整时期"><a href="#75-世界正处于大发展大变革大调整时期" class="headerlink" title="75.世界正处于大发展大变革大调整时期"></a><em>75.世界正处于大发展大变革大调整时期</em></h3><ol><li>世界多极化在曲折中发展（政治）</li><li>经济全球化深入发展</li><li><em>文化多样性持续推进</em></li><li><em>社会信息化快速发展</em></li><li><em>科学技术孕育新突破</em></li></ol><h3 id="76-坚持独立自主和平外交政策"><a href="#76-坚持独立自主和平外交政策" class="headerlink" title="76.坚持独立自主和平外交政策"></a>76.坚持独立自主和平外交政策</h3><ul><li><p>中国独立自主和和平外交政策的<strong>内涵：</strong></p><ol><li>就是把国家主权和安全放在第一位，坚定地维护我国的国家利益，反对任何国家损害我国的独立、主权、安全和尊严；</li><li>就是从我国人民和世界人民的根本利益出发，对于一切国际事务，都要根据事情本身的是非曲直决定自己的立场和政策，秉持公道，伸张正义，不屈从于任何外来压力。</li><li>就是坚持各国的事物应由本国政府和人民决定，世界上的事情应由各国政府和人民平等协商，反对一切形式的霸权主义和强权政治；</li><li>就是主张和平解决国际争端和热点问题，反对动辄诉诸武力或以武力相威胁，反对颠覆别国合法政权，反对一切形式的恐怖主义。</li></ol></li><li><p>中国坚定不移地奉行独立自主和平外交政策的<strong>依据</strong></p><ol><li>走和平发展道路，这是由我国的<strong>社会主义性质</strong>和<strong>在国际上的地位所决定的</strong> ，是从历史、现实、未来的客观判断中得出的结论，是思想自信和实践自觉的有机统一。</li><li>中国走和平发展道路的自信和自觉，来源于中华文明的深厚渊源，来源于对实现中国发展目标条件的认知，来源于对世界发展大势的把握。</li></ol></li><li><p>中国坚定不移地奉行独立自主和平外交政策的<strong>意义</strong> </p><p><em>走和平发展道路，对中国有利，对亚洲有利，对世界也有利。中国坚持走和平发展道路，既积极争取和平的国际环境发展自己，又以自身发展促进世界和平既让中国更好利用世界的机遇，又让世界更好分享中国的机遇，促进中国和世界各国良性互动、互利共赢。</em></p></li></ul><h3 id="77-推动建立新型国际关系"><a href="#77-推动建立新型国际关系" class="headerlink" title="77.推动建立新型国际关系"></a>77.推动建立新型国际关系</h3><ul><li><p>推动建设<strong>相互尊重、公平正义、合作共赢</strong>的新型国际关系。</p><ul><li>“新”在相互尊重，“新”在公平正义，特别是“新”在<strong>合作共赢。</strong></li></ul></li><li><p>中国倡导建立互相尊重、公平正义、合作共赢的新型国际关系，核心是：</p><ul><li>维护联合国宪章的宗旨和原则</li><li>维护不干涉别国内政和尊重国家主权、独立、领土完整等国际关系基本准则</li><li>维护联合国及其安理会对世界和平承担的首要责任，开展对话、合作而不是对抗，实现双赢、共赢而不是单赢</li></ul></li><li><p>基本主张（做法）</p><blockquote><p>如何推动建立新型国际关系</p></blockquote><ol><li><p>要坚决维护国家核心利益。</p><ul><li>中国始终把<strong>坚决维护国家主权、安全、发展利益</strong>作为外交工作的<strong>基本出发点和落脚点</strong>，稳妥应对涉我领土主权和海洋权益争端，坚决维护国家的领土权。</li></ul></li><li><p>要在<strong>和平共处五项原则</strong>基础上发展同世界各国的友好合作。</p><blockquote><p>和平共处五项原则的精髓：互相尊重领土主权完整</p></blockquote><ul><li>要按照大国是关键、周边是首要、发展中国家是基础、多边是舞台的外交工作<strong>布局</strong>，发展与各国的友好关系。</li></ul></li><li><p>推动建立新型国际关系，要积极参与全球治理体系改革和建设。</p><ul><li><p>中国秉持<strong>共商共建共享</strong>的<strong>全球治理观</strong>。 </p><blockquote><p>辨析：</p><p>社会治理格局：共建共治共享</p><p>全球治理观：共商共建共享</p></blockquote></li></ul></li><li><p>推动建立新型国际关系，要加强涉外法律工作，完善涉外法律法规体系。</p></li><li><p>推动建立新型国际关系，还要把相互尊重、公平正义、合作共赢理念体现到政治、经济、安全、文化等对外合作的方方面面，推动构建人类命运共同体。</p></li></ol></li></ul><h3 id="78-构建人类命运共同体思想"><a href="#78-构建人类命运共同体思想" class="headerlink" title="78.构建人类命运共同体思想"></a>78.构建人类命运共同体思想</h3><ul><li><p><em>构建人类命运共同体思想，具有鲜明的时代背景：</em> </p></li><li><p>构建人类命运共同体思想的核心：“建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界。”</p><blockquote><p>考：</p><p>相互对应，注意政治上和安全上的区别。</p></blockquote><ol><li>政治上，要相互尊重、平等协商，坚决摒弃冷战思维和强权政治，走对话而不对抗、结伴而不结盟的国与国交往之路。</li><li>安全上，要坚持以对话解决争端、以协商化解分歧，统筹应对传统和非传统安全威胁，反对一切形式的恐怖主义。</li><li>经济上，要同舟共济，促进贸易和投资自由化便利化，推动经济全球化朝着更加开放、包容、普惠、平衡、共赢的方向发展。</li><li>文化上，要尊重世界文明多样性，以文明交流超越文明隔阂、文明互鉴超越文明冲突、文明共存超越文明优越。</li><li>生态上，要坚持环境友好，合作应对气候变化，保护好人类赖以生存的地球家园。</li></ol></li><li><p><em>共商共建人类命运共同体（怎么做）</em> </p><ol><li>坚持和平发展道路，推动建设新型国际关系。</li><li>不断完善外交布局，积极发展全球伙伴关系。</li><li>深度参与全球治理，积极引导国际秩序变革方向。</li><li>推动国际社会从伙伴关系、安全格局、经济发展、文明交流、生态建设等方面建立人类命运共同体作出努力。</li></ol></li></ul><h3 id="79-促进“一带一路”国际合作"><a href="#79-促进“一带一路”国际合作" class="headerlink" title="79.促进“一带一路”国际合作"></a>79.促进“一带一路”国际合作</h3><ul><li>2013年9月和10月，习近平在出访中亚和东南亚国家期间，先后提出共建“丝绸之路经济带”和“21世纪海上丝绸之路”等重大倡议，得到了国际社会的高度关注和积极回应。<ul><li>一带：丝绸之路经济带</li><li>一路：21世纪海上丝绸之路</li></ul></li><li>共建”一带一路“倡议，<strong>目的</strong>是：聚焦互联互通，深化务实合作，携手应对人类面临的各种风险挑战，实现互利共赢、共同发展。</li><li>中国政府倡议，共建“一带一路”恪守联合国宪章的宗旨和原则，坚持开放合作、和谐包容、市场运作、互利共赢。<ul><li>秉持和平合作、开放包容、互学互鉴、互利共赢<strong>的理念</strong>，<em>全方位推进务实合作，打造政治互信、经济融合、文化包容的利益共同体、命运共同体和责任共同体，</em> </li><li>以政策沟通、设施联通、贸易畅通、资金融通、民心相通为<strong>主要内容</strong>加强合作</li></ul></li></ul><h3 id="80-中国共产党的领导地位是历史和人民的选择"><a href="#80-中国共产党的领导地位是历史和人民的选择" class="headerlink" title="80.中国共产党的领导地位是历史和人民的选择"></a><em>80.中国共产党的领导地位是历史和人民的选择</em></h3><ul><li>中国共产党是中国工人阶级<strong>的先锋队，</strong>同时是中国人民和中华民族的<strong>先锋队</strong>，是中国特色社会主义事业的<strong>领导核心</strong>。</li></ul><h3 id="81-中国特色社会主义最本质的特征"><a href="#81-中国特色社会主义最本质的特征" class="headerlink" title="81.中国特色社会主义最本质的特征"></a>81.中国特色社会主义最本质的特征</h3><ol><li><p>党的领导是中国特色社会主义最本质的特征</p><ul><li><p><strong>中国共产党的领导</strong>是<strong>中国特色社会主义最本质的特征</strong>，这是十八大以来习近平提出的一个重要论断。</p><p>原因：</p><ol><li>这是由科学社会主义的理论逻辑所决定的。<ul><li>坚持无产阶级政党的领导是无产阶级革命和社会主义建设取得胜利的<strong>根本保证</strong>。</li></ul></li><li>这是由中国特色社会主义产生与发展的历史逻辑所决定的。</li><li>这是由中国特色社会主义迈向新征程的实践逻辑所决定的。</li></ol></li><li><p>十三届全国人大一次会议审议通过的宪法修正案，把“中国共产党的领导是中国特色社会主义最本质的特征“载入宪法总纲。</p></li></ul></li><li><p>党的领导是中国特色社会主义制度的最大优势</p><p>原因：</p><ol><li>中国特色社会主义制度是中国共产党领导人民创建的。</li><li>党的领导是中国特色社会主义制度优势发挥的根本保障。</li><li>党的优势是中国特色社会主义制度优势之源。</li></ol></li></ol><h3 id="82-新时代中国共产党的历史使命"><a href="#82-新时代中国共产党的历史使命" class="headerlink" title="82.新时代中国共产党的历史使命"></a>82.新时代中国共产党的历史使命</h3><ul><li><p>新时代中国共产党的<strong>历史使命</strong>：就是统揽伟大斗争、伟大工程、伟大事业、伟大梦想，在全面建成小康社会的基础上全面建成社会主义现代化强国，实现中华民族伟大复兴的中国梦。</p><blockquote><p>辨析：</p><p>历史任务：祖国统一、社会主义现代化、世界和平</p><p>历史使命：伟大斗争、伟大工程、伟大事业、伟大梦想</p></blockquote><ul><li>伟大梦想是<strong>目标</strong>，指引前进方向</li><li>伟大斗争是<strong>手段</strong>，激发前进动力</li><li>伟大工程是<strong>保障</strong>，提高前进保证</li><li>伟大事业是<strong>主体</strong>，开辟前进道路</li><li>起<strong>决定性作用</strong>的是党的建设<strong>伟大工程</strong></li></ul></li></ul><h3 id="83-坚持党对一切工作的领导"><a href="#83-坚持党对一切工作的领导" class="headerlink" title="83.坚持党对一切工作的领导"></a><em>83.坚持党对一切工作的领导</em></h3><ul><li><p>党是最高的政治领导力量</p></li><li><p>确保党始终总揽全局协调各方</p></li><li><p>全面增强党的执政本领</p><p>怎么做？</p><ol><li>增强学习本领</li><li>增强政治领导本领</li><li>增强改革创新本领</li><li>增强科学发展本领</li><li>增强依法执政本领</li><li>增强群众工作本领</li><li>增强狠抓落实本领</li><li>增强驾驭风险本领</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这学期马原毛概并举，政治知识储备达到巅峰qwq&lt;/p&gt;
&lt;p&gt;看着徐涛老师的政治课复习，做了些许笔记，做个总结分享出来。&lt;/p&gt;
&lt;p&gt;社会主义好，共产主义好！&lt;/p&gt;
&lt;p&gt;八个明确，十四个坚持背的溜溜的orz&lt;/p&gt;
&lt;p&gt;不过，对于毛中特的期末考试来说，这个一定要多听听老师勾的重点！！&lt;/p&gt;
    
    </summary>
    
    
      <category term="政治" scheme="https://f7ed.com/categories/%E6%94%BF%E6%B2%BB/"/>
    
    
      <category term="政治" scheme="https://f7ed.com/tags/%E6%94%BF%E6%B2%BB/"/>
    
      <category term="马克思主义" scheme="https://f7ed.com/tags/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>「政治」:马克思主义</title>
    <link href="https://f7ed.com/2021/01/16/Marxism/"/>
    <id>https://f7ed.com/2021/01/16/Marxism/</id>
    <published>2021-01-15T16:00:00.000Z</published>
    <updated>2021-01-16T08:09:53.258Z</updated>
    
    <content type="html"><![CDATA[<p>这学期马原毛概并举，政治知识储备达到巅峰qwq</p><p>看着徐涛老师的政治课复习，做了些许笔记，做个总结分享出来。</p><p>「哲学们只是用不同的方式解释世界，而问题在于改变世界。——卡尔·马克思」</p><p>马克思主义真是大智慧！！！</p><a id="more"></a><h1 id="马克思主义哲学"><a href="#马克思主义哲学" class="headerlink" title="马克思主义哲学"></a>马克思主义哲学</h1><h2 id="马克思主义导论"><a href="#马克思主义导论" class="headerlink" title="马克思主义导论"></a>马克思主义导论</h2><h3 id="1-马克思主义的内涵"><a href="#1-马克思主义的内涵" class="headerlink" title="1.马克思主义的内涵"></a>1.马克思主义的内涵</h3><ul><li><p>马克思主义是什么</p><ol><li>（创造者）马克思主义是马克思和恩格斯创立并为后继者所不断发展的科学理论体系，</li><li>（内容）是关于自然、社会、人类思维发展的一般规律的学说。，</li><li>（目的）是关于社会主义必然代替资本主义，最终实现共产主义的学说，</li><li>（立场）是关于无产阶级解放、全人类解放，和每个人自由而全面发展的学说，</li><li>（作用）是指引人民创造美好生活的行动指南。</li></ol></li><li><p>马克思主义的构成</p><ol><li>（方法）马克思主义哲学</li><li>（主体）马克思主义政治经济学</li><li>（归属）科学社会主义</li></ol><blockquote><p>用了马克思主义哲学的方法，创立了马克思主义政治经济学，得出了科学社会主义的结论。</p></blockquote></li></ul><h3 id="2-马克思主义基本原理"><a href="#2-马克思主义基本原理" class="headerlink" title="2.马克思主义基本原理"></a>2.马克思主义基本原理</h3><p><em>马克思主义基本原理是对马克思主义立场、观点、方法的集中概括</em> </p><ol><li><p>基本立场</p><ul><li>（人的解放）马克思主义以无产阶级的解放和全人类的解放为己任，</li><li>（人的发展）以人的全面发展为目标，</li><li>（人为中心）以人民为中心，一切为了人民，一切依靠人民。</li></ul></li><li><p>基本观点</p><ul><li>（科学认识）是对自然、社会、人类思维发展一般规律的科学认识</li><li>（科学总结）是对人类思想成果和社会实践经验的科学总结。</li></ul></li><li><p>基本方法</p><ul><li><p>辩证唯物主义和历史唯物主义的世界观和方法论。</p><p><em>实事求是的方法、辩证分析的方法、社会基本矛盾和主要矛盾分析的方法、阶级分析的方法、群众路线的方法</em> </p></li></ul></li></ol><h3 id="3-马克思主义的来源"><a href="#3-马克思主义的来源" class="headerlink" title="3.马克思主义的来源"></a>3.马克思主义的来源</h3><ul><li>第一个无产阶级同盟：正义者同盟</li><li>第一个无产阶级政党：共产主义者同盟</li><li>1844年马恩《德法年鉴》：完成了唯心主义向唯物主义的、从革命民主主义向共产主义的转变，为创立马克思主义奠定思想基础。</li><li>1844年马恩《德意志形态》：首次系统阐述了历史唯物主义的基本观点，历史观的伟大变革。</li><li>1848年马恩《共产党宣言的发表》标志马克思主义的公开问世。</li><li>马克思《资本论》：系统阐述剩余价值学说，揭示资本主义生产关系的密码</li></ul><blockquote><p>马克思一生的伟大发现：唯物史观和剩余价值学说</p></blockquote><ul><li>马克思《法兰西内战》：高度赞扬巴黎工人的伟大创举，科学总结了巴黎公社的历史经验</li><li>马克思《哥达纲领批判》：丰富科学社会主义学说</li><li>恩格斯《反杜林论》：全面阐述马克思主义理论体系</li></ul><h3 id="4-马克思主义的产生条件"><a href="#4-马克思主义的产生条件" class="headerlink" title="4.马克思主义的产生条件"></a>4.马克思主义的产生条件</h3><p><em>马克思主义的产生具有深刻的社会根源、阶级基础和思想渊源</em> </p><ol><li><p>社会渊源：马克思、恩格斯生活的时代，资本主义生产方式在西欧已经有相当的发展。</p><blockquote><p>资本主义一方面带来社会化大生产的迅猛发展，一方面又造成严重的社会灾难：</p><ol><li>社会两极化，工人极端困苦</li><li>周期性经济危机频繁爆发</li></ol></blockquote></li><li><p>阶级基础/实践基础：无产阶级在反抗资产阶级剥削和压迫的斗争中，逐渐走向自觉，并迫切渴望科学的理论指导。</p><blockquote><p>工人运动：法、英、德</p><ul><li>1831年法国里昂工人</li><li>1836年英国工人运动——宪章运动：集中反映工人的政治需求</li><li>1844年德国西里西亚纺织工人举行起义：标志现代无产阶级作为独立的政治力量登上历史舞台</li></ul></blockquote></li><li><p>思想渊源：德国古典哲学、英国古典政治经济学、英法两国空想社会主义</p><blockquote><ul><li>德国古典哲学：辩证法</li><li>英国古典政治经济学：资本主义生产关系的分析和关于劳动创造价值的思想</li><li>空想社会主义：对资本主义社会的批判和对未来新社会的发展</li><li>19世纪三大科学发现：细胞学说、能量守恒和能量转化定律、生物进化论</li></ul></blockquote></li></ol><h3 id="5-马克思主义的特征"><a href="#5-马克思主义的特征" class="headerlink" title="5.马克思主义的特征"></a>5.马克思主义的特征</h3><blockquote><p>考：特征和解释对应，一段材料反映什么样的特征。</p></blockquote><ul><li><p>科学性：马克思主义是对自然、社会和人类思维发展本质和规律的<strong>正确</strong>反映 。</p></li><li><p>革命性：马克思主义的革命性集中表现为<strong>彻底的批判精神</strong>和<strong>鲜明的无产阶级立场</strong>。 </p></li><li><p>实践性：马克思主义是从实践中来，到实践中去，在实践中接受检验，并随实践不断发展的学说。</p><blockquote><p>实践性是马克思主义独有的特征，可以区分其他派别。</p></blockquote></li><li><p>人民性：人民至上是马克思主义的政治立场。</p><p><em>马克思主义的人民性是以阶级性为深刻基础的，是无产阶级先进性的的体现</em> </p><blockquote><p>以阶级性为基础，表示只要你是无产阶级，你就代表人民</p></blockquote></li><li><p>发展性：马克思是不断发展的学说，具有与时俱进的品质。马克思主义理论体系是开放的，不断吸收人类最新的文明成果来充实和发展自己。</p></li></ul><h2 id="哲学基本问题"><a href="#哲学基本问题" class="headerlink" title="哲学基本问题"></a>哲学基本问题</h2><h3 id="6-哲学的基本问题"><a href="#6-哲学的基本问题" class="headerlink" title="6.哲学的基本问题"></a>6.哲学的基本问题</h3><ul><li><p>哲学的基本问题：思维和存在的问题。（意识/精神和物质的问题。）</p><ol><li><p>存在和思维何者是第一性，何者是第二性。</p><p><em>该问题的回答，构成了划分唯物主义和唯心主义的标准</em></p></li><li><p>物质和意识是否具有同一性。</p><p><em>即思维能否正确认识存在的问题</em> </p></li></ol></li></ul><h3 id="6-哲学的不同流派"><a href="#6-哲学的不同流派" class="headerlink" title="6.哲学的不同流派"></a>6.哲学的不同流派</h3><p><em>通过对哲学基本问题的回答来划分哲学的流派</em></p><ul><li><p>存在和思维何者是第一性，何者是第二性。</p><ol><li><p>唯物主义：物质第一性</p><p><em>什么才是物质？划分唯物主义中的流派</em> </p><ul><li><p>古代朴素（古典）唯物主义：物质是某一种或者几种</p><blockquote><p>五行；火；一生二，二生三，三生万物。</p></blockquote></li><li><p>近代形而上学唯物主义：物质是原子或粒子</p><blockquote><p>其中机械唯物主义是近代形而上学唯物主义</p><p>近代形而上学唯物主义&gt;机械唯物主义</p></blockquote></li><li><p>现代辩证唯物主义：一切客观存在的都是物质</p><blockquote><p>把历史作为物质。</p><p>唯物史观：把历史作为物质来分析，得出的观点和结论。</p><p>=马克思主义</p></blockquote></li></ul></li><li><p>唯心主义：意识第一性</p><p><em>什么才是意识</em> </p><ul><li><p>主观唯心主义：世界的本原是人的意识。</p></li><li><p>客观唯心主义：世界的本原是独立于“我”之上的。</p><blockquote><p>比如上帝、道、理、缘说等</p></blockquote></li></ul></li></ol></li><li><p>物质和意识是否具有同一性</p><ol><li><p>可知论：意识可以认识物质。</p><blockquote><p>唯物主义和唯心主义都属于可知论，只是唯物主义是物质决定意识，顺序不同。</p></blockquote></li><li><p>不可知论：意识不可以或者不能完全认识物质。</p><blockquote><p>二元论：认为物质和意识都是世界的本原。</p><p>二元论属于不完全的唯心主义。</p></blockquote></li></ol></li></ul><h3 id="6-哲学的重要问题"><a href="#6-哲学的重要问题" class="headerlink" title="6.哲学的重要问题"></a>6.哲学的重要问题</h3><ul><li><p>哲学的重要问题：世界是什么样的。</p><blockquote><p>先回答哲学的基本问题：唯物主义或唯心主义</p><p>再回答哲学的重要问题：形而上学或辩证法。</p></blockquote><ol><li><p>形而上学：世界是孤立的、片面的、静止的、无矛盾的</p></li><li><p>辩证法：世界是联系的、全面的、发展的、矛盾的</p><blockquote><p>辩证法是一种观点，回答世界是什么样的观点。</p></blockquote></li></ol></li><li><p>哲学流派的划分</p><p><em>先回答哲学的基本问题，再回答哲学的重要问题</em></p><ol><li>形而上学的唯物主义</li><li>形而上学的唯心主义</li><li>辩证唯心主义</li></ol><p><em>在马克思主义出现之前，没有辩证唯物主义的组合</em> </p><ol start="4"><li>辩证唯物主义</li></ol></li><li><p>马克思在哲学的两大贡献</p><ol><li>创立了历史唯物主义（唯物史观）：将历史作为物质来研究得出的观点和结论。</li><li>形成了辩证唯物主义：将辩证法的观点和唯物主义结合。</li></ol></li></ul><h3 id="马克思主义的当代价值"><a href="#马克思主义的当代价值" class="headerlink" title="马克思主义的当代价值"></a>马克思主义的当代价值</h3><ol><li>观察当代世界变化的工具</li><li>指引当代中国发展的行动指南</li><li>引领人类社会进步的科学真理</li><li>自觉学习和运用马克思主义</li></ol><h2 id="唯物论-物质观"><a href="#唯物论-物质观" class="headerlink" title="唯物论-物质观"></a>唯物论-物质观</h2><p>框架：</p><ul><li>物质范畴：什么是物质</li><li>物质和运动</li><li>运动和静止</li><li>物质运动和时空</li></ul><h3 id="7-物质范畴：什么是物质"><a href="#7-物质范畴：什么是物质" class="headerlink" title="7.物质范畴：什么是物质"></a>7.物质范畴：什么是物质</h3><p><em>马克思批判了旧唯物主义对物质世界的直观、消极理解，强调要从能动的实践出发去把握客观世界的意义</em></p><ul><li><p>恩格斯的物质概念：物、物质是各种物的总和，这个概念是从这个总和中<strong>抽象</strong>而来的。</p><blockquote><p>考点：物质和具体物的关系：抽象和具体的关系</p></blockquote></li><li><p>列宁的定义：</p><p><em>定义方式：通过物质和意识的关系定义</em></p><ol><li>（客观实在）物质是标志客观实在的哲学范畴，</li><li>（人的感觉）这种客观实在是人通过感觉感知的，不依赖于人的感觉而存在，为我们的感觉所复写、摄影、反映。</li></ol></li><li><p>物质的唯一特性（最本质的特性）：客观实在性</p><p><em>马克思的物质范畴从客观存在的物质世界抽象出万物的共同特性：客观实在性</em> </p></li><li><p>马克思主义的物质范畴理论的意义：（两个坚持两个体现）</p><ol><li><p>坚持唯物主义一元论，同唯心主义一元论和二元论划清界限。</p><p><em>马克思主义是从物质与意识的对立统一关系中把握和规定物质的，物质最本质的特征是客观实在性，这就指明了物质对于意识的独立性、根源性，以及意识对于物质的依赖性、派生性。因为意识不过是物质的反映，不能离开物质而独立存在，所以意识不可能成为另一种本原</em></p></li><li><p>坚持能动反映论和可知论，批判不可知论。</p><p><em>世界上还有很多事物未被人类认识，但这并不意味着它们不可认识</em> </p></li><li><p>体现了唯物论和辩证法的统一，克服了形而上学唯物主义的缺陷</p></li><li><p>体现了唯物主义自然观和唯物主义历史观的统一</p></li></ol></li></ul><h3 id="8-物质和运动"><a href="#8-物质和运动" class="headerlink" title="8.物质和运动"></a>8.物质和运动</h3><ul><li><p>物质的定义：不依赖于人的意识而存在，并能为人类的意识所反映的客观存在。</p></li><li><p>运动的定义：运动是标志一切事物和现象的变化及其过程的哲学范畴</p></li><li><p>物质和运动的关系：</p><ul><li><p>物质和运动的关系：不可分割</p><blockquote><p>不可分割：我是你的我，你是我的你</p></blockquote><p>物质是运动着的物质，运动是物质在运动。</p></li><li><p>物质的根本属性（固有属性）是运动。</p><blockquote><p>物质的唯一特性：客观实在性。</p><p>物质的根本属性：运动。</p></blockquote></li><li><p>物质的存在方式是运动。</p></li></ul></li><li><p>批判两种错误的观点：运动——物质</p><ul><li>脱离物质谈运动，则是唯心主义。</li><li>脱离运动谈物质，则是形而上学。</li></ul></li></ul><h3 id="9-运动和静止"><a href="#9-运动和静止" class="headerlink" title="9.运动和静止"></a>9.运动和静止</h3><ul><li><p>相对静止的定义：静止是物质运动在一定条件下的稳定状态，包括两种状态：空间的相对位置暂时不变和事物的根本性质暂时不变。</p></li><li><p>运动和静止的关系：对立统一</p><blockquote><p>对立统一：相互区别；相互联系。（相同词性）</p><p>不可分割：我是你的我，你是我的你。（不同词性）</p></blockquote><ul><li><p>相互区别：运动是绝对的、无条件性的；静止是相对的、有条件性的。</p></li><li><p>相互联系：运动和静止是相互依赖、相互渗透，“动中有静，静中有动“。</p><blockquote><p>鸟鸣山更幽，风定花犹落。</p></blockquote></li></ul></li><li><p>批判两种错误的观点：运动——静止</p><ul><li><p>夸大静止，否定运动，导致形而上学。</p></li><li><p>夸大运动，否定静止，导致诡辩论。</p><blockquote><p>人不能两次踏入同一条河流。（正确）</p><p>人没有一次能踏入同一条河流。（错误）</p></blockquote></li></ul></li></ul><h3 id="10-物质运动和时空"><a href="#10-物质运动和时空" class="headerlink" title="10.物质运动和时空"></a>10.物质运动和时空</h3><ul><li><p>时空的概念：时间是物质运动的持续性、顺序性，特点是一维性，即时间一去不复返。空间是物质运动的广延性、伸展性，特点是三维性。</p></li><li><p>时空和物质运动的关系：</p><ul><li><p>不可分割：时空是物质运动的时空，物质运动是时空中的物质运动。</p></li><li><p>物质运动的存在形式是时空。</p><blockquote><p>物质运动的存在形式是时空。</p><p>时间是物质运动的存在形式。正确</p><p>空间是物质运动的存在形式。正确</p></blockquote></li></ul></li><li><p>时空的特点：（五个特点）</p><blockquote><p>考察：给一段材料，体现了时空的什么特点</p></blockquote><ul><li><p>客观性：不以人的意志为转移。</p><p><em>物质运动与时空不可分割，证明时间和空间的客观性</em></p></li><li><p>绝对性：时空是绝对存在的。</p></li><li><p>相对性：当速度突破极限，时空会发生变化。</p></li><li><p>有限性：具体物质形态的时空是有限的。</p></li><li><p>无限性：整个物质世界的时空是无限的。</p></li></ul></li></ul><h2 id="唯物论-意识观"><a href="#唯物论-意识观" class="headerlink" title="唯物论-意识观"></a>唯物论-意识观</h2><p>框架：</p><ul><li>实践：物质世界和意识世界的桥梁</li><li>意识的起源</li><li>意识到本质</li><li>意识到作用</li><li>物质和意识的辩证关系</li></ul><h3 id="11-实践：是自然存在和社会存在区分和统一的基础"><a href="#11-实践：是自然存在和社会存在区分和统一的基础" class="headerlink" title="11.实践：是自然存在和社会存在区分和统一的基础"></a>11.实践：是自然存在和社会存在区分和统一的基础</h3><p><em>人类的产生使自然界的运动变化发生了新的飞跃，并通过人的实践形成了自然界与人类社会的区别</em></p><ul><li><p>社会生活的本质是实践。</p><p><em>全部社会生活的本质是实践。</em> </p></li><li><p>从实践出发理解社会生活的本质</p><ol><li><p>实践是使物质世界分化为自然界和人类社会的历史前提，又是使自然界与人类社会统一起来的现实基础。</p><blockquote><p>物质世界：一切客观存在。</p><p>在没有人之前，物质世界是自然界，有人之后，人的实践使其分为自然界和人类社会。</p><p>也通过实践，两部分相互转换，统一。</p></blockquote><p><em>实践活动过程中，物质世界被区分为自然界和人类社会两大领域</em></p><p><em>劳动是人的存在方式，也是人类社会存在与发展的基础。通过劳动实践，人不再是单纯的自然存在物，更主要是社会存在物。</em></p></li><li><p>实践是人类社会的基础，是理解和解释一切社会现象的钥匙。</p><blockquote><p>人类社会的本质是实践，把社会生活当作实践去理解。</p></blockquote><ul><li><p>社会生活的实践性体现在（为什么说实践是社会生活的本质）</p><p><em>社会生活是对人民各种社会活动的总称</em> </p><ol><li><p>实践是社会关系形成的基础。</p><p><em>包含了全部社会关系，是社会关系的发源地</em>。</p></li><li><p>实践形成了社会生活的基本领域。</p><p><em>即社会的物质生活、政治生活和精神生活领域。</em> </p></li><li><p>实践 <strong>构成了</strong> 社会发展的动力。</p><blockquote><p>考：构成动力，而不是 是动力，社会发展的动力是社会基本矛盾。</p></blockquote></li></ol></li></ul></li></ol></li><li><p>实践是自然存在和社会存在区分和统一的基础。</p><blockquote><p>自然存在是自然界，社会存在是人类社会。</p></blockquote></li></ul><h3 id="12-意识的起源"><a href="#12-意识的起源" class="headerlink" title="12.意识的起源"></a>12.意识的起源</h3><ul><li><p>意识的概念：</p><ol><li>（物质的产物）物质世界长期发展的产物，</li><li>（本质）意识是人脑这样一种特殊物质的机能和属性，</li><li>（最本质）是物质/客观世界的主观映像。</li></ol></li><li><p>意识的起源：</p><ol><li><p>由一切事物所具有的反映特性到低等生物所具有的刺激感应性，</p><blockquote><p>一切事物的物理性质，化学性质，到低等生物的应激性反应。</p></blockquote></li><li><p>再到高等动物的感觉和心理，</p><blockquote><p>高等动物的开心、难过等情绪和疼痛等感觉</p></blockquote></li><li><p>最终发展为人的意识。</p><blockquote><p>意识是人所特有的</p></blockquote></li></ol></li><li><p>意识形成过程中的影响因素：</p><p><em>意识是自然界长期发展的产物，也是社会历史发展的产物</em> </p><p><em>意识有很多影响因素，其中</em> </p><ul><li><p>劳动：社会实践，特别是劳动，在意识到产生和发展中起<strong>决定作用</strong>。</p></li><li><p>语言：人们在劳动和交往中形成的语言，<strong>促进</strong>了意识的发展。</p><ul><li><p>语言是意识的物质外壳。</p><blockquote><p>语言是物质，语言的含义是意识。</p></blockquote></li></ul></li></ul></li></ul><h3 id="12-意识的本质"><a href="#12-意识的本质" class="headerlink" title="12.意识的本质"></a>12.意识的本质</h3><ul><li><p>意识的本质：意识是客观世界的主观映像，是客观内容和主观形式的统一。</p><p><em>意识在内容上客观的，在形式上主观的，是客观内容和主观形式的统一</em></p><p><em>意识是物质的产物，又不是物质本身，因此在内容上是反应物质的，是客观存在的，在形式上是主观的映像。</em> </p></li></ul><h3 id="12-意识的作用"><a href="#12-意识的作用" class="headerlink" title="12.意识的作用"></a><font color='red'>12.意识的作用</font></h3><ul><li><p>意识的作用：能动作用</p><p><em>物质决定意识，意识对物质具有反作用，这种反作用就是意识的能动作用</em> </p></li><li><p>意识到能动作用表现在：</p><ol><li><p>意识活动具有自觉性，具有目的性和计划性。</p><blockquote><p>人认识世界时，根据一定的目的和要求去确定反映什么、不反映什么、怎么反应，表现出主体的选择性。</p></blockquote></li><li><p>意识活动具有创造性。</p><blockquote><p>意识是对所见的东西，在头脑中进行加工想象。</p></blockquote></li><li><p>意识具有指导实践改造客观世界的作用。</p><p><em>意识到能动性不限于从实践中形成思想，形成活动的目的、计划、方法等观念的东西，更重要的是，将这些观念作为指导，通过实践使之成为客观现实。</em> </p><blockquote><p>可以创造出世界上原本没有的东西。</p></blockquote></li><li><p>意识具有指导、控制人的行为和生理活动的作用。</p><p><em>意识、心理对人的行为和健康有重要影响，”笑一笑十年少，愁一愁，白了头。</em>  </p><blockquote><p>想做的事，能通过意识不做这件事。</p></blockquote></li></ol></li></ul><h3 id="13-物质和意识的辩证关系"><a href="#13-物质和意识的辩证关系" class="headerlink" title="13.物质和意识的辩证关系"></a>13.物质和意识的辩证关系</h3><blockquote><p>两大关系：不可分割和对立统一，对立统一即辩证关系。</p></blockquote><ul><li><p>物质和意识相互区别：</p><ol><li><p>物质是本原，意识是派生。</p></li><li><p>物质不是意识，意识不是物质。</p><blockquote><p>大脑的分泌物是意识。错误。</p></blockquote></li><li><p>物质不能代替意识，意识不能代替物质。</p></li></ol></li><li><p>物质和意识相互联系：</p><ol><li><p>物质可以转换为意识，意识可以转换为物质。</p></li><li><p>意识对物质既有依赖性，又有相对独立性。</p><blockquote><p>把物质作为强，意识作为弱，但没有那么弱，弱的要依赖于强的，但也要有自己的独立性。</p></blockquote></li><li><p>物质决定意识，意识反作用于物质。</p><blockquote><p>强的决定弱的。</p></blockquote></li></ol></li><li><p>主观能动性和客观规律性的统一</p><p><em>正确认识和处理物质和意识的辩证统一，还需要处理好主观能动性和客观规律性的关系</em> </p><ul><li><p>主观能动性和客观规律性的关系（物质世界）</p><ul><li>一方面，尊重客观规律是正确发挥主观能动性的前提。</li><li>另一方面，只有充分发挥主观能动性，才能正确认识和利用客观规律。</li></ul></li><li><p>正确发挥人的主观能动性的前提和条件：</p><ol><li>前提：从实际出发是发挥人的主观能动性的前提。</li><li>基本途径：实践是正确发挥人的主观能动性的基本途径。</li><li>正确发挥人的主观能动性，还需要依赖一定的物质条件和物质手段。</li></ol><blockquote><p>类比考研：从实际出发，实践，依赖一定的条件和手段</p></blockquote></li><li><p>主观能动性和客观规律性的关系（人类历史的角度：社会领域）</p><ul><li><p>社会历史领域，主观能动性和客观规律的辩证关系具体表现在社会历史趋向与主体选择的关系   </p><blockquote><p>社会历史趋向，即，客观规律。</p></blockquote></li></ul><blockquote><p>主体选择，即，主观能动。</p></blockquote><p>  <em>社会历史趋向是指社会历史规律的客观性和必然性</em> </p><p>  <em>主体选择是指社会主体在社会发展中的能动性和选择性</em> </p><p>  <em>社会历史规律的客观性和必然性规定了人的活动要受到规律的限制，但又不能否认人作为历史主体的能动性和选择性</em> </p></li></ul></li></ul><h3 id="14-世界的物质统一性原理"><a href="#14-世界的物质统一性原理" class="headerlink" title="14.世界的物质统一性原理"></a>14.世界的物质统一性原理</h3><blockquote><p> 总结性，命题的方向</p><ol><li>世界是统一的，即世界的本原只有一个。（批判二元论）</li><li>世界的统一性在于他的物质性，即世界统一的基石是物质。（批判唯心主义）</li><li>物质世界的统一性是多样性的统一，而不是单一的无差别的统一。（批判旧唯物主义，即马哲之前的唯物主义）</li></ol></blockquote><ul><li><p>马克思主义哲学与唯心主义的比较</p><ul><li><p>联系：都是可知论。</p><blockquote><p>都是一元论，认为世界的本原只有一个。</p></blockquote></li><li><p>区别：</p><ol><li><p>（本原）马克思主义哲学认为物质是本原，唯心主义认为意识是本原。</p></li><li><p>（认识论）马克思主义哲学在认识问题上坚持能动反映论，唯心主义坚持先验论。</p></li><li><p>（辩证法）马克思主义哲学坚持彻底的辩证法，唯心主义部分坚持辩证法。</p><blockquote><p>唯心主义中也有形而上学的唯心主义和辩证唯心主义。</p></blockquote></li><li><p>（历史观）马克思主义哲学在历史观上是唯物的，唯心主义在历史观上是唯心的。</p></li></ol></li></ul></li><li><p>马克思主义与旧唯物主义的比较。</p><ul><li><p>联系：都是唯物主义，认为物质是世界的本原。</p></li><li><p>区别：</p><ol><li><p>（认识论）马克思主义哲学在认识论上坚持能动反映论，旧唯物主义坚持机械反映论。</p></li><li><p>（辩证论）马克思主义哲学彻底坚持辩证法，旧唯物主义完全不认同辩证法，坚持形而上学。</p></li><li><p>（历史观）马克思主义哲学在历史观上唯物，旧唯物主义在历史观上唯心。</p></li><li><p>（实践）马克思主义哲学坚持实践的观点，旧唯物主义没有实践的观点。</p><blockquote><p>实践是马克思独有的观点</p></blockquote></li></ol></li></ul></li><li><p>世界统一于物质的观点</p><ol><li><p>（意识）世界的物质统一性首先体现在，意识统一于物质。</p><blockquote><p>意识是物质发展的产物。</p></blockquote></li><li><p>（人类社会）世界的物质统一性还体现在，人类社会也统一于物质。</p><blockquote><p>人类社会（历史）是物质。</p></blockquote></li></ol><ul><li><p>人类社会的物质性</p><ol><li><p>（物质世界）人类社会是物质世界的组成部分。</p><blockquote><p>物质世界包含人类社会。</p></blockquote></li><li><p>（物质资料的获取）人类获取物质生活资料的实践活动，虽然是意识指导，但仍然是物质性的活动。</p><blockquote><p>实践活动是物质：</p><p>社会生活的本质是实践。</p><p>社会生活/人类社会是物质的，实践是物质。</p></blockquote></li><li><p>（物质资料的生产）物质资料的生产方式，是人类存在和发展的基础，集中体现人类社会的物质性。</p><blockquote><p>生产方式是物质：</p><p>实践是社会关系的基础，包含所有社会关系。</p><p>实践是物质的，物质资料的生产方式也是物质的。</p></blockquote></li></ol></li></ul></li></ul><h3 id="14-世界的物质统一性原理的意义"><a href="#14-世界的物质统一性原理的意义" class="headerlink" title="14.世界的物质统一性原理的意义"></a><font color='red'>14.世界的物质统一性原理的意义</font></h3><p><em>世界的物质统一性原理的作用</em> </p><ol><li><p>（理论上）世界的物质统一性是马克思主义的基石。</p></li><li><p>（实践上：一切从实际出发）在认识和改造世界过程中，坚持实事求是，一切从实际出发，是世界的物质统一原理体现在现实生活中和实际工作中的生动体现。</p><blockquote><p>考：材料关于一切从实际出发，问题问这段材料体现什么哲学原理</p><p>：世界的物质统一性原理</p></blockquote></li></ol><h2 id="辩证法-两大总特征"><a href="#辩证法-两大总特征" class="headerlink" title="辩证法-两大总特征"></a>辩证法-两大总特征</h2><ul><li><p>两大总特征</p><ol><li>普遍联系</li><li>永恒发展</li></ol></li><li><p>五对范畴：联系和发展环节上的逻辑</p><blockquote><p>怎样的联系。</p><p>怎么发展</p></blockquote></li><li><p>三大规律</p><blockquote><p>事物怎么联系</p></blockquote><ol><li>对立统一</li><li>质量互变</li><li>否定之否定</li></ol></li></ul><h3 id="15-唯物辩证法两大总特征"><a href="#15-唯物辩证法两大总特征" class="headerlink" title="15.唯物辩证法两大总特征"></a>15.唯物辩证法两大总特征</h3><p><em>唯物辩证法的总观点和总特征：联系和发展</em> </p><ul><li><p>两大总特征：</p><ol><li>普遍联系</li><li>永恒发展</li></ol></li><li><p>普遍联系</p><ul><li><p>联系的概念：联系是指事物内部各要素之间 <strong>和</strong> 事物之间相互影响、相互制约、相互作用的关系。</p><blockquote><p>联系是以区别为前提。</p></blockquote></li><li><p>联系的特点：</p><blockquote><p>考：材料体现联系什么特点</p></blockquote><ul><li><p>客观性：联系是事物本身固有的，不是主观臆想的。</p></li><li><p>普遍性：</p><ol><li>（事物内部）任何事物内部的不同部分和要素是相互联系，即任何事物都有内部结构性。</li><li>（事物间）任何事物都不能孤立存在，都同其他事物处于一定的相互联系中中。</li><li>（世界是一个联系网）整个世界是相互联系的统一整体，每个事物都是世界普遍联系中的一个成分或环节，并通过这个联系之网体现出联系的普遍性。事物的普遍联系是通过中介实现的，是通过中间性的联系和过渡性环节而实现的。</li></ol></li><li><p>多样性：世界上的事物是多样的，事物之间的联系也是多样的。</p></li><li><p>条件性</p><p><em>条件是对事物存在和发展发生作用的诸要素的总和。</em> </p><ol><li><p>（支持或制约）条件对事物发展和人的活动具有<strong>支持或制约</strong>作用。</p><blockquote><p>有利条件促进发展，不利条件抑制发展。</p></blockquote></li><li><p>条件是可以改变的。</p><blockquote><p>将不利条件转化为有利条件。</p></blockquote></li><li><p>改变和创造条件不是任意的，必需尊重事物发展的客观规律。</p></li></ol></li></ul></li></ul></li><li><p>永恒发展</p><ul><li><p>发展的概念：概括一切形式的变化是运动，运动变化的趋势是发展。</p><blockquote><p>运动=变化 &gt; 发展</p><p>运动：标志一切事物和现象变化及其过程的哲学范畴。</p><p>运动可以是前进或者后退的方向，变化也是可以往好的和不好的方向。</p><p>但发展是运动变化的趋势，是前进的，是上升的。</p><p>因此运动是绝对的无条件的，发展不是，发展是永恒的。</p></blockquote></li><li><p>发展的实质：前进的上升的运动，新事物的产生和旧事物的灭亡。</p><ul><li>新事物：合乎历史前进方向、具有远大前途的东西。</li><li>旧事物：丧失历史必然性、日趋灭亡的东西。</li></ul><blockquote><p>新旧事物的区分是：通过历史趋势来看的。而与时间的先后无关。</p></blockquote><ul><li><p>新事物是不可战胜的：</p><ol><li><p>新事物具有新结构，适应新环境。</p><p><em>新事物之所以新，是因为新事物有新的要素、结构和功能，它适应已经变化了的环境和条件；旧事物之所以旧，是因为他的各种要素和功能已经不适应环境和客观条件的变化</em></p></li><li><p>新事物是旧事物的改良，吸收了旧的优点。</p><p><em>新事物否定了旧事物中消极腐朽的东西，又保留了旧事物中合理的、适应新条件的因素，并添加了旧事物所不能容纳的新内容</em> </p></li><li><p>新事物符合群众利益，受到群众拥护。</p></li></ol></li></ul></li></ul></li><li><p>过程的观点</p><ul><li><p>恩格斯指出：“世界不是既成事物的集合体，而是过程的集合体。”</p><p><em>事物的发展是一个过程，只有经过一定的过程，事物才能实现自身的发展。</em> </p><p><em>事物发展的过程，从形式上看，是事物在时间上持续性和空间上广延性的交替；从内容上看，是事物在运动形式、形态、结构、功能和关系上的更替。</em> </p></li><li><p>一切在历史上产生的都要在历史上灭亡。</p></li><li><p>任何事物都有它的过去、现在和将来。</p></li></ul></li></ul><h2 id="辩证法-五对范畴"><a href="#辩证法-五对范畴" class="headerlink" title="辩证法-五对范畴"></a>辩证法-五对范畴</h2><p><em>联系和发展是通过一系列基本环节得以实现的。</em> </p><p>五对范畴：联系和发展环节上的逻辑问题</p><ol><li>原因与结果</li><li>必然与偶然</li><li>可能与现实</li><li>现象与本质</li><li>内容与形式</li></ol><blockquote><p>概念、概念、方法论展开阐述</p></blockquote><h3 id="16-原因和结果"><a href="#16-原因和结果" class="headerlink" title="16.原因和结果"></a>16.原因和结果</h3><ul><li><p>原因和结果：是揭示事物前后相继、彼此制约的关系范畴</p><p><em>原因和结果是揭示事物引起和被引起关系的一对范畴</em> </p><blockquote><p>前后相继，则是因果，错误。</p><p>发生在你之前的不一定是原因。比如雷电不是因果。</p></blockquote><ul><li>原因：引起某种现象的现象</li><li>结果：被某种现象引起的现象</li></ul></li><li><p>辩证关系：对立统一</p><ol><li><p>（确定又不确定）原因和结果的区分既是确定的，又是不确定。</p><blockquote><p>在某一种具体因果关系中，原因和结果是相互区别的，原因就是原因，结果就是结果。</p><p>但整体来说，一种现象在一种联系中是原因，在另一种现在中可能是结果。</p></blockquote></li><li><p>（互为因果）原因和结果相互作用，原因产生结果，结果反影响原因。互为因果。</p></li><li><p>（互相表达）原因和结果互相渗透，结果存在在原因中，原因出现在结果之中。</p><blockquote><p>知道原因，可以预测结果，知道结果，可以反推原因。原因结果互相表达。</p></blockquote></li><li><p>（关系复杂）原因和结果的关系复杂多样，有一因多果、同因异果、一果多因、异因同果、多因多果、复因多果。</p><blockquote><p>有其因，必有其果。错误。原因结果的关系复杂，有一因多果的情况。</p><p>有因必有果。正确。</p></blockquote></li></ol></li><li><p>方法论：凡事预则立不预则废。</p><blockquote><p>做什么事都要先有计划和准备。有因，结果自然就有了。</p><p>考：故事体现什么哲理。</p><p>如果故事讲的是凡事预则立不预则废，为因果关系哲理，因为该方法论是因果范畴的出的启示。</p></blockquote></li></ul><h3 id="17-必然和偶然"><a href="#17-必然和偶然" class="headerlink" title="17.必然和偶然"></a>17.必然和偶然</h3><ul><li><p>必然和偶然：解释客观事物产生、发展和衰亡过程中不同趋势的一对范畴。</p><ul><li><p>事物的发展既包含必然的方面，也包含偶然的方面。</p><blockquote><p>不是说这件事是必然，这件事是偶然。每一件事都有必然和偶然的成分。</p></blockquote></li><li><p>必然：事物联系与发展中一定要发生、确定不移的趋势。</p></li><li><p>偶然：事物联系和发展过程中并非确定出现，可以出现，可以不出现，可以这样出现，也可以那样出现，具有不确定的趋势。</p></li></ul></li><li><p>关系：对立统一</p><ul><li><p>相互区别：</p><ol><li>产生和形成的原因不同：必然是内部原因；偶然是外部原因。</li><li>他们表现的形式不同：必然是稳定的；偶然是不稳定的。</li><li>他们在事物发展中地位和作用不同：必然起决定作用，偶然起影响作用。</li></ol></li><li><p>相互联系：</p><ol><li><p>一方面，没有脱离偶然的必然（都有偶然的一面，必然是通过多次偶然表现的）。现实事物的发展，不通过偶然而只表现为纯粹的必然的情况是不存在的。必然伴随着偶然，必然要通过偶然表现出来。</p><blockquote><p>我对芒果过敏，但如果我永远不吃芒果，这件事情就不会发生，不会有我过敏的偶然事件发生。</p></blockquote></li><li><p>另一方面，没有脱离必然的偶然（都有必然的一面）。似乎是偶然起支配作用的地方，实际上是必然起决定作用，制约着偶然的作用形式及其变化。</p><blockquote><p>我对芒果过敏，但我不知道。我吃了一次，过敏了，我以为是偶然，我又吃了一次，又过敏了，又以为是偶然。</p><p>虽然是偶然，但其实是我芒果过敏，因此是必然的。</p></blockquote></li></ol><ul><li><p>必然与偶然相互转化。</p><p><em>对于某一过程来说是必然的东西，对另一过程就可能成为偶然的东西。</em> </p><blockquote><p>在生物进化中，某个基因变异会导致新物种的产生，这是偶然转化为必然。</p><p>旧物种的基本性状在新物种中表现为返祖现象，这是必然转化为偶然。</p></blockquote></li></ul></li></ul></li></ul><ul><li>方法论：重视事物发展的必然，把握事物发展的总趋势，又要善于从偶然中发现必然，有利于事物发展的机遇。</li></ul><h3 id="18-现实与可能"><a href="#18-现实与可能" class="headerlink" title="18.现实与可能"></a>18.现实与可能</h3><ul><li><p>现实和可能：揭示事物过去、现在和将来的相互关系的一对范畴。</p><ul><li>可能（潜在的）：事物发展过程中<strong>潜在的东西</strong>，包含在事物中，是事物发展前途的种种趋势。</li><li>现实（实际存在）：相互联系着的<strong>实际存在</strong>的事物的综合。</li></ul></li><li><p>关系：对立统一</p><ul><li><p>区别：一个潜在的，一个实际存在的。</p><p><em>现实是当下的客观存在，标志着事物的当前状况；可能是事物潜在的趋势，标志着事物的发展方向。</em> </p></li><li><p>联系：</p><ol><li>（现实包含可能、现实产生新的可能）一方面，现实蕴藏着未来的发展方向，会不断<strong>产生新的可能</strong>。</li><li>（可能 包含发展为现实的依据，条件成熟可以转化为现实）另一方面，可能包含着发展为现实的因素依据，一旦主客观条件成熟，可能就会<strong>转化为现实</strong>。</li></ol></li><li><p>区分可能性和不可能性的根据是：现实中是否有依据。</p><blockquote><p>如果现实有依据，则是可能性。</p><p>如果现实没有依据，则是不可能。</p></blockquote></li><li><p>区分现实的可能和抽象的可能（潜在的可能）的根据是：在现实中是否有充分的依据</p><blockquote><p>如果有充分的依据，则是现实的可能。</p><p>如果没有充分的依据，则是抽象的可能。</p></blockquote></li></ul></li><li><p>方法论：</p><ul><li>（立足现实，分析可能）一方面，要求人民立足现实，展望未来，对可能性作全面的分析和预判。</li><li>（防止坏的可能变成现象，争取好的可能变为现实）另一方面着远长远，防止坏的可能变为现实，同时善于创造条件，促使好的可能获得实现。</li></ul></li></ul><h3 id="19-现象和本质"><a href="#19-现象和本质" class="headerlink" title="19.现象和本质"></a>19.现象和本质</h3><blockquote><p>考试重要</p></blockquote><ul><li><p>现象和本质：解释客观事物外部表现和内在联系的一对范畴。</p><ul><li>本质：事物内在关系和根本性质，只有靠人的理性思维才能把握。</li><li>现象：事物的外部联系和表面特性，通过人的感官直接感知</li></ul></li><li><p>关系：对立统一</p><ul><li><p>区别：</p><ol><li>现象是个别的、具体的，本质是一般的、普遍的。</li><li>现象是多变的，本质是相对稳定的。</li><li>现象是生动的、丰富的，本质是深刻单纯的。</li></ol><ul><li><p>现象有真象和假象之分。</p><p><em>科学的任务就在于准确辨别真象和假象</em></p><ul><li><p>真象和假象都是现象，都是事物外部联系和表面特性，都通过人的感官直接感知。</p><blockquote><p>都是客观存在的反映，没有正确和错误之分。</p></blockquote></li><li><p>真象是正面直接的反映本质，假象是侧面歪曲的反映本质。</p></li></ul></li><li><p>假象和错觉不是一回事。</p><ul><li>假象也是现象，是客观事物的外在表现，而错觉是错误的感觉，是主观的。</li></ul></li></ul></li><li><p>联系：</p><ul><li>本质决定现象，本质总是通过一定的现象表现自己的存在；</li><li>现象表现本质，现象的存在和变化归根到底依赖于本质。假象也是本质的表现。</li><li>不表现为现象的本质和不表现本质的现象是不存在的。是错觉。</li></ul></li></ul><blockquote><p>例：</p><ol><li>错觉一定是被假象迷惑。错误。（错在一定）</li><li>真象是正确的现象，错觉是错误的感觉。错误。（现象是本质的表现，是客观的，没有正确错误之分，后半句正确）</li><li>真象往往隐藏在内部，假象往往外露在外部。错误。（真象、假象都是现象，都是事物本质的外在表现，本质才是在事物内部）</li></ol></blockquote></li><li><p>方法论：</p><ul><li>（现象和本质有联系）现象和本质是<strong>统一</strong>的，所以我们<strong>能够通过</strong>现象认识事物的本质。</li><li>（现象和本质是有区别的）又因为现象和本质是<strong>对立</strong>的，所以要求我们不能停留在现象中，要透过现象，解释本质。</li></ul></li></ul><h3 id="20-内容和形式"><a href="#20-内容和形式" class="headerlink" title="20.内容和形式"></a>20.内容和形式</h3><ul><li><p>内容和形式：从构成要素和表现方式反映事物的一对基本范畴。</p><ul><li>内容：构成事物的一切要素的总和，是事物存在的基础。</li><li>形式：把诸要素统一起来的结构或表现内容的方式。</li></ul></li><li><p>关系：相互依赖、不可分割</p><ul><li><p><strong>任何事物都是内容与形式的统一。</strong>任何事物的内容都有一定的形式，任何形式也都有一定的内容，没有无内容的空洞形式，也没有无形式的纯内容。</p></li><li><p><strong>内容决定形式，形式反作用于内容。</strong>当形式适合内容的时候，对内容的发展起积极的推动作用；当形式不适合内容的时候，对内容的发展起消极的阻碍作用。</p><blockquote><p>生产力是社会生产的内容。生成关系是社会生产的形式。</p><p>当生产关系适应生产力发展时，会推动生产力。当生产关系不适应生产力时，就会阻碍生产力。</p></blockquote></li></ul></li><li><p>方法论：</p><ul><li>（注重内容，反对形式主义）在我们的认识和实践中，根据内容决定形式的原理，注重事物的内容，反对忽视内容、夸大形式作用的形式主义；</li><li>（利用形式促进内容的发展）又要积极利用合适的形式促进内容的发展，不能忽视形式对内容的能动促进作用。</li></ul></li></ul><h2 id="辩证法-三大规律"><a href="#辩证法-三大规律" class="headerlink" title="辩证法-三大规律"></a>辩证法-三大规律</h2><p>三大规律：</p><ol><li>对立统一规律：事物联系的内容和发展的动力<ul><li>唯物辩证法的实质和核心</li><li>同一性和斗争性的辩证关系原理</li><li>同一性和斗争性在事物发展中的作用原理</li><li>普遍性和特殊性的辩证规律关系原理</li><li>矛盾的不平衡发展原理</li><li>矛盾分析法（方法论总结）</li></ul></li><li>质量互变规律：事物发展过程中的状态</li><li>否定之否定规律：回答事物发展的方向和最终归属<ul><li>辩证否定观</li><li>否定之否定规律</li><li>方法论</li></ul></li></ol><h3 id="21-对立统一规律（很重要）"><a href="#21-对立统一规律（很重要）" class="headerlink" title=" 21.对立统一规律（很重要）"></a><font color='red'> 21.对立统一规律（很重要）</font></h3><ul><li><p>唯物辩证法的实质和核心：对立统一规律</p><blockquote><p>为什么怎么说</p></blockquote><ol><li>对立统一规律揭示了事物普遍联系的根本内容和变化发展的内在动力，从根本上回答了事物为什么会发展的问题。</li><li>对立统一规律贯穿质变量变规律、否定之否定规律以及唯物辩证法基本范畴的中心线索。</li><li>对立统一规律提供矛盾分析法，他是对事物辩证认识的实质。</li><li>是否承认对立统一学说是唯物辩证法和形而上学对立的实质。</li></ol></li><li><p>矛盾：反映事物内部<strong>和</strong>事物之间对立统一关系的哲学范畴。</p><ul><li>矛盾的两种基本属性：对立和统一。<ul><li>矛盾的对立属性又称斗争性</li><li>矛盾的统一属性又称同一性</li></ul></li></ul></li></ul><h4 id="（1）同一性和斗争性的辩证关系原理"><a href="#（1）同一性和斗争性的辩证关系原理" class="headerlink" title="（1）同一性和斗争性的辩证关系原理"></a>（1）同一性和斗争性的辩证关系原理</h4><blockquote><p>同一性；斗争性；关系；方法论</p></blockquote><ul><li><p>矛盾的同一性：矛盾双方<strong>相互依存、相互贯通</strong>的性质和趋势。</p><ul><li><p>相互依存：对立面相互依存，互为存在的前提，共处一个统一体中。</p><blockquote><p>比如，没有上，就没有下。没有强就没有弱。</p><p>上下、强弱都是相互存在的前提。</p></blockquote></li><li><p>相互贯通：对立面相互贯通，<strong>在一定条件下可以相互转化</strong>。</p></li></ul></li><li><p>矛盾的斗争性：矛盾的对立面<strong>相互排斥、相互分离</strong>的性质和趋势。</p><ul><li><p>矛盾的性质不同，矛盾的斗争形式也不同</p><ul><li>对抗性矛盾</li><li>非对抗性矛盾</li></ul><blockquote><p>资本主义终将灭亡。</p><p>因为资本主义中间存在需要对抗性的激烈的矛盾，在对抗性矛盾运动中，资本主义走向灭亡。</p><p>而社会主义中间也存在矛盾，但是是非对抗性的人民内部的矛盾，可以通过民主集中制解决，不会走向灭亡。</p></blockquote></li></ul></li><li><p>同一性和斗争性的关系：对立统一</p><blockquote><p>矛盾的同一性和斗争性的辩证关系不是时而同一性时而斗争性的关系，而是每时每刻既同一又斗争的关系。</p></blockquote><p><em>矛盾的同一性和斗争性相结合，构成了事物的矛盾运动，推动着事物的变化发展</em> </p><ul><li><p>相互联系：矛盾的同一性和斗争性相互联结相辅相成。没有斗争性就没有同一性，没有同一性就没有斗争性，斗争性寓于同一性之中，同一性通过斗争性来体现。</p><blockquote><p>现实中，越相似的两个事物，同一性越强，斗争性就会越强。</p><p>因此，想要减少斗争性，那就要消除同一性。</p></blockquote></li><li><p>相互区别：在事物的矛盾中，矛盾的同一性是有条件的、相对的，矛盾的斗争性是无条件的、绝对的。</p></li></ul></li><li><p>方法论的意义：</p><blockquote><p>矛盾的同一性和斗争性是同时存在的，因此事物总是具有两面性，这要求我 们看待事物时要做到“一分为二”。例如，对待传统文化要“批判地继承”，对待外来文化应该 “批判地吸收”。</p></blockquote><ol><li>看问题要一分为二。（矛盾的同一性和斗争性是同时存在的）</li><li>求同存异（承认事物存在斗争性，追求同一性）</li><li>批判的继承（事物都有两面性）</li><li>事物之间会相互转化。（同一性和斗争性是相互转化的）</li></ol><blockquote><p>考：材料说明了同一性和斗争性的辩证关系原理。</p></blockquote></li></ul><h4 id="（2）同一性和斗争性在事物发展中的作用原理"><a href="#（2）同一性和斗争性在事物发展中的作用原理" class="headerlink" title="（2）同一性和斗争性在事物发展中的作用原理"></a>（2）同一性和斗争性在事物发展中的作用原理</h4><blockquote><p>同一性的作用；斗争性的作用；方法论</p></blockquote><ul><li><p>矛盾的同一性在事物发展中的作用：</p><ol><li><p>（相互发展）由于矛盾双方相互依存、互为存在的条件，矛盾双方可以利用对方的发展使自己得到发展。</p><blockquote><p>你好我也好。</p></blockquote></li><li><p>（各自发展）同一性可以使矛盾双方相互吸取有利于自身的因素，在相互作用中各自得到发展。</p><blockquote><p>相互吸取优点，各自发展的更好。</p></blockquote></li><li><p>（转化发展）由于矛盾双方彼此互通，矛盾双方可以向彼此的对立面转化而得到发展，并规定着事物的发展方向。</p><blockquote><p>你强我弱，变成我强你弱，向对立面转化了，但我的强不是原来你的强了，而是更强，因此是发展。</p></blockquote></li></ol></li><li><p>矛盾的斗争性在发展中的作用：</p><ol><li><p>（量变）矛盾双方的斗争促进矛盾双方力量的变化，竞长争高，此消彼长，造成事物的量变。</p></li><li><p>（质变）矛盾双方的斗争，促使矛盾双方的的地位和性质发生变化，实现事物的质变。</p><p><em>矛盾双方的斗争是一种矛盾统一体向另一种矛盾统一体过渡的决定力量</em> </p></li></ol></li><li><p>方法论：</p><ul><li><p>事物的发展不仅表现为“相辅相成”，而且表现为“相反相成”。</p><blockquote><p>矛盾的斗争性处于主要方面：“相反相成”是从事物的对立面也能达到统一，达到想要的效果。即逆向思维。</p><p>矛盾的同一性处于主要方面：“相辅相成”是从事物的同一性达到统一，达到想要的效果。</p></blockquote></li><li><p>学会从事物的对立面把握事物的统一，逆向思考；</p></li><li><p>正确把握和谐对事物发展的作用。和谐是对立统一，而不是无差别的一致。</p><p><em>和谐是矛盾的一种特殊表现形式，体现着，矛盾双方的相互依存、相互促进、共同发展，和谐并不意味着矛盾的绝对同一。</em> </p></li></ul></li></ul><h4 id="（3）矛盾的普遍性和特殊性的辩证关系原理"><a href="#（3）矛盾的普遍性和特殊性的辩证关系原理" class="headerlink" title="（3）矛盾的普遍性和特殊性的辩证关系原理"></a>（3）矛盾的普遍性和特殊性的辩证关系原理</h4><ul><li><p>矛盾的普遍性：（矛盾无处不在，矛盾无时不有）矛盾的普遍性是指矛盾存在与一切事物中，存在一切事物发展过程的始终，旧的矛盾解决了，新的矛盾又产生，事物始终在矛盾运动。</p></li><li><p>矛盾的特殊性：各个具体事物的矛盾、每一个矛盾的各个方面在发展的不同阶段上各有特点。</p><ol><li>不同事物的矛盾各有特点。</li><li>同一事物的矛盾在不同发展过程和发展阶段各有不同。</li><li>构成事物的 诸多矛盾 以及 每一矛盾的不同方面 各有不同的性质、地位和作用。</li></ol></li><li><p>关系：</p><ul><li>相互区别：<ul><li>矛盾的共性，即矛盾的普遍性，是无条件的、绝对的。</li><li>矛盾的个性，即矛盾的特殊性，是条件的、相对的。</li></ul></li><li>相互联系：任何现实存在的事物的矛盾都是共性和个性的有机统一，共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性。</li></ul></li><li><p>方法论：</p><blockquote><p>考：材料体现矛盾的普遍性和特殊性的辩证关系原理</p></blockquote><ul><li><p>“具体问题具体分析“，对症下药，量体裁衣，因材施教。</p><p><em>只有具体分析矛盾的特殊性，才能认清事物的本质和发展规律，并采取正确的方法和措施去解决矛盾，推动事物的发展。</em> </p></li></ul></li></ul><h4 id="（4）矛盾的不平衡发展原理"><a href="#（4）矛盾的不平衡发展原理" class="headerlink" title="（4）矛盾的不平衡发展原理"></a>（4）矛盾的不平衡发展原理</h4><p><em>事物是由多种矛盾构成的。</em></p><ul><li><p>主要矛盾：主要矛盾是矛盾体系中处于支配地位，对事物发展、对事物发展起决定性作用的矛盾。</p></li><li><p>次要矛盾：次要矛盾是矛盾体系中处于从属地位、对事物的发展起次要作用的矛盾。</p><ul><li>每一对矛盾：<ul><li>主要方面：有一方处于支配地位，起主导地位，是矛盾的主要方面。</li><li>次要方面：被支配的一方则是矛盾的次要方面。</li></ul></li></ul></li><li><p>原理：事物的性质主要是由主要矛盾的主要方面决定的。</p></li><li><p>方法论：“两点论”与“重点论”相结合；看问题既要全面的看，又要抓关键，看主流。</p><ul><li>“两点论”（面面俱到）：分析事物的矛盾，不仅要看的矛盾双方的对立，而且还要看到矛盾双方的统一；还要看到矛盾体系中存在主要矛盾、矛盾的主要方面，而且还有看到次要矛盾、矛盾的次要方面。</li><li>“重点论”（突出重点）：把握主要矛盾、矛盾的主要方面，并以此作为解决问题的出发点。</li></ul><blockquote><p>考：材料体现矛盾的不平衡发展原理。</p></blockquote></li></ul><h4 id="矛盾分析法"><a href="#矛盾分析法" class="headerlink" title="矛盾分析法"></a>矛盾分析法</h4><blockquote><p>与矛盾有关的所有原理的所有方法论。</p><p>考：根据题干材料判断矛盾分析法。</p></blockquote><ul><li>从事物的对立面把握事物的统一，反向思考，逆向思维。2<ul><li>矛盾的同一性和斗争性在事物发展中的作用原理。</li></ul></li><li>物极必反；否极泰来；福祸相依的对立面把握事物的统一。1<ul><li>矛盾的同一性和斗争性的辩证关系原理。</li></ul></li><li>中庸、和谐不走极端的思考方法和态度。1<ul><li>矛盾的同一性和斗争性的辩证关系原理。</li></ul></li><li>具体问题具体分析，对症下药，量体裁衣。3<ul><li>矛盾的普遍性和特殊性的辩证关系的原理。</li></ul></li><li>求同存异；差异中谋求共识。1<ul><li>矛盾的同一性和斗争性的辩证关系原理。</li></ul></li><li>两点论和重点论；抓关键，看主流。4<ul><li>矛盾的不平衡发展原理。</li></ul></li></ul><h3 id="22-量变质变规律"><a href="#22-量变质变规律" class="headerlink" title="22.量变质变规律"></a>22.量变质变规律</h3><blockquote><p>概念；关系；方法论</p></blockquote><ul><li><p>质：事物成为其自身并区别于其他事物的内在规定性。</p><p>考点：</p><ul><li>认识质是<strong>认识和实践的起点和基础</strong>。</li><li>只有认识质，才能区别事物。</li></ul></li><li><p>量：事物的规模、程度、速度 以及 它的构成成分在空间上的排列组合等可以用数量关系表示的规定性。</p><blockquote><p>量：两种情况，一种是数量上的，一种是空间上的排列组合。</p></blockquote><ul><li><p>考点：量的意义：</p><ol><li><p>认识事物的量是认识的深化和精确化。</p><blockquote><p>只认识质是不够的，量才能深化认识，准确认识。</p></blockquote></li><li><p>只有正确了解事物的量，才能正确估计事物在实践中的地位和作用。</p></li></ol></li></ul></li><li><p>度：保持事物 质的稳定性的数量界限，即事物的限度、幅度和范围，度的两端叫关节点或临界点。</p><blockquote><p>度是一个区间，关节点/临界点时端点。</p></blockquote></li><li><p>量变：事物 数量的增减 <strong>和</strong> 次序的变动 ，是保持事物的质的相对稳定性的<strong>不显著变化</strong>，体现了事物渐进过程的<strong>连续性</strong>。 </p><blockquote><p>量变有两种情况，一种是数量上的变化，一种是空间排列次序的变动。</p></blockquote></li><li><p>质变：事物性质的 <strong>根本变化</strong> ，是事物由一种质态向另一种质态的飞跃，体现了事物渐进过程和连续性的<strong>中断</strong>。 </p></li><li><p>关系：对立统一</p><ul><li><p>相互区别：</p><ul><li>量变是事物质相对稳定的不显著变化，而质变是事物性质的根本变化。</li><li>量变是事物渐进过程的连续性，而质变是事物渐进过程和连续性的中断。</li></ul></li><li><p>相互联系:</p><ol><li><p>（必要准备）量变是质变的<strong>必要</strong>准备。</p><p><em>任何事物的变化都有一个量变的积累过程，没有量变的积累，质变就不会发生。</em> </p><blockquote><p>想要质变，就必须要量变。</p></blockquote><ul><li>激变论：夸大质变，否定量变，认为可以不通过量变产生质变。</li></ul></li><li><p>（必要结果）质变是量变的<strong>必然</strong>结果。</p><p><em>单纯的量变不会永远持续下去，量变达到一定的程度必然引起质变。</em> </p><blockquote><p>持续的量变一定会引起质变。</p></blockquote><ul><li>庸俗进化论：夸大量变，否定质变，认为可以一直量变下去，而没有质变。</li></ul></li><li><p>量变和质变是相互渗透的。</p><blockquote><p>事物的总量变认为是一个连续性过程，在某些点是阶段性的质变。</p><p>这些点的前后是旧质在量上的收缩和新质在量上的扩张。</p></blockquote><ul><li>一方面，在总的量变过程中有阶段性和局部性的部分质变。</li><li>另一方面，在质变过程中也有旧质在量上的收缩和新质在量上的扩张。</li></ul></li></ol></li><li><p>方法论：</p><ul><li><p>理论上的方法论：</p><blockquote><p>可以用来批判其他理论观点。</p></blockquote><ul><li>激变论：夸大质变，否定量变，认为可以不通过量变产生质变。</li><li>庸俗进化论：夸大量变，否定质变，认为可以一直量变下去，而没有质变。</li></ul></li><li><p>实践中的方法论：</p><blockquote><p>指导实践</p></blockquote><ul><li><p>适度原则。</p><blockquote><p>否则会引起质变。</p></blockquote></li><li><p>对社会主义初级阶段的认识。</p><blockquote><p>社会主义是质，初级阶段是量。</p></blockquote></li><li><p>改革、发展和稳定。</p><blockquote><p>改革、发展追求的是速度，但也要把握好度，保持稳定。</p></blockquote></li></ul></li></ul></li></ul></li></ul><h3 id="23-否定之否定规律"><a href="#23-否定之否定规律" class="headerlink" title="23.否定之否定规律"></a>23.否定之否定规律</h3><ul><li><p>概念</p><blockquote><p>万事万物都同时存在着肯定因素和否定因素</p></blockquote><ul><li><p>肯定因素：维持现存事物存在的因素。</p><blockquote><p>存在的原因是因为事物身上有肯定因素。</p></blockquote></li><li><p>否定因素：促使现存事物灭亡的因素。</p><blockquote><p>灭亡的原因是因为事物身上有否定的因素。</p></blockquote></li></ul></li><li><p><strong>辩证否定观</strong>：</p><ol><li><p>否定是事物的<strong>自我否定</strong>。</p><p><em>是事物内部矛盾运动的结果</em>。</p><blockquote><p>形而上学：认为是外在力量对事物进行消灭，错误的。</p></blockquote></li><li><p>否定是事物发展的环节。</p><p><em>是旧事物向新事物的转变，是从旧质到新质到飞跃。只有经过否定，旧事物才能向新事物转变</em> </p></li><li><p>否定是新旧事物联系的环节。</p><p><em>新事物孕育产生于旧事物，新旧事物是通过否定环节联系起来的。</em> </p></li><li><p>辩证否定的实质是 <strong>扬弃</strong> 。</p><p><em>新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素</em> </p><blockquote><p>形而上学：认为要么肯定一切，要么否定一切。错误的。</p></blockquote></li></ol><ul><li><p>对比：</p><table><thead><tr><th>辩证否定法观</th><th>形而上学否定观</th></tr></thead><tbody><tr><td>“自我否定”</td><td>外在力量对事物进行否定和消灭</td></tr><tr><td>”扬弃“</td><td>”要么肯定一切，要么否定一切“</td></tr></tbody></table></li></ul></li><li><p>否定之否定规律</p><ul><li><p>事物的辩证发展经过肯定-否定-否定之否定三个阶段。</p><ul><li>第一次否定：使矛盾初步解决，而处于否定阶段的事物仍然有片面性。</li><li>第二次否定：还需要经过再次否定，即否定之否定，实现对立面的统一，使矛盾得到根本解决。</li></ul><blockquote><p>每一个事物都是由许多矛盾组成的，一对矛盾，A方面和B方面组成这对矛盾。</p><p>否定是事物发展的环节，最开始事物处于A的方面，第一次否定，A - &gt; B 。</p><p>第二次发展，否定之否定，是更高形态的A，变成A‘。</p></blockquote></li><li><p>事物的辩证发展就是经过两次否定、三个阶段，形成一个周期。其中，否定之否定阶段仿<strong>佛是向原来出发点的“回复”，但这是在更高阶段的“回复”，是“扬弃”的结果。</strong> </p></li><li><p>事物的发展呈现出周期性，不同周期的交替使事物的发展呈现<strong>波浪式前进或螺旋式上升的趋势</strong>。</p></li></ul></li><li><p>方法论</p><ul><li><p>理论上的方法论：</p><ul><li>循环论：只看到回归，没有看到发展。</li><li>直线论：只看到发展，看不到回归。</li></ul></li><li><p>实践中的方法论：</p><p><em>否定之否定规律揭示了事物发展的前进性和曲折性</em> </p><ul><li><p>事物发展的前进性：前途是光明的</p><p><em>每一次否定都是质变，都把事物推进到新阶段；每一个周期都是开放的，前一个周期的终点是下一个周期的起点，不存在不被否定的终点。</em> </p></li><li><p>事物发展的曲折性：道路是曲折的</p><p><em>曲折性体现在回复性上，其中有暂时的停顿甚至是倒退。但是，曲折性终将为事物的发展开辟道路。表明，事物的发展是螺旋式上升的，而不是直线式前进的</em> </p></li></ul></li></ul></li></ul><h3 id="24-客观辩证法与主观辩证法"><a href="#24-客观辩证法与主观辩证法" class="headerlink" title="24.客观辩证法与主观辩证法"></a>24.客观辩证法与主观辩证法</h3><ul><li><p>客观辩证法：客观事物或客观存在的辩证法。</p><p><em>客观事物以相互作用、相互联系的形式呈现出的各种物质形态的辩证运动和发展规律。</em> </p><blockquote><p>大自然本身就存在的辩证法。</p></blockquote><ul><li>客观辩证法采取<strong>外部必然性形式</strong>  ，不以人的意志为转移，是物质世界本身的联系和发展。</li></ul></li><li><p>主观辩证法：人类认识和思维运动的辩证法。</p><p><em>以概念作为思维细胞的辩证思维运动和发展规律</em> </p><blockquote><p>是人头脑中思维的辩证法。</p></blockquote><ul><li>主观辩证法则是采取<strong>观念的、逻辑的形式</strong>，是同人类思维的自觉活动相联系的，是以概念为基础的辩证思维规律，是辩证法的科学体系。</li></ul></li></ul><blockquote><p>考：</p><p>客观辩证法是唯物的，主观辩证法是唯心的。（错误）</p><p>主观和客观辩证法是反映和被反映的关系，没有正确错误之分。</p><p>而唯物是正确的，唯心是错误的。</p></blockquote><h3 id="25-辩证思维方法"><a href="#25-辩证思维方法" class="headerlink" title="25.辩证思维方法"></a>25.<em>辩证思维方法</em></h3><ol><li>归纳与演绎</li><li>分析与综合</li><li>抽象与具体</li><li>历史与逻辑</li></ol><h2 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h2><p>框架：</p><ol><li>认识的来源和本质<ul><li>来源：实践</li><li>本质：主体在实践的基础上对客体的能动反映</li></ul></li><li>认识的过程和规律<ul><li>两次飞跃：感性认识到理性认识到飞跃；理论到实践的飞跃。</li><li>规律：反复性和无限性。</li></ul></li><li>认识的结果和检验标准</li></ol><p>物质和意识：物质决定意识，意识反作用于物质，意识对物质具有依赖性，又有相对独立性。</p><p>实践和认识：实践决定认识，认识反作用于实践，认识对实践具有依赖性，又有相对独立性。</p><p>实践是物质性活动。</p><p>认识是意识活动。</p><h3 id="26-实践的本质和特征"><a href="#26-实践的本质和特征" class="headerlink" title="26.实践的本质和特征"></a>26.实践的本质和特征</h3><ul><li><p>错误的实践观：</p><ul><li><p>中国古代哲学：实践被称为“践行””实行“或”行“与”知“相对于，（知行合一的行是实践），但主要是指<strong>道德伦理行为</strong>。</p><blockquote><p>错在道德伦理，太局限。不是道德伦理行为也是实践。</p></blockquote></li><li><p>康德：把实践看作<strong>理性自主</strong>的<strong>道德活动</strong>。</p><blockquote><p>错在道德活动。</p><p>错在理性自主，只强调主体，忽略客体。</p></blockquote></li><li><p>黑格尔：把实践理解为<strong>主体改造客观对象</strong>的创造性的<strong>精神活动</strong>。</p><blockquote><p>和康德相比，主体改造客观对象。</p><p>错在精神活动，实践是物质性活动，具有客观性。</p></blockquote></li><li><p>费尔巴哈：把实践与<strong>物质的活动</strong>联系起来，但他所理解的实践仅限于日常生活活动，并将实践等同于生物适应环境的活动。</p><blockquote><p>和黑格尔相比，认为实践是物质的活动。</p><p>错在日常活动，生理活动。实践只能是人的行为，动物没有实践。</p></blockquote></li></ul></li><li><p>马克思正确的实践观：实践是<strong>感性的</strong>、<strong>对象性</strong>的<strong>物质活动</strong>。</p><p><em>马克思科学阐明了人类实践的本质及其在认识世界和改造世界中的作用，创立了科学的实践观。</em> </p><p><em>他在《关于费尔巴哈的提纲》阐明了实践是感性的、对象性的物质活动，提出全部社会生活的本质是实践，并鲜明指出哲学家们只是用不同的方式解释世界，而问题在于改变世界。</em> </p><blockquote><p>感性的：是人的意识指导的，具有目的性和计划性。</p><p>对象性：实践有客体。</p><p>物质活动：实践是物质性活动，具有客观性。</p></blockquote></li><li><p>实践的本质含义：实践是<strong>人类</strong> <strong>能动地</strong>改造世界的社会性<strong>的物质活动</strong>。</p><blockquote><p>人类：实践是人独有的活动，动物没有实践。</p><p>能动的：和感性的相同，是由意识指导的，意识的反作用。</p></blockquote></li><li><p>实践的基本特征：直接现实性、自觉能动性/主体能动性、社会历史性。</p><blockquote><p>考：材料体现实践的特点。</p></blockquote><ul><li><p>直接现实性（实践最本质的特性）：实践具有将人脑中观念的存在变为现实的可能。</p><p><em>实践是改造世界的物质活动，不是纯粹的精神活动，是以感性事物为对象的现实的物质活动。</em> </p><p><em>实践所具有的直接现实性也就是实践活动的客观实在性。（物质的唯一特性）</em> </p><blockquote><p>能将头脑中的想法变成现实存在。</p></blockquote></li><li><p>自觉能动性/主体能动性：实践受意识的指导，体现主体的目的性。</p><p><em>与动物的本能的、被动的适应活动不同，人的实践活动是一种<strong>有意识、有目的</strong>的活动。</em> </p><blockquote><p>和动物的本能活动不同（包括人的本能活动：吃饭/睡觉），实践是有目的的。</p><p>因此人的活动中，本能活动不属于实践。</p></blockquote></li><li><p>社会历史性：不同历史阶段的实践内涵不同。</p><p><em>实践的内容、性质、范围、水平以及方式都收到一定社会条件的制约，随着一定社会历史条件的变化而变化。</em> </p><blockquote><p>比如现在人们可以通过互联网实践，虚拟实践。</p></blockquote></li></ul></li></ul><h3 id="27-实践的基本结构和形式"><a href="#27-实践的基本结构和形式" class="headerlink" title="27.实践的基本结构和形式"></a>27.实践的基本结构和形式</h3><ul><li><p>实践的基本结构：</p><ul><li><p>实践主体：指具有<strong>一定的主体能力、从事现实社会实践活动的人</strong>，是实践活动中自主性和能动性的因素，担负着设定实践目的、操作实践中介、改造实践客体的任务。 </p><blockquote><p>实践主体只能是人，但不是所有人都是实践主体，只有具有一定主体能力、从事现实实践活动的人才是主体。</p></blockquote><ul><li>实践主体的能力：自然能力和精神能力。<ul><li>自然能力：如力量大。</li><li>精神能力：知识性因素和非知识性因素。<ul><li>知识性因素：对理论知识的掌握，对经验知识的掌握。<ul><li>知识性因素是<strong>首要的</strong>实践主体的能力</li></ul></li><li>非知识性因素：情感和意志因素。</li></ul></li></ul></li><li>实践主体的基本形态：个体主体、群体主体、人类主体。</li></ul></li><li><p>实践客体：指<strong>实践活动所指向</strong>的对象。</p><p>实践客体和客观存在的事物不完全等同，客观事物只有在被纳入主体实践活动的范围之内，为主体实践活动所指向并与主体相互作用时才成为现实的实践客体 。</p><blockquote><p>实践客体是客观存在的事物，但不是所有客观存在的物都是实践客体，必需是实践活动所指向的，而像外太空、深海未被人所认知到的物都不是实践的客体。</p></blockquote></li><li><p>实践中介：各种形式的工具、手段 以及 运用、操作这些工具、手段的程序和方法。</p><p>实践的中介系统：</p><p><em>正是依赖这些中介系统，实践的主体和客体才能够<strong>相互作用</strong>。</em></p><ol><li><p>作为人的肢体延长、感官延伸、体能放大的物质性工具系统。</p><blockquote><p>火车、电脑、雷达分别是对人的腿、脑、眼功能的延伸和放大。</p></blockquote></li><li><p>语言符号工具系统。</p><p><em>语言符号是主体思维活动的现实形式，也是人们社会交往得以进行的中介。</em>  </p></li></ol></li></ul></li><li><p>主体和客体相互作用的关系：实践关系、认识关系和价值关系。</p><ul><li><p>实践关系是<strong>最根本</strong>的关系。</p><ul><li>实践的主体和客体与认识的主体和客体在本质上是一致的。</li></ul><blockquote><p>认识关系和价值关系都是基于实践关系。</p></blockquote></li><li><p>实践结构的变化</p><p><em>主体客体化和客体主体化的双向运动是人类实践活动两个不可分割的方面。</em> </p><ul><li><p><strong>主体客体化</strong>：人通过实践使自己的本质力量作用于客体，使其按照主体的需要发生结构和功能上的变化，形成了世界上本来不存在的对象。</p><p><em>实际上，人类一切实践活动的结果都是主体客体化的结果。</em> </p><blockquote><p>比如：人通过实践，使树变成纸张和筷子。</p></blockquote></li><li><p><strong>客体主体化</strong>：客体从客观对象的存在形式转化为主体生命结构的因素 或 本质力量的因素，客体失去客体性的形式，变成主体的一部分。</p><blockquote><p>比如：</p><p>主体把物质工具如电脑、汽车等作为自己身体器官的延长 包括 在主体的活动 属于客体主体化。</p><p>把作为精神性客体的精神产品、先进理念和思想 转化为 主体意识的一部分，属于客体主体化。</p></blockquote></li></ul></li></ul></li><li><p>实践的形式：</p><p><em>人类实践的具体形式日益多样化，从内容上看，实践可分为三种基本形式</em> </p><blockquote><p>注意：人的活动分为本能活动和实践活动，本能活动不属于实践活动，只有下列的劳动、搞关系、探索才算实践活动。</p></blockquote><ul><li><p>物质生产实践（<strong>最基本</strong>的实践活动）</p><blockquote><p>物质生成实践：就是劳动。</p></blockquote></li><li><p>社会政治实践：人们之间的社会交往和政治活动。</p><blockquote><p>社会政治实践：人和人之间搞关系。</p></blockquote></li><li><p>科学文化实践：创造精神文化产品的实践。</p><blockquote><p>科学社会实践：探索创新，比如科学、艺术、教育等。</p></blockquote></li><li><p>虚拟实践：实践活动的<strong>派生形式</strong>，具有<strong>相对独立性</strong>。</p><blockquote><p>虚拟实践是基于人类实践的三种形式：物质生产实践、社会政治实践和科学文化实践，只是实践的载体发生了变化，变成了网络世界。</p><p>虚拟实践是一般实践活动的派生。</p></blockquote><ul><li><p>特点：交互性、开放性、间接性。</p><blockquote><p>交互性：人与人之间。</p><p>开放性：互联网是共享的。</p><p>间接性：通过数字中介</p></blockquote></li></ul></li></ul></li></ul><h3 id="28-实践决定认识"><a href="#28-实践决定认识" class="headerlink" title="28.实践决定认识"></a><font color='red'>28.实践决定认识</font></h3><p><em>辩证唯物主义认为，在实践和认识之间，实践是认识的基础，实践在认识活动中起着决定性的作用。</em> </p><ul><li><p>实践在认识活动中的决定作用（实践决定认识的原因）</p><ol><li><p>实践是认识的来源（是唯一来源）</p><p>形成认识的因素中：</p><ul><li>实践是决定因素</li><li>天赋（生理因素）和间接经验等起影响作用，是重要因素</li></ul><blockquote><p>认识的形成是多因素的，实践是决定因素。</p><p>类似意识的形成：</p><p>意识也是多因素形成的，实践特别是劳动，对意识的形成起决定作用，语言也促进意识的形成。</p></blockquote></li><li><p>实践是认识的动力</p><blockquote><p>恩格斯：社会一旦有技术上的需要，这种需要就会比十所大学更能把科学推向前进。</p></blockquote></li><li><p>实践是认识的目的</p><p><em>不是为了认识而认识，其最终目的是为实践服务，指导实践</em> </p></li><li><p><strong>实践</strong>是检验认识真理性的唯一标准</p></li></ol></li></ul><blockquote><p>考：</p><p>认识总是滞后于实践。错在总是。</p><p>实践是认识的先导。错在先导，实践指导认识不对，实践是一种行为，应该是认识/意识指导实践。</p><p>实践高于认识。正确，实践决定认识，高于认识。</p><p>实践和认识是合一的。知行合一。正确。</p><p>（但王阳明的知行合一，是作为的，王阳明的行局限于道德伦理行为）</p></blockquote><h3 id="29-认识的本质"><a href="#29-认识的本质" class="headerlink" title="29.认识的本质"></a>29.认识的本质</h3><ul><li><p>各流派的认识论</p><ul><li><p>唯心主义先验论：从思想和感觉到物</p><ul><li>认识不是对事物的反映，而是先于事物的存在。</li></ul></li><li><p>唯物主义反映论：从物到思想和感觉</p><ul><li>先有客观事物，才有我们的认识，认识是对客观事物的反映</li><li>旧唯物主义机械反映论：直观的、消极被动的反映论</li><li>辩证唯物主义能动反映论：反映是一个能动的过程</li></ul><blockquote><p>区别在于机械反映论只有反应，即物到人的大脑中的直观反映，是什么就是什么，没有加工创造。</p><p>而辩证唯物主义能动反映是，先反映，再能动创造加工。</p></blockquote></li></ul></li><li><p>认识的本质：主体<strong>在实践基础上</strong>对客体的<strong>能动</strong>反映。</p><p>能动反映：</p><ol><li><p>认识的<strong>反映特性</strong>：具有反映客体内容的反映性特征</p><p>认识的反映特性指人的认识必然要  以客观事物为原型和摹本  ，在思维中再现或摹写客观事物的状态、属性和本质。</p><blockquote><p>（错误）虚幻的观念也是对事物本质的反映。错在本质，一切观念，即意识，都是对事物的反映，但不一定都是对事物的本质的反映，可能是对事物的现象、属性的反映。</p><p>回顾：本质和现象，现象反映本质，真象和假象都是对本质的反映。</p></blockquote></li><li><p>认识的能动反映具有<strong>创造性</strong> ：具有实践的主体能动的、创造的特征</p><p>认识是一种在思维中能动的、创造性的活动，而不是主观对客观对象简单、直接的描摹或照镜子式的原物映现。</p><blockquote><p>（错误）一切观念都是现实的模仿。错在模仿，认识是具有能动的创造性。</p></blockquote></li></ol><ul><li><p>认识的反映特性和能动的创造特性之间的关系：<strong>不可分割</strong></p><p><em>人的认识是反映性或摹写性与创造性的统一</em> </p><blockquote><p>反映是能动创造的反映，创造是在基于反映创造。</p></blockquote><ul><li>旧唯物主义直观反映论：只坚持认识的反映特性，看不到认识的能动和创造性。</li><li>唯心主义和不可知论：只坚持认识能动的创造性，使创造脱离反映论的前提。</li></ul></li></ul></li><li><p>能动反映论的两个优点/特点：</p><ol><li><p>把<strong>实践</strong>的观点引入认识论。</p></li><li><p>把<strong>辩证法</strong>应用于反映论考察认识的发展过程。</p><p><em>科学揭示认识过程中多方面的辩证关系，把认识看成一个由不知到可知、由浅入深的充满矛盾的能动的认识过程，全面揭示了认识过程的辩证特征。</em> </p></li></ol></li></ul><h3 id="30-认识过程的两次飞跃"><a href="#30-认识过程的两次飞跃" class="headerlink" title=" 30.认识过程的两次飞跃"></a><font color='red'> 30.认识过程的两次飞跃</font></h3><ol><li><p>从感性认识到理性认识（第一次飞跃）</p><blockquote><p>比第二次飞跃考的多</p></blockquote><ul><li><p>感性认识（通过感觉感官直接感受）：人们在实践基础上，由感觉器官直接感受到的关于事物的现象、事物的外部联系、事物的各个方面的认识。</p><ul><li>对象：事物的现象、事物的外部联系、事物的各个方面</li><li>形式：感觉、知觉和表象<ul><li>感觉：对客观事物的个别属性、个别方面的直接反映。</li><li>知觉：对客观事物外部特征的整体反映。</li><li>表象：人脑对过去感觉和知觉的回忆</li></ul></li><li>特点：直接性、具体性</li></ul></li><li><p>理性认识（需要抽象、归纳、总结）：人们借助抽象思维，在概括整理大量感性材料的基础上达到关于事物的本质、全体、内部联系和事物自身的规律性的认识。</p><ul><li>对象：事物的本质、全体、内部联系和事物自身的规律性的认识。</li><li>形式：概念、判断、推理<ul><li>概念：同类事物的一般特性和本质属性的概括和反映</li><li>判断：展开了的概念，是对事物之间的联系和关系的反映，是什么或不是什么</li><li>推理：形式上表现为判断和判断之间的关系</li></ul></li><li>特点：间接性和抽象性</li></ul></li><li><p>感性认识和理性认识的辩证关系：对立统一</p><ol><li><p>（感性到理性）感性认识有待发展和深化为理性认识</p></li><li><p>（理性依赖感性）理性认识依赖于感性认识</p></li><li><p>（相互渗透）感性认识和理性认识相互渗透、相互包含。</p><p><em>感性中有理性，理性中有感性，具有交融性。</em> </p></li></ol><ul><li><p>感性认识和理性认识的辩证统一关系是在实践的基础上形成的，也需要在实践中发展。</p><p>如果割裂辩证统一关系：</p><ul><li>教条主义-唯理论：否认感性认识而片面夸大理性认识。（否定实践）</li><li>经验主义：否认理性认识而片面夸大感性认识。</li></ul></li></ul><blockquote><p>考：选择题：材料中是认为<strong>感性认识更重要还是理性认识更重要</strong></p><ol><li>尽信书，则不如无书。感性认识。</li><li>饱经风霜的老人与缺乏阅历的少年对同一句格言的理解不同。感性认识。</li></ol><p>感性认识，即要实践。</p></blockquote></li><li><p>感性认识上升到理性认识到的条件：</p><ol><li>（实践）投身实践，深入调查，获取十分丰富和合乎实际的感性材料。</li><li>（思考能动性）必须经过思考的作用，运用理论思维和科学抽象，将丰富的感性材料加工制作。</li></ol></li></ul></li><li><p>从认识到实践（理性认识到实践的飞跃）</p><p><em>从认识到实践，是认识过程的第二个阶段，是第二次能动的飞跃，也是<strong>认识过程中</strong>最重要的一次飞跃</em> </p><p>重要性和必要性：一是认识世界的目的是为了改造世界。而是认识的真理性只有在实践中才能得到检验和发展。</p></li></ol><h3 id="31-认识过程中的理性因素和非理性因素"><a href="#31-认识过程中的理性因素和非理性因素" class="headerlink" title="31.认识过程中的理性因素和非理性因素"></a><font color='red'>31.认识过程中的理性因素和非理性因素</font></h3><blockquote><p>即形成认识，获得认识中的影响因素</p></blockquote><ol><li><p>理性因素：人的理性直观、理性思维的能力。</p><ul><li><p>在认识活动中的作用：指导作用、解释作用和预见作用。</p><blockquote><p>知识</p></blockquote></li></ul></li><li><p>非理性因素（感性因素）：人的情感和意志</p><ul><li><p>在认识过程中的作用：激活、驱动和控制作用</p><blockquote><p>联想、想象、猜测、直觉、灵感</p></blockquote></li></ul></li></ol><blockquote><p>区分感性认识和理性认识｜感性因素和理性因素：</p><p>感性认识是理性认识是认识过程已经结束，已经获得了认识。</p><p>感性因素和理性因素是在认识过程中的影响因素，还没有获得认识。</p><p>在感性认识/理性认识中都有感性因素和理性因素在起作用。</p></blockquote><h3 id="32-认识的规律"><a href="#32-认识的规律" class="headerlink" title="32.认识的规律"></a><font color='red'>32.认识的规律</font></h3><ul><li>认识过程的反复性（反复循环）：人们对于一个复杂事物的认识往往要经过由感性认识到理性认识、再由理性认识到实践的多次反复才能完成。<ul><li>原因：<ul><li>客观：事物暴露有一个过程</li><li>主观：主体认识能力提高有个过程</li></ul></li></ul></li><li>认识过程的无限性（无限发展）：事物发展过程的推移来说，人类的认识永无止境，无限发展，表现为“实践、认识、再实践、再认识”，由低级阶段向高级阶段不断推移的永无止境的前进运动。<ul><li>认识的无限发展过程：形式上是<strong>循环往复</strong>，实质上是<strong>前进上升</strong>。</li></ul></li><li>认识是一个波浪式前进和螺旋式上升的过程。（否定之否定在认识论中）</li></ul><h3 id="33-认识与实践的具体的历史统一性"><a href="#33-认识与实践的具体的历史统一性" class="headerlink" title="33.认识与实践的具体的历史统一性"></a><em>33.认识与实践的具体的历史统一性</em></h3><p><em>在实践和认识的辩证运动中，主观必须统一于客观，认识必须统一于实践</em> </p><ul><li><p>方法论</p><ol><li><p>实践超前于认识：冒进主义（左）</p><blockquote><p>比如跑步进入中国特色社会主义道德的观点，左派。</p></blockquote></li><li><p>实践落后于认识：保守主义（右）</p><blockquote><p>先学西方搞几百年资本主义，再搞社会主义的观点，右派。</p></blockquote></li></ol></li></ul><h2 id="认识的结果"><a href="#认识的结果" class="headerlink" title="认识的结果"></a>认识的结果</h2><h3 id="34-真理及其特点"><a href="#34-真理及其特点" class="headerlink" title="34.真理及其特点"></a><font color='red'>34.真理及其特点</font></h3><ul><li><p>错误的真理观：</p><ul><li><p>马赫主义：真理是“思想形式”，是社会性组织起来的经验，凡事大多数人承认的就是真理。</p><blockquote><p>错在，大多数人。</p></blockquote></li><li><p>实用主义：“有用即真理”，把真理的有用性与真理本身等同起来。</p><blockquote><p>错在，真理和有用等同起来。</p></blockquote></li></ul></li><li><p>正确的真理观：（马克思）真理是标志主观和客观相符合的哲学范畴，是对客观事物的<strong>正确</strong>反映。</p><blockquote><p>谬误：同客观事物及其发展规律相违背的认识（主客观不相符合），是对客观事物的错误/歪曲反映。</p></blockquote></li><li><p>真理的特点：</p><ol><li><p>客观性（<strong>真理的本质属性</strong>）：真理的内容是对客观事物及其规律的正确反映，真理中包含着不依赖人和人的意识的客观内容。</p><ul><li><p>客观性体现在：真理的内容和检验标准上</p><ul><li>真理的内容是客观的：对物质世界的正确反映</li><li>真理的检验标准是客观的：实践是物质性的活动。</li></ul></li><li><p>真理的形式是主观的：通过感觉、知觉、表象、概念、判断、推理等主观形式表达出来</p><blockquote><p>真理的内容是客观的，形式是主观的。真理是对客观事物及其规律的正确反映。</p><p>意识到内容是客观的，形式是主观的。意识是对物质世界的主观反映。</p></blockquote></li><li><p>真理的客观性决定了真理的<strong>一元性</strong>：在同一条件下对特定的认识客体的真理性认识只有一个，而不可能是多个。</p></li></ul></li><li><p>绝对性：真理<strong>主客观统一的确定性</strong>和<strong>发展的无限性</strong>。</p><ul><li><p>绝对性体现在：</p><blockquote><p>今天认为正确的东西，主客观的符合，是真理。</p><p>但明天认为昨天的不对，新的主客观符合，也是真理。</p></blockquote><ul><li>（承认了真理的客观性就是承认了真理的绝对性）任何真理都<strong>标志主观和客观的符合</strong>，包含着不依赖于人和人的意识的客观内容，都同谬误有原则的界限。这一点是绝对的、无条件的。</li><li>（承认世界的可知性，承认人能够获得关于无限发展的物质世界的正确认识，也就是承认了真理的绝对性）人类认识按其本性来说，能够正确认识无限发展着的物质世界，认识每前进一步，都是对无限发展着物质世界的接近，这一点也是绝对的、无条件的。</li></ul></li></ul></li><li><p>相对性：人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的、不完善的。</p><ul><li><p>相对性体现在：</p><blockquote><p>今天认为正确的东西，明天可能不对了。</p></blockquote><ul><li>（客观世界在发展，认识的广度有待扩展）客观世界的整体来看，任何真理都只是对客观世界的某一阶段、某一部分的正确认识，人类已经达到的认识的广度总是有限度的，<strong>认识有待扩展</strong>。</li><li>（一定程度，认识反映事物的深度有限）特定事物而言，任何真理只是对客观对象一定方面、一定层次和一定程度的正确认识，<strong>认识反映事物的深度是有限的</strong> </li></ul></li></ul></li></ol></li><li><p>真理的绝对性和相对性的关系：辩证统一</p><blockquote><p>辩证统一不是这个真理是绝对的，这个真理是相对的，而是每一个真理都有绝对性和相对性的一面。 </p></blockquote><ul><li><p>相互依存</p><blockquote><p>真理的绝对性是基于相对性的（一定条件下的），真理的相对性也是基于绝对性的（主观和客观的相符合）。</p></blockquote></li><li><p>相互包含：</p><p><em>没有离开绝对真理的相对真理，也没有离开相对真理的绝对真理</em></p><ul><li><p>真理的绝对性寓于真理的 相对性之中。</p><p><em>任何真理所包含的客观内容都只能是人们在特定条件下所把握到的，都是对客观世界及其事物的一定范围、一定程度的正确反映。</em> </p></li><li><p>真理的相对性必然包含并表现着真理的绝对性。</p><p><em>真理都是对无限发展着的物质世界的正确认识，包含着正确的客观内容</em> </p></li><li><p><strong>无数相对的真理的总和，就是绝对的真理。</strong> </p></li></ul></li><li><p>真理永远处在由相对向绝对的转化和发展中，是真理的相对性走向绝对性、接近绝对性的过程。</p><blockquote><p>真理发展的规律就是真理的相对性无限接近绝对性。</p></blockquote></li><li><p>真理的绝对性与相对性根源于人认识世界的能力的无限性（至上性）与有限性（非至上性）、绝对性与相对性的矛盾。</p><blockquote><p>总体来看，人是能够完全认识世界的，是人认识世界的能力的无限性，对应真理的绝对性。</p><p>但现在的人囿于一定条件还没有完全认识世界，是人认识世界的能力的有限性，对应真理的相对性。</p></blockquote></li></ul></li><li><p>方法论：</p><ul><li><p>教条主义：只看到真理的绝对性，忽视相对性。</p></li><li><p>诡辩论（怀疑主义）：只看到真理的相对性，忽视绝对性。</p><blockquote><p>在运动和静止中，诡辩论也是夸大运动，忽视静止。认为在一直运动。</p></blockquote></li></ul></li></ul><h3 id="35-真理与谬误"><a href="#35-真理与谬误" class="headerlink" title="35.真理与谬误"></a><font color='red'>35.真理与谬误</font></h3><ul><li><p>真理与谬误的关系：对立统一</p><p><em>真理和谬误的对立只是在非常有限的范围内才具有绝对的意义，超出这个范围，二者的对立就是相对的。</em> </p><ul><li>相互区别：在<strong>确定的对象和范围内</strong>，真理与谬误的对立是绝对的，与对象相符合的认识就是真理，与对象不相符合的认识就是谬误。在确定条件下，真理和谬误存在着原则界限。</li><li>相互联系：在一定条件下，真理和谬误能相互转化。<ul><li>真理和谬误在一定范围内的对立是绝对的，但超出一定范围，真理和谬误就会相互转化，真理变成谬误，谬误变成真理。</li></ul></li></ul></li></ul><h3 id="36-真理的检验标准"><a href="#36-真理的检验标准" class="headerlink" title="36.真理的检验标准"></a><em>36.真理的检验标准</em></h3><ul><li><p>实践是检验真理的唯一标准这是由真理的本性和实践的特点决定的。</p><ul><li><p>真理的本性：主观和客观相符合。</p><p><em>真理是人们对客观事物及其发展规律的正确反应，他的本性在于主观和客观相符合。</em> </p><blockquote><p>实践是连接物质和意识的桥梁，只有通过实践才能判断主客观是否相符合。</p></blockquote></li><li><p>实践的本质特点：直接现实性。</p><p><em>实践是人们改造世界的客观的物质性活动，具有直接现实性的特点。</em> </p></li></ul></li><li><p>实践是标准，并不排斥逻辑证明的作用。</p><blockquote><p>不排斥，但实践是唯一标准。</p></blockquote></li><li><p>实践标准的确定性和不确定性</p><blockquote><p>实践标准的确定性和不确定性是说实践标准既有确定性又有不确定性，而不是这个实践标准是确定的，另一个实践标准是不确定的。</p></blockquote><ul><li>实践标准的确定性<ol><li>检验真理的唯一标准</li><li>不可推翻</li><li>即使当前不能检验，但最终能裁决</li></ol></li><li>实践标准的不确定性<ol><li>一定时期的实践受到主客观的制约具有局限性，不能完全证明或驳倒一切</li><li>实践检验真理不是一次完成的</li><li>已被检验的仍需接受再检验。</li></ol></li></ul></li></ul><h3 id="37-真理与价值的辩证统一"><a href="#37-真理与价值的辩证统一" class="headerlink" title="37.真理与价值的辩证统一"></a>37.真理与价值的辩证统一</h3><ul><li><p>价值：价值是指在实践基础上形成的主体和客体之间的意义关系，是客体对个人、群体乃至整个社会的生活和活动所具有的积极意义。</p><blockquote><p>价值：客体对…的意义</p></blockquote></li><li><p>价值的特点</p><blockquote><p>考：材料体现了价值的什么特点</p></blockquote><ul><li><p>客观性：客体对于主义的意义不依赖于主体的主观意识存在。</p><blockquote><p>所有的客观性：不依赖于人的意识存在</p></blockquote></li><li><p>主体性：主体不同，价值不同</p><p><em>主体性是指价值直接同主体相联系，始终以主体为中心</em></p><blockquote><p>主体性不等同于主观性。</p></blockquote></li><li><p>多维性：维度不同，价值不同。</p></li><li><p>社会历史性：历史时期不同，价值不同。</p></li></ul></li><li><p>价值评价（价值判断）：主体对客体的价值以及价值大小所作的评判或判断。</p><blockquote><p>认识分为两种，一种是知识性认识，一种是评价性认识。</p><p>知识性认识：以客体为对象，主要是是什么。</p><p>评价性认识：以主客体的关系为对象，比如主体喜不喜欢客体等。</p></blockquote></li><li><p>价值评价的特点：</p><ol><li><p>评价以主客体的价值关系为认识对象。</p></li><li><p>评价结果与评价主体直接相关。</p></li><li><p>评价结果的正确与否 依赖于对客体状况和主体需要的认识。</p><blockquote><p>评价性认识依赖于知识性认识。</p><p>即知识越多，评价越好，评价认识越充分。</p><p>（充分了解后，再来说喜欢与否。）</p></blockquote></li></ol><ul><li><p>价值评价的特点表明，评价并不是一种主观随意性的认识，而是<strong>具有客观性的认识活动。</strong> </p><p><em>评价作为一种价值评判活动，虽具有主观性，但不是一种主观随意性的认识，只有正确反映价值关系的评价才是正确认识。</em> </p><p><em>对于任何价值评价的主体而言，其价值评价只有与人类整体的要求或理由相一致，才是正确的价值评价。</em> </p></li></ul></li><li><p>真理和价值在实践中的辩证统一</p><ul><li><p>人们的实践活动总是受着真理尺度和价值尺度的制约。</p><ul><li><p>实践的真理尺度是指在实践中人们必须遵循正确反映客观事物本质和规律的真理。</p></li><li><p>实践的价值是指在实践中人们都是按照自己的尺度和需要去认识世界和改造世界。</p><p><em>这一尺度体现了人的活动的目的性</em> </p></li></ul></li><li><p>任何实践活动都是在这两种尺度共同制约下进行的，任何<strong>成功的实践都是真理尺度和价值尺度的统一。</strong></p></li><li><p>紧密联系、不可分割的辩证统一关系</p><ol><li><p>价值尺度必须以真理为前提。真理又必然是具有价值的。</p><blockquote><p>真理必然有价值，有价值的不一定是真理。</p><p>真理一定有用，有用的不一定是真理。</p></blockquote></li><li><p>人类自身需要的内在尺度，推动着人们不断发现新的真理。</p></li></ol></li></ul></li></ul><h3 id="38-认识世界和改造世界必须勇于创新"><a href="#38-认识世界和改造世界必须勇于创新" class="headerlink" title="38.认识世界和改造世界必须勇于创新"></a><em>38.认识世界和改造世界必须勇于创新</em></h3><h3 id="39-自由和必然"><a href="#39-自由和必然" class="headerlink" title="39.自由和必然"></a>39.自由和必然</h3><blockquote><p>自由：人想怎样就怎样。</p><p>必然：客观规律，该怎样就怎样。</p></blockquote><ul><li><p>自由：标示人的活动状态的范畴，是指人在活动中 通过认识和利用必然 所表现出的一种自觉自主的状态。<strong>自由是对必然的认识和对客观世界的改造。</strong></p></li><li><p>必然：必然性即规律性，指的是不依赖于人的意识而存在的自然和社会发展所固有的客观规律。</p></li><li><p>认识必然和争取自由，是人类认识世界和改造世界的根本目标，是一个历史性的过程。</p><p>由必然到自由的表现为人类不断从必然王国向自由王国发展的 历史。</p><blockquote><p>以前只能顺应自然的一切规律。是必然王国。</p><p>现在通过认识和利用必然，能做一些人类想做的事，是向自由王国的发展。</p></blockquote></li><li><p>自由是有条件的：</p><ol><li>认识条件：要有对客观事物的正确认识，最主要的是对客观事物运动发展规律性和必然性的正确认识。</li><li>实践条件：能够将获得的规律性认识运用于指导实践，实现改造世界的目的，才是真正的自由。</li></ol></li></ul><h2 id="唯物史观"><a href="#唯物史观" class="headerlink" title="唯物史观"></a>唯物史观</h2><p>人类社会历史</p><ol><li>社会发展的物质动因</li><li>人民群众创造历史</li></ol><h3 id="40-唯物史观和唯心史观的对立"><a href="#40-唯物史观和唯心史观的对立" class="headerlink" title="40.唯物史观和唯心史观的对立"></a>40.唯物史观和唯心史观的对立</h3><ul><li>唯心史观的缺陷：<ul><li>只看到历史发展背后的精神力量，没有看到精神力量背后的 <strong>物质动因</strong> 和 <strong>经济根源</strong> 。</li><li>只看到历史发展中少数英雄人物的力量，而没有看到人们群众在社会历史发展中的决定作用。</li></ul></li></ul><h3 id="41-社会存在和社会意识及其辩证关系"><a href="#41-社会存在和社会意识及其辩证关系" class="headerlink" title="41.社会存在和社会意识及其辩证关系"></a>41.社会存在和社会意识及其辩证关系</h3><blockquote><p>社会存在和社会意识是社会历史领域的物质和意识</p></blockquote><ul><li><p>社会存在：社会物质生活条件</p><ul><li><p>自然地理环境：影响因素，<strong>非决定力量</strong></p></li><li><p>人口因素：影响因素，<strong>非决定力量</strong></p><blockquote><p>考：是影响因素，而非决定力量</p><p>低级概念，夸大说是决定力量，拉低说是没有作用</p></blockquote></li><li><p>物质生产方式（物质生活的生产方式，生产方式）：<strong>决定力量</strong></p><p><em>是指人民为获取物质生活资料而进行的生产活动的方式，它是生产力和生产关系的统一体。</em></p><ul><li><p>生产力 + 生产关系 = 生产方式</p></li><li><p>生产力</p><ul><li>劳动资料：生产工具是生产力发展水平的标准</li><li>劳动对象：与劳动资料合成为生产资料</li><li>劳动者：生产力中最活跃的因素</li></ul></li><li><p>生产关系</p><ul><li>生产资料所有制关系：最基本内容</li><li>生产中人与人的关系</li><li>产品分配关系</li></ul></li></ul></li></ul></li><li><p>社会意识：社会生活的精神方面，是社会存在的反映</p><p><em>根据不同的层次：</em></p><ul><li><p><strong>社会心理</strong>：低层次的社会意识，是自发的、不系统的、不定型的社会意识</p><ul><li>表现为：人民的感知、情绪、情感、心态、习俗</li></ul></li><li><p><strong>社会意识形式</strong>：高层次的社会意识，是自觉的、系统的、定型的社会意识</p><p><em>社会意识形式以社会心理为基础，并对社会心理起指导和影响作用。</em> </p><ul><li>包括：政治法律思想、道德、艺术、宗教、哲学、科学，以理性认识为主。</li></ul><blockquote><p>社会意识形态是和阶级有关的，不同的阶级社会意识形态不同。</p><p>非社会意识形态和阶级无关，不同的阶级非社会意识形态相同。</p></blockquote><ul><li><strong>社会意识形态</strong>：反映社会的经济关系、阶级关系的社会意识形式<ul><li>包括：政治法律思想、道德、艺术、宗教、哲学</li></ul></li><li><strong>非社会意识形态</strong>：不具有社会经济形态和政治制度的性质<ul><li>包括：自然科学、语言学、形式逻辑、心理学</li></ul></li></ul></li></ul></li><li><p>社会存在和社会意识的辩证关系</p><p><em>社会存在和社会意识是辩证统一的。社会存在决定社会意识，社会意识是社会存在的反映。</em> </p><ul><li><p>社会存在决定社会意识</p><ol><li><p>社会存在是社会意识内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映。</p><blockquote><p>物质是意识内容的客观来源，意识是物质的主观反映。</p></blockquote></li><li><p>社会意识是人们进行社会物质交换的产物。</p><p><em>社会意识同语言一样，是在生产中由于交往活动的需要而产生的。</em> </p></li><li><p>随着社会存在的发展，社会意识也相应地<strong>或早或迟地</strong>发生变化和发展。</p><blockquote><p>考：将或早或迟改为一定立刻</p></blockquote><blockquote><p>社会存在发展，社会意识也在变，但不一定是一致的、同步的变化，而是不一致不同步。</p></blockquote></li></ol></li><li><p>社会意识反作用与社会存在</p><p>社会意识的相对独立性：</p><ol><li><p>社会意识与社会存在发展的不完全同步性和不平衡性</p><blockquote><p>社会意识和社会存在的发展不同步、不平衡，有些经济发展水平较高的国家社会意识水平未必很高。</p></blockquote></li><li><p>社会意识内部各形式之间的相互作用 及 各自具有的历史继承性</p><blockquote><p>社会意识形式中各要素相互作用社会意识。</p><p>但有些社会意识还具有历史继承性，比如一些封建残余观念。</p></blockquote></li><li><p>社会意识对社会存在能动的反作用。（双向）</p><p><em>先进的社会意识促进社会发展，落后的社会意识阻碍社会发展。</em> </p></li></ol></li></ul></li></ul><h3 id="42-生产力与生产关系矛盾运动的规律"><a href="#42-生产力与生产关系矛盾运动的规律" class="headerlink" title="42.生产力与生产关系矛盾运动的规律"></a>42.生产力与生产关系矛盾运动的规律</h3><ul><li><p><strong>生产力</strong>：人们解决社会同自然矛盾的实际能力，是人类在生产实践中形成的改造和影响自然以使其适合社会需要的<strong>物质力量</strong> 。</p><ul><li><p>它表示<strong>人和自然</strong>的关系</p></li><li><p>生产力基本要素：</p><ul><li><strong>劳动资料</strong>（劳动手段）：人们在劳动过程中所运用的物质资料或物质手段<ul><li>最重要的是<strong>生产工具</strong>，他是生产力发展水平的<strong>客观尺度</strong>，是区分<strong>社会经济时代</strong>的<strong>客观依据</strong>。</li></ul></li><li><strong>劳动对象</strong><ul><li>劳动资料+劳动对象 = 生产资料 </li></ul></li><li><strong>劳动者</strong> 劳动者是生产力中<strong>最活跃</strong>的因素：</li></ul></li><li><p>科学技术日益成为生产发展的<strong>决定性因素</strong> </p><blockquote><p>注意：</p><p>科学技术属于生产力，但不是生产力的独立的基本要素，科学技术是与生产力的三个基本要素结合，发挥作用。</p><p>考：问生产力的因素还是生产力的独立要素/基本要素。</p><p>（正确）生产力在生产劳动中起决定作用。</p><p>（错误）生产力在社会历史中起决定作用。</p></blockquote><ul><li>科学技术是先进生产力的集中体现和主要标志，是第一生产力</li></ul></li></ul></li><li><p>生产关系：人们在物质生产过程中形成的<strong>不以人的意志</strong>为转移的经济关系。</p><blockquote><p>不以人的意志为转移，生产关系是物质</p></blockquote><p><em>生产关系是社会关系中最基本的关系，政治关系、家庭关系、宗教关系等其他社会关系，都受生产关系的支配和制约。</em> </p><ul><li><p>包括：</p><ul><li><p><strong>生产资料所有制关系</strong></p><ul><li><p>生产资料所有制是<strong>最基本、具有决定</strong>意义的方面。</p></li><li><p>它构成全部社会关系<strong>的基础</strong>，是区分不同生产方式、判定<strong>社会经济结构</strong>的<strong>客观依据</strong>。</p><blockquote><p>生产工具：区分社会经济时代的客观依据。</p><p>生产资料所有制关系：判定社会经济结构的客观依据。</p></blockquote></li></ul></li><li><p><strong>生产中人与人的关系</strong></p></li><li><p><strong>产品分配关系</strong></p></li></ul></li><li><p>生产关系是一种<strong>人和人的关系</strong>，但他在物质生产过程中结成的关系，是不以人的意志为转移。 </p><blockquote><p>生产力：人和自然的关系，是物质。</p><p>生产关系：人和人的关系，是物质。</p></blockquote></li></ul></li><li><p>生产力和生产关系的关系：不可分割</p><p><em>生产力和生产关系是社会生产不可分割的两个方面</em> </p><ul><li><p>在社会生产中：生产力是生产的<strong>物质内容</strong>，生产关系是生产的<strong>社会形式</strong>，二者的有机结合统一构成<strong>社会的生产方式</strong>。</p><blockquote><p>在辩证法的内容和形式的范畴中：</p><p>内容决定形式，形式反作用与内容，当形式适合内容，对内容发展起积极作用，当形式不适合内容是，对内容发展起消极作用。</p></blockquote><ul><li><p>生产力决定生产关系</p></li><li><p>生产关系反作用与生产力（双向）</p><p><em>当生产关系适合生产力发展的客观要求时，对生产力的发展起推动作用；当生产关系不适合生产力发展的客观要求时，就会阻碍生产力的发展。</em> </p></li></ul></li></ul></li><li><p><strong>社会发展第一规律：生产关系一定要适应生产力发展状况的规律</strong></p><blockquote><p>形式要适应内容。</p></blockquote></li></ul><h3 id="43-经济基础与上层建筑矛盾运动的规律"><a href="#43-经济基础与上层建筑矛盾运动的规律" class="headerlink" title="43.经济基础与上层建筑矛盾运动的规律"></a>43.经济基础与上层建筑矛盾运动的规律</h3><ul><li><p>经济基础：是指 由社会一定发展阶段的生产力  <strong>所决定的生产关系</strong>的总和</p><blockquote><p>经济基础是生产关系。</p><p>经济基础和生产关系是同级概念，生产力决定生产关系，生产力也决定 经济基础。</p></blockquote></li><li><p>上层建筑：建立在一定的经济基础之上的  <strong>意识形态</strong>  以及  <strong>相应的制度、组织和设施</strong> </p><ul><li><p>组成</p><blockquote><p>区分：</p><p>观念上层建筑是无形的，政治上层建筑是有形的。</p></blockquote><ul><li><p><strong>意识形态</strong>（<strong>观念上层建筑</strong>）</p><ul><li><p>包括政治法律思想、道德、意识、宗教、哲学等思想观念。</p><blockquote><p>辨析：社会意识中的意识形态和上层建筑中的意识形态</p><p>社会意识中的意识形态和上层建筑中的意识形态是同一个东西</p><ul><li>社会意识：<ul><li>社会心理</li><li>社会意识形式<ul><li><strong>社会意识形态</strong></li><li>非社会意识形态</li></ul></li></ul></li><li>上层建筑：<ul><li><strong>意识形态（观念上层建筑）</strong></li><li>政治上层建筑</li></ul></li></ul><p><strong>属于上层建筑的意识形态是社会意识形态。</strong> </p></blockquote></li></ul></li><li><p><strong>政治法律制度及设施 和 政治组织</strong>（<strong>政治上层建筑</strong>）</p><ul><li><p>包括：国家政治制度、立法司法制度和行政制度，以及国家政权机构、政党、军队、警察、法庭、监狱等政治组织形态和设施</p></li><li><p>国家</p><p><em>国家不是从来就有的，而是社会发展到一定历史阶段的产物。</em> </p><p><em>这种从社会中产生但又自居于社会之上并且日益同社会相异化的力量，就是国家。</em> </p><ul><li><p>产生：</p><ul><li>国家是按照地域来划分国民 的，而不再以血缘关系来划分。</li><li>国家依靠强制性或暴力手段以及征收赋税来维系。</li><li>国家是阶级矛盾不可调和的产物</li></ul></li><li><p>实质：一个阶级统治另一个阶级的工具，具有政治统治和社会管理职能的有组织的力量。</p><ul><li>它是经济上占支配地位的阶级为维护其根本利益而建立起来的强制性暴力机关，以保证其在政治上也成为统治阶级。</li><li>国家和社会完全统一之日，也就是国家消亡之时。</li></ul></li><li><p>国体：社会各阶级在国家的地位，国家政权掌握在哪个阶级手中。</p></li><li><p>政体：统治阶级实现其阶级统治的具体组织形式，统治阶级采取什么样的形式去组织自己的政权，实现自己的统治。</p></li><li><p>国体决定政体，政体服务于国体。</p></li></ul></li></ul></li></ul></li><li><p>上层建筑中，政治上层建筑占<strong>主导地位</strong>，国家政权是<strong>核心</strong>。 </p><blockquote><p>政治上层建筑可以主导 观念上层建筑，决定法律思想等。</p></blockquote></li></ul></li><li><p>经济基础和上层建筑的关系中</p><blockquote><p>辩证统一关系与生产力和生产关系的矛盾相同</p></blockquote><ul><li><p>经济基础<strong>决定</strong>上层建筑</p></li><li><p>上层建筑对经济基础具有反作用</p><ul><li>反作用集中表现在 为自己的经济基础服务。上层建筑的反作用是巨大的，但不是无限的，它可以<strong>影响</strong>社会性质和历史进程，但<strong>不能决定</strong>历史发展的总趋势。</li></ul><blockquote><p>生产力 决定 生产关系，经济基础 决定 上层建筑。</p><p>生产关系和经济基础是同级概念，因此，生产力 可以 决定 上层建筑， 生产关系可以决定上层建筑。</p></blockquote><ul><li><p>上层建筑反作用的性质，取决于它所服务的经济基础的性质，归根到底取决于它是否有利于生产力发展</p><p><em>上层建筑这种反作用的后果可能有两种：当他 为适合生产力发展要求的经济基础服务时，就成为推动社会发展的进步力量；反之，当它为落后的经济基础服务时，就成为阻碍社会发展的消极力量。</em> </p><blockquote><p>辨析：</p><p>判断生产关系是否先进：看生产关系是否适应生产力的发展。</p><p>判断上层建筑是否先进：看上层建筑 所服务的经济基础 是否适应生产力的 发展。</p><p>如果生产关系适应生产力的发展，生产力是先进的，经济基础也适应生产力发展，是先进的，那上层建筑服务于先进的经济基础，上层建筑就是先进的，推动社会发展。</p><p>反之，上层建筑 为落后的经济基础服务，即经济基础不适应于生产力，上层建筑阻碍社会发展。</p></blockquote></li></ul></li></ul></li><li><p><strong>社会发展的第二规律：上层建筑一定要适应经济基础发展状况的规律。</strong></p></li></ul><h3 id="44-社会形态更替的一般规律和特殊形式"><a href="#44-社会形态更替的一般规律和特殊形式" class="headerlink" title="44.社会形态更替的一般规律和特殊形式"></a>44.社会形态更替的一般规律和特殊形式</h3><p><em>马克思、恩格斯揭示的生产力与生产关系矛盾运动的规律和经济基础与上层建筑矛盾运动的规律，是<strong>人类社会发展的一般规律</strong>。</em> </p><ul><li><p>社会形态：关于社会运动的具体形式、发展阶段和不同质态的范畴，是 同生产力发展一定阶段相适应的 经济基础与上层建筑的统一体。</p><ul><li><p>社会形态 = 经济基础 + 上层建筑</p><blockquote><p>总结：</p><p>生产方式 = 生产力 + 生产关系</p><p>社会形态 = 经济基础 + 上层建筑</p><p>生产资料 = 劳动资料 + 劳动对象</p></blockquote></li><li><p>社会形态包括：社会的<strong>经济形态</strong>、<strong>政治形态和意识形态</strong> </p><blockquote><p>社会形态 = 经济基础 + 上层建筑</p><p>经济基础 对应 社会的经济形态，上层建筑（观念上层建筑 和 政治上层建筑） 对应政治形态和意识形态。</p></blockquote></li><li><p>马克思主义的<strong>社会形态范畴</strong> 深刻揭示了人类社会的本质结构及其发展的客观规律。</p><ul><li><p>全面的：</p><p>社会形态的内容是<strong>全面的</strong>，既包括经济基础，又包括上层建筑，两者缺一不可，犹如“骨骼”和“血肉”。<strong>经济基础是社会的“骨骼系统</strong>”，<strong>上层建筑是社会的“血肉系统</strong>”，上层建筑不过是经济基础的政治和思想的表现形态。</p><blockquote><p>骨骼 决定 血肉</p></blockquote></li><li><p>具体的：</p><p>社会形态是<strong>具体的</strong>，不是抽象的。</p></li><li><p>历史的：</p><p>社会形态是<strong>历史的</strong>，有它产生、发展和灭亡的过程。</p></li></ul></li></ul></li><li><p>社会形态更替的<strong>统一性和多样性</strong> </p><ul><li><p>社会形态更替的统一性：</p><p><em>社会历史可以划分为五种社会形态：原始社会、奴隶社会、封建社会、资本主义社会和共产主义社会（第一阶段是社会主义社会）</em> </p><ul><li>这五种社会形态的依次更替，是社会历史运动的一般过程和一般规律，表现社会形态更替的统一性。</li></ul></li><li><p>社会形态更新的多样性：</p><ul><li>有些国家在发展中经历了几种社会形态依次更替的典型过程，也有些国家在发展中超越了一个甚至几个社会形态而跨越式向前发展，甚至多种社会形态特征交叉渗透。</li><li>即使是同一种社会形态，在不同国家也会显现不同特点。</li></ul></li><li><p>社会形态更替统一性与多样性辩证关系</p><p><em>列宁指出：世界历史发展的一般规律，不仅丝毫不排斥个别发展阶段在发展的形式或顺序上表现出的特殊性，反而是以此为前提的。</em> </p></li></ul></li><li><p>社会形态更替的<strong>必然性</strong>与人们的<strong>历史选择性</strong> </p><blockquote><p>必然性，即客观必然性，是社会历史的客观规律。</p><p>人们的历史选择性，是能动的选择。</p></blockquote><ul><li>社会形态更替的必然性：社会形态依次更替的过程和规律是客观的，发展趋势是确定不移的。<ul><li>社会形态更替归根结底是社会基本矛盾运动的结果。</li><li>生产力与生产关系矛盾运动的规律性，从根本上规定了社会形态更替的客观必然性。</li></ul></li><li>人们的历史选择性：<ul><li>社会发展的客观必然性造成了一定历史阶段社会发展的基本趋势，为人们的历史选择提供了基础、范围和可能性空间。</li><li>社会形态更替的过程也是一个主观能动性与客观规律性相统一的过程。</li><li>人们的历史选择性归根结底社会人们群众的选择性，取决于人们群众的根本利益：<ul><li>取决于民族利益</li><li>取决于交往</li><li>取决于对历史必然性以及本民族特点的把握程度</li></ul></li></ul></li></ul></li><li><p>社会形态更替的前进性与曲折性</p><blockquote><p>否定之否定在社会形态更替上的应用。</p></blockquote><p><em>社会形态的更替还表现为历史的前进性与曲折性、顺序性与跨越性的统一。</em> </p><ul><li>社会形态更替的前进性、顺序性：五种社会形态依次演进的基本趋势，其历史过程是一个“扬弃”的过程。<ul><li>表明社会发展的总趋势是前进的。</li></ul></li><li>社会形态的曲折性、跨越性：每一次社会制度的变革，无不经过曲折反复的斗争。</li></ul></li></ul><blockquote><p>例题：</p><p>（错误）社会发展过程与自然界演变过程一样都是自觉的。</p><p>社会发展过程是自觉的，能动的，有人们的历史选择性。而自然界演变过程，没有人的参与，是自发的。</p><p>辨析：自觉和自发</p><p>自觉和自发是标志人们行为活动的觉悟程度的一对范畴。</p><p>同动物相比，人类一切有意思的活动都是自觉的。自然界的规律都是自发的。</p><p>而就人的活动本身而言，自发是指人们在社会活动中盲目地为历史必然性所支配。</p><p>（正确）人类总体历史进程是不可超越的。</p><p>总体，是站在人类历史发展规律的角度，即社会更替的统一性，是不可超越的。</p></blockquote><h3 id="45-社会基本矛盾在历史发展中的作用：社会发展的根本动力"><a href="#45-社会基本矛盾在历史发展中的作用：社会发展的根本动力" class="headerlink" title="45.社会基本矛盾在历史发展中的作用：社会发展的根本动力"></a>45.社会基本矛盾在历史发展中的作用：社会发展的根本动力</h3><ul><li><p>社会基本矛盾：生产力和生产关系、经济基础和上层建筑的矛盾</p></li><li><p>社会基本矛盾是社会发展的<strong>根本动力</strong> </p><p>她在历史发展中的作用主要表现在：</p><ol><li>生产力是社会基本矛盾运动中<strong>最基本的动力因素</strong>，是人类社会发展和进步的最终决定力量。 </li><li>社会基本矛盾特别是生产力和生产关系的矛盾，是“一切历史冲突的根源”，决定着社会中其他矛盾的存在和发展。</li><li>社会基本矛盾具有不同<strong>的表现形式</strong>和解决方式，并从根本上影响和促进社会形态的变化和发展。</li></ol></li></ul><h3 id="46-阶级斗争在阶级社会发展中的作用"><a href="#46-阶级斗争在阶级社会发展中的作用" class="headerlink" title="46.阶级斗争在阶级社会发展中的作用"></a><em>46.阶级斗争在阶级社会发展中的作用</em></h3><ul><li>阶级斗争是社会基本矛盾在阶级社会中的直接表现，是阶级社会发展的<strong>直接动力</strong>。 </li></ul><h3 id="47-社会革命在阶级社会发展中的作用"><a href="#47-社会革命在阶级社会发展中的作用" class="headerlink" title="47.社会革命在阶级社会发展中的作用"></a><em>47.社会革命在阶级社会发展中的作用</em></h3><ul><li>革命是实现社会形态更替的<strong>重要手段</strong> </li></ul><h3 id="48-改革的性质及其在社会发展中的作用"><a href="#48-改革的性质及其在社会发展中的作用" class="headerlink" title="48.改革的性质及其在社会发展中的作用"></a><em>48.改革的性质及其在社会发展中的作用</em></h3><ul><li>改革是推动社会发展的又一<strong>重要动力</strong></li></ul><h3 id="49-科学技术在社会发展中的作用"><a href="#49-科学技术在社会发展中的作用" class="headerlink" title="49.科学技术在社会发展中的作用"></a>49.科学技术在社会发展中的作用</h3><ul><li><p>科学技术革命是社会动力体系的一种<strong>重要动力</strong> </p><blockquote><p>考：夸大科学技术的作用，说根本动力，贬低科学技术的作用，没有影响。</p></blockquote><ol><li>现代科技革命推动<strong>生产方式</strong>的变革</li><li>现代科技革命推动<strong>生活方式</strong>的变革</li><li>现代科技革命推动<strong>思维方式</strong>的变革</li></ol></li></ul><h3 id="50-关于历史创造者的问题"><a href="#50-关于历史创造者的问题" class="headerlink" title="50.关于历史创造者的问题"></a><em>50.关于历史创造者的问题</em></h3><p><em>唯物史观和唯心史观的对立，在历史创造者问题上表现为群众史观和英雄史观的对立。</em> </p><ul><li><p>英雄史观：唯心史观从社会意识决定社会存在的基本前提，否认物质资料生产方式是社会发展的决定力量，抹杀人民群众的历史作用，宣扬少数英雄人物创作历史。</p></li><li><p>唯物史观考察历史创造者问题的原则：</p><ol><li><p>唯物史观立足于 <strong>现实的人</strong>及其本质 来把握历史的创造者。</p></li><li><p>唯物史观立足 <strong>整体的社会历史过程</strong>来探究历史创造者问题。</p></li><li><p>唯物史观从社会历史发展的<strong>必然性</strong>入手来考察和说明历史创造者及其活动。</p></li><li><p>唯物史观从人与历史关系的<strong>不同层次</strong> 考察谁是历史的创造者。</p><p><em>人与历史的关系具有类与历史、群体与历史、个体与历史三层关系。</em> </p></li></ol></li></ul><h3 id="51-现实的人及其本质"><a href="#51-现实的人及其本质" class="headerlink" title="51.现实的人及其本质"></a>51.现实的人及其本质</h3><ul><li><p>唯物史观认为：人不是 抽象的而<strong>是现实的</strong>，现实的人，不是处在某种虚幻的离群索居和固定不变状态的人，而是处在现实的、<strong>可以通过经验观察到的</strong>、在一定条件下进行的发展过程的人。</p></li><li><p><strong>人与动物</strong>相区别的层次上，<strong>人的本质在于劳动。</strong></p></li><li><p>从<strong>人与人</strong>层相区别的层次上，人的本质是一切社会关系的总和。</p><p><em>马克思指出：人的本质不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和。</em> </p><blockquote><p>有许多社会关系，而我是我的原因是，我是这些社会关系的这个节点。</p></blockquote><ul><li>人的本质是社会属性，而不是自然属性。</li></ul></li></ul><h3 id="52-人民群众创造历史原理"><a href="#52-人民群众创造历史原理" class="headerlink" title="52.人民群众创造历史原理"></a>52.人民群众创造历史原理</h3><ul><li><p>人民群众：是一个历史范畴。</p><ul><li><p>从质上看，人民群众是指<strong>一切对社会历史发展起推动作用的人</strong>，从量上看，人民群众是指<strong>社会人口中的绝大多数</strong>。</p><blockquote><p>人民群众：推动顺应社会历史发展。</p><p>反动派：阻碍社会历史发展。</p></blockquote></li><li><p>人民群众的最稳定的主体部分始终是<strong>从事物质资料生产的劳动群众及其知识分子</strong>。</p></li></ul></li><li><p>人民群众创造历史的原因（为什么说人民群众创造历史，起决定作用）</p><ol><li><p>人民群众是社会<strong>物质财富</strong>的创造者。</p><p><em>人类社会赖以存在和发展的基础是物质资料的生产方式。</em></p></li><li><p>人民群众是社会<strong>精神财富</strong>的创造者。</p></li><li><p>人民群众是<strong>社会变革的决定力量</strong>。</p><p><em>人民群众在创造社会财富的同时，也创造并改造着社会关系。生产关系的变革，社会制度的更替，最终取决于生产力的发展。但不会随着生产力的发展自发地实现和完成，而必须借助人民群众的力量。</em> </p></li><li><p>人民群众既是先进生产力和先进文化的<strong>创造主体</strong>，也是实现自身利益的<strong>根本力量。</strong> </p></li></ol></li><li><p>人民群众创造历史的活动收到一定社会历史条件的制约</p><ul><li>经济条件：根本制约因素</li><li>政治条件</li><li>精神文化条件</li></ul></li><li><p>人民群众创造历史原理的方法论：</p><ul><li>马克思主义群众观点：坚信人民群众自己解放自己的观点，全心全意为人民服务的观点，一切向人民群众负责的观点，虚心向群众学习的观点。</li><li>群众路线：一切为了群众，一切依靠群众，从群众中来，到群众中去。</li></ul><blockquote><p>为什么要一切为了群众，一切依靠群众，从群众中来，到群众中去？</p><p>考：方法论后面依靠的原理，即因为人民群众创造历史。</p></blockquote></li></ul><h3 id="53-个人在社会历史中的作用"><a href="#53-个人在社会历史中的作用" class="headerlink" title="53.个人在社会历史中的作用"></a><em>53.个人在社会历史中的作用</em></h3><p><em>唯物史观从人民群众创造历史这一基本前提出发，既明确了人民群众是历史的创造者，也不否认个人在历史上的作用。</em> </p><ul><li><p>历史人物对历史发展的具体过程始终起着一定的作用，有时甚至对历史事件的进程和结局发生决定性的影响，但不能决定历史发展的基本趋势。</p><blockquote><p>个人是与人民群众一起创造历史。</p><p>反动派不能创造历史（历史是哲学范畴的历史）</p></blockquote></li></ul><h1 id="政治经济学"><a href="#政治经济学" class="headerlink" title="政治经济学"></a>政治经济学</h1><ul><li>简单商品经济（54-60）<ul><li>价值是什么</li><li>价值如何衡量</li><li>价值如何表现</li><li>价值有何规律</li></ul></li><li>发达商品经济（资本主义以后的商品经济）<ul><li><strong>自由竞争阶段</strong> （重点）（61-70）</li><li>垄断阶段</li></ul></li></ul><h2 id="简单商品经济"><a href="#简单商品经济" class="headerlink" title="简单商品经济"></a>简单商品经济</h2><p><em>马克思主义不仅揭示了人类社会发展的一般规律，而且揭示了资本主义社会发展的特殊规律。特别是马克思的劳动价值论和剩余价值论，科学揭示了资本主义生产方式的本质和资本主义剥削的秘密。</em> </p><h3 id="54-资本主义生产关系的产生和生产方式的形成"><a href="#54-资本主义生产关系的产生和生产方式的形成" class="headerlink" title="54.资本主义生产关系的产生和生产方式的形成"></a><em>54.资本主义生产关系的产生和生产方式的形成</em></h3><p><em>资本主义生产关系的产生和资本主义生产方式的形成的过程，与商品经济的发展有着密不可分的关系。</em> </p><ul><li>商品经济的发展<ul><li>简单商品经济：以生产资料私有制和个体劳动力为基础</li><li>资本主义商品经济：以生产资料私有制和雇佣劳动为基础，是商品经济的高级发达形态。</li></ul></li><li>资本主义<strong>产生的途径</strong> <ul><li>从小商品经济分化出来</li><li>从商人和高利贷者转化而成</li></ul></li><li>资本<strong>原始积累</strong>的主要途径<ul><li>用暴力手段剥夺农民<strong>土地</strong></li><li>用暴力手段掠夺货币<strong>财富</strong>  </li></ul></li><li>通过资本主义革命和产业革命，最终建立起资本主义生产方式</li></ul><h3 id="55-价值是什么"><a href="#55-价值是什么" class="headerlink" title="55.价值是什么"></a>55.价值是什么</h3><ul><li><p><strong>商品经济</strong>：是<strong>以交换为目的</strong>而进行生产的经济形式</p><ul><li>商品经济产生的<strong>历史条件</strong>：<ul><li>存在社会分工</li><li>生产资料和劳动产品属于不同的所有者</li></ul></li></ul></li><li><p>商品的二因素：商品的使用价值和价值</p><ul><li><p>商品：用来交换、能满足人的某种需要的劳动产品</p></li><li><p><strong>使用价值</strong>：商品能满足人民某种需要的属性，即商品的有用性。</p><ul><li><p>反映<strong>人与自然</strong>之间的<strong>物质关系。</strong></p></li><li><p>是商品的<strong>自然属性</strong> </p></li><li><p>是一切劳动产品共有的属性</p><blockquote><p>劳动产品一定有使用价值，而有些劳动产品，不是为了交换，不是商品，比如为了自己用，也具有使用价值。</p><p>任何有用的物品都具有使用价值，诸如空气，也具有使用价值。</p></blockquote></li><li><p>使用价值构成社会财富的物质内容。</p></li></ul></li><li><p><strong>价值</strong>： 凝结在商品中的无差别的一般人类<strong>劳动</strong>，即人的脑力和体力的耗费。</p><blockquote><p>价值的本质 是 劳动，是藏在商品里的抽象劳动。</p><p>因此，没有蕴含劳动的物品就没有价值，比如空气，没有劳动蕴含其中，本身存在的，就没有价值。</p></blockquote><ul><li><p>价值是商品特有的<strong>社会属性</strong> </p></li><li><p>本质上体现了生产者之间的社会关系</p><p><em>商品的价值是劳动创造的，实质是凝结在商品中的无差别的一般人类劳动，商品交换实际上是商品生产者之间互相交换劳动的关系，商品价值的本质体现了生产者之间一定的社会关系。</em> </p></li></ul></li><li><p>交换价值：首先<strong>表现为</strong>一种使用价值同另一种使用价值想交换的量的关系或比例，<strong>决定</strong>商品交换的比例的不是商品的使用价值，<strong>而是价值</strong>。</p><blockquote><p>注意：商品的二因素只有使用价值和价值，交换价值是另一个概念。</p><p>交换价值，表面上是有用性比例的关系，但其实是商品背后蕴藏的劳动的比例关系。</p></blockquote><ul><li>价值是交换价值的<strong>基础</strong>，交换价值是价值的<strong>表现形式</strong>。 </li></ul></li><li><p>商品的价值和使用价值的关系：<strong>对立统一</strong> </p><ul><li><p>对立性：商品的使用价值和价值是相互排斥的，二者<strong>不可兼得</strong>。</p><p><em>要获得商品的价值，就必须放弃商品的使用价值；要得到商品的使用价值，就不能得到商品的价值。</em> </p></li><li><p>统一性：作为商品，必须同时具有使用价值和价值两个因素，二者<strong>缺一不可</strong>。 </p></li></ul></li></ul></li><li><p>劳动的二重性</p><p><em>商品是劳动产品，生产商品的劳动可区分为具体劳动和抽象劳动。</em> </p><ul><li><p>具体劳动：生产一定使用价值的<strong>具体形式</strong>的劳动，即有用劳动。</p><ul><li>形成商品的<strong>使用价值</strong></li></ul></li><li><p>抽象劳动：撇开一切具体形式的、无差别的一般人类劳动，即<strong>人的体力和脑力的消耗</strong>。 </p><ul><li>形成商品的<strong>价值实体</strong> </li></ul></li><li><p>具体劳动和抽象劳动的关系：对立统一</p><p><em>具体劳动和抽象劳动是同一劳动的两种规定。任何一种劳动，<strong>既是</strong>特殊的具体劳动，<strong>又是</strong>一般的抽象劳动，这就是劳动的二重性。</em> </p><p><em>正是劳动的二重性决定了商品的二因素。</em> </p><ul><li><p>一方面，具体劳动和抽象劳动在时间上和空间上是统一的，是商品生产者同一劳动过程的两个方面。</p></li><li><p>另一方面，具体劳动和抽象劳动又分别反映劳动的不同属性</p><ul><li><p>具体劳动反映的是<strong>人与自然</strong>的关系，是劳动的<strong>自然属性</strong></p><blockquote><p>使用价值反映的是人与自然的物质关系，是商品的自然属性。</p><p>具体劳动决定商品的使用价值。</p></blockquote></li><li><p>抽象劳动反映的是<strong>商品生产者的社会关系</strong>，是劳动的<strong>社会属性</strong></p><blockquote><p>价值本质体现了生产者之间的社会关系，是商品的社会属性。</p><p>抽象劳动决定商品的价值</p><p>因此，价值 就是 藏在商品里的抽象劳动。</p></blockquote></li></ul></li></ul></li></ul></li></ul><h3 id="56-价值如何衡量"><a href="#56-价值如何衡量" class="headerlink" title="56.价值如何衡量"></a>56.价值如何衡量</h3><ul><li><p>决定商品价值量的不是生产商品的个别劳动时间，而只能是<strong>社会必要劳动时间</strong>。 </p><ul><li><p>社会必要劳动时间：在现有的社会正常的生产条件下，在<strong>社会平均</strong>的劳动熟练程度和劳动强度下制造的某种使用价值所需要的劳动时间。</p><blockquote><p>是社会平均劳动时间。</p></blockquote></li></ul></li><li><p>商品的价值量与生产商品所耗费的<strong>劳动时间成正比</strong>，<strong>与劳动生产率成反比</strong>。</p><blockquote><p> 与生产商品所耗费的劳动时间成正比，指的是社会必要劳动时间。</p><p> 与劳动生产率成反比，劳动生产率是劳动者生产使用价值的效率，生产效率越高，所耗费的劳动时间越少，商品价值量也就越低。</p></blockquote><ul><li><p>影响劳动生产率的因素包括：</p><p>劳动者的平均熟练程度、科学技术的发展程度及其在生产中的应用、生产过程的社会结合、生产过程的社会结合、生产资料的规模和效能以及自然条件等。</p><blockquote><p>生产过程的社会结合，就是分工</p></blockquote></li><li><p><strong>劳动生产率的变化</strong>对商品价值总量的影响</p><blockquote><p>商品价值总量 = 单位商品对价值量 * 相同时间生产商品的数量</p></blockquote><table><thead><tr><th></th><th>单位商品的价值量</th><th>相同时间生产商品数量</th><th>商品价值总量</th></tr></thead><tbody><tr><td>社会劳动生产率增加</td><td>减少</td><td>增多</td><td>不变</td></tr><tr><td>个别劳动生产率增加</td><td>不变</td><td>增多</td><td>增多</td></tr></tbody></table></li></ul></li><li><p>商品价值量同简单劳动与复杂劳动有密切的关系</p><ul><li><p>简单劳动：不需要经过专门训练的培养的一般劳动者都能从事的劳动</p></li><li><p>复杂劳动：需要经过专门训练和培养，具有一定文化知识和技术专长的劳动者所从事的劳动</p></li><li><p>形成商品价值量的劳动是以<strong>简单劳动为尺度</strong>计量的，<strong>复杂劳动</strong>等于<strong>自乘的或多倍</strong>的简单劳动。</p><p><em>也就是说，少量的复杂劳动等于多量的简单劳动。在相同的劳动时间里，复杂劳动创造的价值大于简单劳动创造的价值。</em></p><ul><li>在以私有制为基础的商品经济条件下，复杂劳动转化为简单劳动，不是商品生产者自觉计算出来的，而是在商品交换过程中<strong>自发</strong>实现的。</li></ul></li></ul></li></ul><h3 id="57-价值如何表现"><a href="#57-价值如何表现" class="headerlink" title="57.价值如何表现"></a>57.价值如何表现</h3><blockquote><p>通过交换表现价值</p></blockquote><ul><li><p>商品的价值形式的发展经历了四个阶段：</p><ol><li><p>简单的或偶然的价值形式：1只绵羊 = 2把石斧</p></li><li><p>总和的或扩大的价值形式</p></li><li><p>一般的价值形式</p></li><li><p>货币形式</p></li></ol><p><em>金银天然不是货币，货币天然是金银。</em> </p><blockquote><p>金银只是大自然之物，而货币天生就应该是金银来充当，因为金银具备了充当货币的优良特点。</p><p>其他东西充当一般等价物时，不能叫货币，只有金银充当一般等价物时才能叫货币。</p></blockquote></li><li><p>货币：在长期交换过程中形成的固定地充当一般等价物的<strong>商品</strong>。</p></li><li><p>货币的五种基本职能：</p><ul><li><p><strong>价值尺度（最基本职能）</strong>：货币衡量和表现一切商品价值大小的作用</p><ol><li><p>原因：货币也是商品，也有价值，可以衡量其他商品的价值。</p></li><li><p>特点：可以是观念上的货币。</p><blockquote><p>衡量其他商品价值时，不一定有这么多货币，可以是头脑中想象的。</p></blockquote></li></ol></li><li><p><strong>流通手段（最基本职能）</strong> ：货币作为商品交换的媒介</p><blockquote><p>用货币可以交换其他商品。</p></blockquote><ol><li><p>必须是现实的货币</p><blockquote><p>现实的货币，电子钱包也是现实的货币。</p></blockquote></li><li><p>可以不足值</p><blockquote><p>金银，可能由于磕碰，其价值可能不足它代表的值，但还是按照它代表的值流通。</p><p>经济现象：劣币驱逐良币</p><p>因为货币作为流通手段时，可以不足值，所以衍生出了纸币，纸币 = 0价值（忽略纸币的价值），纸币是一个工具，代替货币作为流通手段。</p><p>但纸币没有价值，所以纸币不能执行价值尺度的功能。</p></blockquote></li></ol></li></ul><ol start="3"><li>储藏手段：货币推出流通领域作为社会财富的一般代表被保存起来的职能</li></ol><ul><li><p>支付手段：货币被用来<strong>清偿债务</strong>或<strong>支付赋税</strong>、<strong>租金</strong>、<strong>工资</strong></p><blockquote><p>辨析：</p><p>支付手段 vs 流通手段</p><p>流通手段：现货交易，与商品交换。</p><p>支付手段：没有现货。</p></blockquote></li><li><p>世界货币</p></li></ul></li><li><p>货币的产生使整个商品世界分化为两级：</p><ul><li>一极是各种各样的<strong>具体商品</strong>，分别代表不同的使用价值。</li></ul></li><li><p>一极是<strong>货币</strong>，只代表商品的价值。</p></li><li><p>这样就使商品 内在的使用价值和价值的矛盾 发展成为 外在的<strong>商品</strong>和<strong>货币</strong>的矛盾。</p><p>一切商品<strong>只要转化为货币</strong>，商品使用价值和价值的矛盾就能得到解决，从而使<strong>商品的价值得到实现</strong>。</p><ul><li>货币的出现有利于商品交换的困难性，但不能解决也不可能解决商品经济的基本矛盾。</li></ul></li></ul><h3 id="58-价值规律及其作用"><a href="#58-价值规律及其作用" class="headerlink" title="58.价值规律及其作用"></a>58.价值规律及其作用</h3><ul><li><p>价值规律的<strong>基本内容</strong>：</p><ul><li>商品的价值量由生产商品的社会必要劳动时间决定，</li><li>商品交换以价值量为基础，按照<strong>等价交换</strong>的原则进行。</li></ul></li><li><p>价值规律的<strong>表现形式</strong>：是商品的价格围绕商品的价值自发波动。</p><blockquote><p>决定商品价格的因素：</p><ul><li>供给：影响因素</li><li>币值：影响因素</li><li>价值：决定因素</li></ul></blockquote></li><li><p>价值规律的作用：</p><ul><li><p>积极作用：</p><ol><li><strong>自发地</strong>调节 生产资料和劳动力在社会各生产部门之间的分配比例。</li><li>自发地刺激社会生产力的发展</li><li>自发地调节社会收入的分配</li></ol></li><li><p>消极后果：</p><ol><li><p>导致社会资源浪费。</p><p>（价值规律自发调节社会资源在社会生产各部门的配置，可能出现比例失调的情况）</p></li><li><p>阻碍技术的进步。</p><p>（垄断的发生）</p></li><li><p>导致收入两极分化。</p></li></ol></li></ul></li></ul><h3 id="59-私有制基础上商品经济的基本矛盾"><a href="#59-私有制基础上商品经济的基本矛盾" class="headerlink" title="59.私有制基础上商品经济的基本矛盾"></a>59.私有制基础上商品经济的基本矛盾</h3><ul><li><p><strong>私人劳动</strong>和<strong>社会劳动</strong>的矛盾构成 <strong>私有制商品经济的基本矛盾</strong>（简单商品经济的基本矛盾）。</p><p><em>在以私有制为基础的商品经济中，商品生产者的劳动具有两重性，既是具有社会性质的社会劳动，又是具有私人性质的私人劳动。</em></p><blockquote><p>是每一种劳动，既是私人劳动，又是社会劳动，角度不同。</p><p>从生产资料私有制来看，是私人劳动，从社会分工的角度看，又是社会劳动。</p><p>在商品经济条件下，每个生产者的劳动本身是私人劳动，而私人劳动要转化为社会劳动，就必须用自己的产品去同别人的产品交换。</p><p><strong>交换</strong>是解决私人劳动和社会劳动之间矛盾的唯一途径。</p></blockquote></li><li><p>私人劳动和社会劳动之间的<strong>矛盾</strong> 在资本主义制度下，进一步发展成<strong>资本主义的基本矛盾</strong>，即生产资料资本主义私人占有 和 生产社会化之间的矛盾，正是这一<strong>矛盾不断运动</strong>，才使资本主义制度最终被社会主义制度所代替具有了客观必然性。</p></li></ul><h3 id="60-马克思劳动价值论的意义"><a href="#60-马克思劳动价值论的意义" class="headerlink" title="60.马克思劳动价值论的意义"></a>60.马克思劳动价值论的意义</h3><ul><li><p>马克思<strong>继承</strong>了古典政治经济学<strong>劳动创造价值理论</strong>的同时，<strong>创立</strong>了<strong>劳动二重性</strong>理论。 </p></li><li><p>劳动二重性理论称为理解政治经济学的<strong>枢纽</strong> 。</p></li><li><p>深化对马克思劳动价值论的认识</p><p><em>走进21世纪，面对新的情况，必须深化对马克思劳动价值论的认识，根据变化了的实践在继承的基础上有所创新、有所前进。</em> </p><ul><li>深化对创造价值的劳动的认识，对<strong>生产性劳动</strong>作出新的界定。</li><li>深化对<strong>科技人员、经营管理人员</strong>在社会生产和价值创造中所起的作用的认识</li><li><del>深化对科技、知识、信息等新的生产要素在财富和价值创造中的作用等认识。</del></li><li>深化对<strong>价值创造</strong>和<strong>价值分配</strong>关系对认识。</li></ul></li></ul><h2 id="发达商品经济-自由竞争阶段"><a href="#发达商品经济-自由竞争阶段" class="headerlink" title="发达商品经济-自由竞争阶段"></a>发达商品经济-自由竞争阶段</h2><blockquote><p>简单商品经济和发达商品经济的区别：劳动力成为商品</p></blockquote><h3 id="61-劳动力成为商品与货币转化为资本"><a href="#61-劳动力成为商品与货币转化为资本" class="headerlink" title="61.劳动力成为商品与货币转化为资本"></a>61.劳动力成为商品与货币转化为资本</h3><ul><li><p>劳动力：指人的劳动能力，是人的体力和脑力的总和。劳动力的使用即<strong>劳动</strong>。</p><blockquote><p>劳动者：人。</p><p>劳动力：体力和脑力的总和。</p></blockquote></li><li><p><strong>劳动力成为商品</strong>的基本条件：</p><ol><li>劳动者是自由人，能够把自己的劳动力当作自己的商品来支配。</li><li>劳动者没有别的商品可以出卖，自由得一无所有，没有任何实现自己的劳动力所必需的物质条件。</li></ol></li><li><p>劳动力的<strong>价值</strong>：是由生产、发展、<strong>维持和延续劳动力</strong>所必需的生活必需品的价值决定的。</p><p>包括三个部分：</p><ol><li><p>维持劳动者<strong>本人</strong>生存所必需的生活资料的价值</p></li><li><p>维持劳动者<strong>家属</strong>的生存所必需的生活资料的价值</p></li><li><p>劳动者接受教育和训练所支出的费用</p></li></ol><ul><li><p>劳动力价值的构成包含一个历史的和道德的因素。</p><blockquote><p>劳动力价值和历史时期、地区有关。</p></blockquote></li></ul></li><li><p>劳动力商品在使用价值上有一个很大的特点：它的<strong>使用价值是劳动</strong>，而<strong>劳动又是普通商品价值的源泉</strong>。</p><blockquote><p>劳动创造商品的价值。</p><p>而劳动力商品在消费的过程，就是在劳动的过程，就能够创造新的商品的价值。</p></blockquote><ul><li><p>货币所有者购买到这种特殊商品，<strong>能够增值，货币也就变成了资本</strong>。</p><p><em>劳动力商品在消费过程中能够创造新的价值，而且这个新的价值比劳动力本身的价值更大。</em> </p><p><em>正是由于这一特点，货币所有者购买到劳动力以后，在消费过程中，不仅能够收回他在购买这种商品时支付的价值，还能得到一个增值的价值即<strong>剩余价值</strong>。而<strong>一旦货币购买的劳动力带来剩余价值</strong>，<strong>货币也就变成了资本</strong>。</em> </p></li></ul></li><li><p>劳动力成为商品，货币转化为资本。</p></li></ul><h3 id="62-资本主义所有制"><a href="#62-资本主义所有制" class="headerlink" title="62.资本主义所有制"></a><em>62.资本主义所有制</em></h3><ul><li>资本家凭借对生产资料的占有，在等价交换原则的掩盖下，雇佣工人从事劳动，占有雇佣工人的剩余价值，这就是资本主义所有制的实质。</li></ul><h3 id="63-剩余价值的生产"><a href="#63-剩余价值的生产" class="headerlink" title="63.剩余价值的生产"></a>63.剩余价值的生产</h3><ul><li><p><strong>资本主义生产过程</strong> 是<strong>劳动过程</strong>和<strong>价值增殖</strong>过程的统一。</p><p><em>剩余价值是在资本主义的生产过程中生产出来的。</em> </p><p><em>资本主义的生产过程具有两重性，一方面是生产物质资料的劳动过程，另一方面是生产剩余价值的过程，即价值增殖过程。资本主义生产过程是劳动过程和价值增殖过程的统一。</em> </p><blockquote><p>工人在劳动，资本家在获得增值价值。</p></blockquote></li><li><p>样例：</p><ul><li><p>有一个做包子的资本家。</p><ul><li><p>情况一：</p><p>生产资料：40元的面</p><p>工人工资：20元</p><p>工人将40元的面生产为60元的包子，需要花费4个小时。</p><p>此时，剩余价值m = 0</p></li><li><p>情况二：</p><p>生产资料：80元的面</p><p>工人工资：20元</p><p>工人将80元的面生产为120元的包子，需要花费8个小时。</p><p>此时，<strong>剩余价值m = 20元</strong></p><blockquote><p>注意，工人的工资，即工人劳动力的价值是由生产、发展、<strong>维持和延续劳动力</strong>所必需的生活必需品的价值决定的，即上述1、2、3点，与工人的工作时间、强度无关。</p><p>所以工人的工资仍然为20元。</p></blockquote></li></ul></li></ul></li><li><p>剩余价值的生产——从劳动的方面来看</p><blockquote><p>劳动：</p><p>具体劳动产生商品的使用价值，抽象劳动产生商品的价值</p></blockquote><ul><li><p><strong>具体劳动</strong>的任务：</p><ol><li><p>转移“面粉”的价值，到包子的“价值上”</p><blockquote><p>将面的80元价值，转移到包子的价值中。</p></blockquote></li><li><p>生产包子的使用价值</p></li></ol></li><li><p>抽象劳动的任务：生产新价值</p><blockquote><p>情况二：</p><p>本来只有80元价值的面，20元价值的劳动力，经过工人的劳动，20元价值的劳动力不变，但产生了120元价值的包子。</p><p>120元的价值中有具体劳动时转移面的80元价值，还有抽象劳动生产的40元的新的价值。</p></blockquote></li></ul></li><li><p>剩余价值的生产——从资本的方面</p><p>全部预付资本100元：</p><ul><li><p>购买面粉的80元，借助<strong>具体劳动</strong>转移到最终产品中，不会增值。称为<strong>不变资本</strong>（C）。</p><ul><li><p><strong>不变资本</strong>：以<strong>生产资料形态</strong>存在的资本。</p><p><em>生产资料的价值通过工人的具体劳动被转移到新产品中，其转移到价值量不会大于它原有价值量，不发生增殖。</em>  </p></li></ul><blockquote><p>具体劳动的任务之一，转移生产资料的价值到商品的价值中去。</p></blockquote></li><li><p>购买工人的20元。由工人的劳动再创造出来，并能够增值。称之为<strong>可变资本</strong>（V）。并能够带来剩余价值（M）</p><ul><li><p><strong>可变资本</strong>：用来<strong>购买劳动力</strong>的那部分资本。</p><p><em>可变资本的价值在生产过程中不是被转移到新产品中去，而是由工人的劳动再生产出来。</em> </p><p><em>在生产过程中，工人所创造的新价值，不仅包括相当于劳动力价值的价值，而且还包括一定量的剩余价值。</em> </p></li></ul><blockquote><p>商品价值中除了生产资料转移过来的价值，还有工人抽象劳动产生的新价值。</p><p>可变成本V = 20元。</p><p>剩余价值M = 20元</p></blockquote></li><li><p>剩余价值率<strong>M‘ = M/V</strong>。衡量剥削程度。</p><blockquote><p>剩余价值率M’ = 100%</p></blockquote></li></ul></li><li><p>剩余价值的生产——从时间的方面</p><p>全天工作8小时</p><blockquote><p>8个小时工人创造40元的新价值，前4个小时创造20元，即工人的工资，后4个小时创造20元，为资本家劳动。</p></blockquote><ul><li><p>前4个小时。为自己劳动，创造劳动力价值，即工资，称之为<strong>必要劳动时间。</strong></p><ul><li><strong>必要劳动时间</strong>：用来产生生产劳动力价值或可变资本的价值的时间。</li></ul><blockquote><p>辨析：必要劳动时间和社会必要劳动时间。</p><p>社会必要劳动时间决定商品的价值量。</p><p>必要劳动时间是工人为自己劳动，创造工人劳动力价值的时间。</p></blockquote></li><li><p>后4个小时。为资本家劳动，创造剩余价值，称之为<strong>剩余劳动时间。</strong></p><ul><li><strong>剩余劳动时间</strong>：生产剩余价值的劳动时间。</li></ul></li></ul></li><li><p>剩余价值既不是由全部资本创造的，也不是由不变资本创造的，而是由<strong>可变资本</strong>雇佣的劳动者创造的。</p><ul><li>雇佣劳动者的<strong>剩余劳动</strong>是剩余价值的唯一源泉。</li><li>资本家对工人的剥削程度m’ = m/v = 剩余劳动/必要劳动 = 剩余劳动时间/必要劳动时间</li></ul></li><li><p>资本家提高对工人剥削程度的方法：绝对剩余价值的方法和相对剩余价值的生产</p><ul><li><p>绝对剩余价值：<strong>必要劳动时间不变</strong>的条件下，由于<strong>延长工作日的长度和提高劳动强度</strong>而生产的剩余价值。</p><blockquote><p>在相同长的劳动时间内比以前消耗更多的脑力和体力，这和延长工作日并没有本质区别，因此，由提高劳动强度而产生剩余价值的方法是绝对剩余价值生产方法。</p></blockquote></li><li><p>相对剩余价值：在<strong>工作日长度不变</strong>的条件下，通过<strong>缩短必要劳动时间</strong>而<strong>相对延长剩余劳动</strong>时间所生产的剩余价值。</p><blockquote><p>资本家在调整必要劳动时间与剩余劳动时间的比例上下功夫，通常缩短必要劳动时间、相对延长剩余劳动时间的方法，增加剩余价值的生产。</p></blockquote><ul><li><p>缩短必要劳动时间是通过<strong>全社会劳动生产率</strong>的提高实现的。</p><blockquote><p>社会生产率的提高（科学技术的革新），缩短了必要劳动时间，相对延长了剩余劳动时间。</p></blockquote></li></ul><blockquote><p>辨析：绝对剩余价值 和 相对剩余价值</p><p>都延长剩余劳动时间。</p><p>绝对剩余价值的生产没有缩短必要劳动时间，相对剩余价值的生产由缩短必要劳动时间。</p><p>绝对剩余价值没有科学技术革新，相对剩余价值有科学技术的革新。</p></blockquote></li><li><p>超额剩余价值：企业由于提高劳动生产率而使商品的个别价值低于社会价值的超额。</p><ul><li>全社会劳动生产率的提高是资本家追逐超额剩余价值的结果。</li><li>相对剩余价值是资本家追逐超额剩余价值的结果。</li></ul><p><em>单个资本家改进技术、改善管理的主动动机是追求超额剩余价值，但其客观后果则是整个社会各个生产部门的劳动生产率普遍提高，导致生活资料的价值下降和补偿劳动力价值的必要劳动时间缩短，而剩余劳动时间相对延长，整个资本家阶级普遍获得更多的相对剩余价值。</em> </p></li></ul></li><li><p>资本主义条件下的生产自动化是资本家<strong>获取超额剩余价值</strong>的手段，而<strong>雇佣工人的剩余劳动</strong>仍然是这种剩余价值的唯一源泉。</p><blockquote><p> 生产自动化：首先是不存在绝对的无人，其次，这些机器上也蕴含着资本家对制作机器工人的剥削。</p></blockquote></li></ul><h3 id="64-资本的积累"><a href="#64-资本的积累" class="headerlink" title="64.资本的积累"></a>64.资本的积累</h3><ul><li><p>资本<strong>积累</strong>：把剩余价值转化为资本，或者说，剩余价值的资本化。</p></li><li><p>资本主义再生产的特点：<strong>扩大再生产。</strong></p><ul><li>资本主义<strong>扩大再生产</strong>的<strong>源泉</strong>：资本积累</li><li>资本主义<strong>简单再生产</strong>：资本家获得剩余价值后，如果将其全部用于消费，则生产就在原有规模的基础上重复进行。</li></ul></li><li><p>资本积累的<strong>本质</strong>：资本家不断利用无偿占有的<strong>工人创造的剩余价值</strong>，来扩大自己的资本规模，进一步扩大和加强对工人的剥削和统治。</p><ul><li>资本积累的<strong>源泉</strong>：剩余价值</li></ul></li><li><p>资本积累规模的大小取决于：对工人的剥削程度、劳动生产率的高低、所用资本和所费资本之间的差额（投资的钱和花掉的钱的差额）以及资本家垫付资本的大小。</p></li><li><p><strong>资本的技术构成</strong>：由生产的技术水平所决定<strong>生产资料</strong>和<strong>劳动力</strong>之间的比例。</p><blockquote><p>在买包子例子中，资本的技术构成为4斤面：1个工人</p></blockquote></li><li><p><strong>资本的价值构成</strong>：资本分为不变资本和可变资本，这两部分资本价值之间的比例。</p><blockquote><p>在买包子的例子中，资本的价值构成为80元：20元</p></blockquote><blockquote><p>资本的不变资本，用来买生产资料。</p><p>资本的可变资本，用来买劳动力。</p></blockquote></li><li><p><strong>资本的有机构成</strong>：由资本技术构成决定并反映技术构成变化的<strong>资本价值构成</strong>。通常用c: v来表示。</p><blockquote><p>资本的有机构成是 资本的价值构成。</p><p><strong>前提条件</strong> 是资本的价值构成反映资本技术构成，即资本的技术构成改变，引起资本的价值构成改变。</p><p>如果资本的技术构成不变，但由于其他原因，资本的价值构成改变了，此时资本的价值构成就不是资本的有机构成。</p></blockquote></li><li><p>在资本主义生产过程中，资本有机构成呈现<strong>不断提高</strong>趋势。</p><blockquote><p>c: v，资本不断积累，c增大。</p></blockquote><ul><li><p>失业：资本的有机构成提高，<strong>可变资本</strong>相对量减少，资本对劳动力的需求日益相对地减少，结果就不可避免地造成大批工人失业，形成相对过剩人口。</p><blockquote><p>资本的积累，造成失业。</p></blockquote></li></ul></li><li><p>资本积累的历史趋势是资本主义制度的必然灭亡和社会主义制度的必然胜利</p><blockquote><p>资本积累 -&gt; 资本有机构成提高 -&gt; 相对剩余人口过剩（失业） -&gt; 贫富差距拉大（两级分化）-&gt;  资本主义灭亡</p></blockquote></li></ul><h3 id="65-剩余价值的循环"><a href="#65-剩余价值的循环" class="headerlink" title="65.剩余价值的循环"></a>65.剩余价值的循环</h3><ul><li><p>产业资本在循环过程中要经历三个不同阶段，与此联系的是资本依次执行三种不同职能：</p><ol><li>购买阶段，即生产资料和劳动力的购买阶段：产业资本执行的是货币资本的职能。</li><li>生产阶段，生产资料与劳动者相结合在一起从事资本主义生产的阶段：产业资本执行的是生产资本的职能。</li><li>售卖阶段，商品资本向货币资本转化的阶段：产业资本执行的是商品资本的职能。</li></ol></li><li><p>产业资本运动的两个基本条件：</p><ol><li><p>产业资本的三种职能形式必须在空间上并存。</p><p><em>产业资本必须按照一定比例同时存在于货币资本、生产资本和商品资本三种形式中。</em> </p></li><li><p>产业资本的三种职能形式必须在时间上继起。</p><p><em>产业资本循环的三种职能形式的转化必须保持时间上的依次连续性。</em> </p></li></ol></li><li><p>资本的<strong>周转</strong>：资本是在运动中增殖的，资本周而复始、不断反复的循环。</p><ul><li>影响资本周转快慢的因素有很多，关键的因素：<ol><li>资本周转的时间</li><li>生产资本中固定资本和流动资本的构成<ul><li>固定资本：资本家的资本分多次转移到最终的产品中，比如机器。</li><li>流动资本：资本家的资本一次转移到最终的产品中，比如做包子的面。</li></ul></li></ol></li></ul></li><li><p>总结：划分资本</p><blockquote><p>考：按照不同的维度判断该资本。</p></blockquote><table><thead><tr><th></th><th>内容</th><th>依据</th></tr></thead><tbody><tr><td>第一次划分</td><td>不变资本、可变资本</td><td>是否能增值（是否能产生剩余价值）</td></tr><tr><td>第二次划分</td><td>货币资本、生产资本、货币资本</td><td>资本执行的不同职能形式</td></tr><tr><td>第三次划分</td><td>固定资本、流动资本</td><td>资本的周转方式</td></tr></tbody></table></li><li><p>社会再生产的<strong>核心问题</strong>是<strong>社会总产品的实现问题</strong>，即社会总产品的<strong>价值补偿</strong>和<strong>实物补偿</strong>问题</p><ul><li>价值补偿：东西卖出去后，能收回钱。</li><li>实物补偿：东西卖出去后，为了后面的生产，需要补偿原材料。</li></ul></li><li><p>马克思将社会总产品在物质上划分为两大类，在价值上划分为三个组成部分。</p><blockquote><p>马克思，真的是大智慧啊！！！！</p></blockquote><ul><li><p>社会总产品：社会在一定时期（通常为一年）所生产的全部物质资料的总和。</p></li><li><p>社会总产品的<strong>物质形态</strong>上，根据其最终用途可以区分为用于生产消费的生产资料和用于生活消费的消费资料</p><ul><li>第一部类（Ⅰ）：由生产 <strong>生产资料</strong>的部门构成，其产品进入生产领域。</li><li>第二部类（Ⅱ）：由生产 <strong>消费资料</strong>的部门构成，其产品进入生活消费领域。</li></ul></li><li><p>社会总产品在<strong>价值形态</strong>上，又叫<strong>社会总价值</strong>(商品价值构成) = c + v + m</p><ul><li>产品中的生产资料的转移价值(c) </li><li>凝结在产品中的由工人必要劳动时间创造的价值(v)</li><li>凝结在产品中的由工人在剩余劳动时间创造的价值(m)</li></ul></li><li><p>第一部类的社会总价值 = Ⅰ(c) + <u>Ⅰ(v) + Ⅰ(m)</u></p><ul><li>其中Ⅰ(c)的来源可以从第一部类中自我解决</li><li>而 Ⅰ(v) + Ⅰ(m) ，一个是工人生活必需品的消耗，一个是资本家的生活必需品的消耗（家属资本家赚到的钱都去用了），Ⅰ(v) + Ⅰ(m) 需要从第二部类中来。</li></ul></li><li><p>第二部类的社会总价值 = <u>Ⅱ(c)</u> + Ⅱ(v) + Ⅱ(m)</p><ul><li>其中Ⅱ(c)的来源需要从第一部类中来</li><li>Ⅱ(v) + Ⅱ(m)，则可以从第二部类中自我解决</li></ul></li><li><p>需要满足Ⅰ(v) + Ⅰ(m) = Ⅱ(c)的平衡，这需要两部类的交换，当Ⅰ(v) + Ⅰ(m) &gt; Ⅱ(c)，就会造成资源浪费。</p><p><em>这两部类的生产都是在价值规律和剩余价值规律的作用下自发进行的，具有严重的盲目性，这就导致了这两大部类生产在规模上和结构上经常处于失衡状态。</em></p><p><em>这种失衡和脱节经常表现为生产过剩，以至于社会总产品的实现，即实物替换和价值补偿难以顺利进行，最严重的就是引发经济危机。</em> </p></li><li><p>经济危机的发生，实际上是资本主义条件下<strong>以强制的方式</strong> 解决社会再生产的实现问题的途径。</p><p>这种强制性地恢复平衡，是以社会经济生活的严重混乱以及社会资源和财富的极大浪费为代价的。</p></li></ul></li></ul><h3 id="66-工资与剩余价值的分配"><a href="#66-工资与剩余价值的分配" class="headerlink" title="66.工资与剩余价值的分配"></a>66.工资与剩余价值的分配</h3><ul><li><p>在资本主义制度下，工人工资：劳动力的价值或价格</p><ul><li><p>资本主义<strong>工资的本质</strong>：劳动力的价值或价格</p></li><li><p>工资<strong>表现为</strong>：“劳动的价格”或工人全部劳动的报酬</p><p><em>这就模糊了工人必要劳动和剩余劳动的界限，掩盖了资本主义的剥削关系。</em>  </p></li></ul></li><li><p>概念</p><ul><li><p>生产成本（成本价格）：不变资本和可变资本构成</p></li><li><p>利润：= 剩余价值</p><p><em>资本家并不把剩余价值看作可变资本的产物，而是把它看作全部垫付资本的产物或增长额。</em> </p></li><li><p>平均利润率：利润平均化形成的 社会的平均利润率（行业间的）</p><p><em>资本主义生产的目的是获得利润。为了得到尽可能高的利润率和尽可能多的利润，不同生产部门的资本家之间必然展开激烈的竞争，大量资本必然从利润率低的部门转投到利润率高的部门，从而<strong>导致利润率平均化</strong>。</em> </p></li><li><p>平均利润：按照平均利润率计算和获得的利润</p><p><em>在利润率平均化的过程中，形成了<strong>社会的平均利润率</strong>，按照平均利润率计算和获得的利润，叫做平均利润。</em> </p></li><li><p>生产价格：商品价值的转化形式， = 生产成本 + 平均利润</p><p><em>在价值转化为生产价格的条件下，价值规律作用的形式发生了变化：商品不再以价值而是<strong>以生产价格为基础进行交换</strong>，市场价格的变动不再以价值为中心，而是<strong>以生产价格为中心</strong>。</em>  </p><p><em>从全社会看，整个资本家阶级获得的利润总额与雇佣工人所创造的剩余价值总额是相等的；从个别部门看，商品的生产价格同价值不一致，但从全社会来看，商品的生产价格总额和价值总额相等</em></p></li><li><p>超额利润： = 超额剩余价值（行业内企业间的竞争）</p><blockquote><p>注意：</p><p>平均利润率是社会中行业间形成的，而超额利润是行业内企业之间形成的。</p><p>平均利润率的形成，并不影响企业革新获取超额利润。</p></blockquote></li></ul></li><li><p>在利润平均化规律作用下，产业资本家获得产业利润，商业资本家获得商业利润，银行资本家获得银行利润，土地所有者获得地租。</p></li></ul><h3 id="67-马克思剩余价值理论的意义"><a href="#67-马克思剩余价值理论的意义" class="headerlink" title="67.马克思剩余价值理论的意义"></a><em>67.马克思剩余价值理论的意义</em></h3><ul><li><p>马克思通过分析剩余价值的生产、积累、流通以及分配，解释了剩余价值的运动规律 ，<strong>创立了</strong>剩余价值理论。</p><blockquote><p>马克思在哲学上的两大成就：创立了唯物史观；形成了唯物辩证统一</p><p>马克思理论上的两大成就：创立了唯物史观；创立了剩余价值理论</p></blockquote></li><li><p>剩余价值理论深刻</p><ul><li><strong>揭露了</strong>资本主义生产关系的<strong>剥削本质</strong>，</li><li><strong>阐明了</strong>资产阶级与无产阶级之间<strong>阶级斗争的经济根源</strong>，</li><li><strong>指出了</strong>无产阶级革命的<strong>历史必然性</strong>。</li></ul></li><li><p>剩余价值理论是马克主义经济理论的基石，是无产阶级反对资产阶级、揭示资本主义制度剥削本质的锐利武器。</p></li><li><p>由于<strong>唯物史观和剩余价值</strong>的发现，社会主义由空想变为科学。</p></li></ul><h3 id="68-资本主义的基本矛盾与经济危机"><a href="#68-资本主义的基本矛盾与经济危机" class="headerlink" title="68.资本主义的基本矛盾与经济危机"></a>68.资本主义的基本矛盾与经济危机</h3><ul><li><p><strong>生产资料资本主义私人占有</strong>和<strong>生产社会化</strong>之间的矛盾，是资本主义的基本矛盾。</p><ul><li>这是生产力和生产关系之间的矛盾在资本主义社会的具体形式。</li></ul></li><li><p><strong>生产相对过剩</strong>是资本主义经济危机的<strong>本质特征</strong>。</p></li><li><p>经济危机的<strong>可能性</strong>是由货币作为<strong>支付手段和流通手段</strong>引起的。</p></li><li><p>资本主义经济危机爆发的<strong>根本原因</strong>是：资本主义的基本矛盾</p><p>这种基本矛盾具体表现为两个方面：</p><ol><li>表现为生产无限扩大的趋势与劳动人民有支付能力的需求相对缩小的矛盾。</li><li>表现为个别企业内部生产的有组织性和整个社会生产的无政府状态之间的矛盾</li></ol></li><li><p>经济危机一般包括四个阶段：危机、萧条、复苏和高涨</p><ul><li>危机是经济危机周期的基本阶段。</li></ul></li></ul><h3 id="69-资本主义的国家、政治制度及其本质"><a href="#69-资本主义的国家、政治制度及其本质" class="headerlink" title="69.资本主义的国家、政治制度及其本质"></a>69.资本主义的国家、政治制度及其本质</h3><ul><li>资本主义国家的<strong>职能</strong>是以服务于资本主义制度和资产阶级利益为根本内容的，是资产阶级进行政治统治的工具。<ul><li>资本主义国家的职能包括对内对外两个基本方面，<ul><li>即<strong>对内</strong>实行政治统治和社会管理</li><li><strong>对外</strong>进行国际交往和维护国家安全及利益</li></ul></li></ul></li><li>资本主义国家的<strong>本质</strong>是：资产阶级进行阶级统治的工具。</li><li>资本主义的<strong>民主制度</strong>：“主权在民”、“天赋人权”、“分权制衡”、“社会契约”、“自由、平等、博爱”</li><li>资本主义<strong>法制</strong>：<strong>宪法</strong>是资本主义国家法律制度的核心<ul><li>依据的基本原则：<ul><li>私有制原则</li><li>“主权在民”原则</li><li>分权与制衡原则</li><li>人权原则</li></ul></li></ul></li><li>资本主义<strong>国家政权</strong>：分权制衡的组织形式，即国家的立法权、行政区、司法权分别由三个权力主义独立行使。</li><li>资本主义政治制度的局限性：<ol><li>资本主义的民主是金钱操纵下的民主，实际是资产阶级精英统治下的民主。</li><li>法律名义上的平等掩盖着事实上的不平等。</li><li>资本主义国家的政党制是一种维护资产阶级统治的政治制度。<ul><li>资本主义多党制仍然是资产阶级选择自己的国家管理者、实现其内部利益平衡的政治机制。</li></ul></li><li>政党恶斗相互掣（che）肘时，决策效率低下，激化社会矛盾。</li></ol></li></ul><h3 id="70-资本主义的意识形态及其本质"><a href="#70-资本主义的意识形态及其本质" class="headerlink" title="70.资本主义的意识形态及其本质"></a><em>70.资本主义的意识形态及其本质</em></h3><ul><li>资本主义国家意识形态的本质：<ul><li>资本主义意识形态是资本主义社会条件下的观念上层建筑，是为资本主义社会形态的经济基础服务的。</li><li>资本主义意识形态是资产阶级的阶级意识的集中体现。</li></ul></li></ul><h2 id="发达商品经济-垄断阶段"><a href="#发达商品经济-垄断阶段" class="headerlink" title="发达商品经济-垄断阶段"></a>发达商品经济-垄断阶段</h2><h3 id="71-资本主义从竞争到垄断"><a href="#71-资本主义从竞争到垄断" class="headerlink" title="71.资本主义从竞争到垄断"></a>71.资本主义从竞争到垄断</h3><ul><li><p>资本主义的发展经历两个阶段：</p><ul><li><p><strong>自由竞争资本主义</strong></p></li><li><p><strong>垄断资本主义</strong></p><p><em>19世纪20世纪初，垄断取代自由竞争在资本主义经济中占据统治地位。</em> </p><ul><li>垄断资本主义的发展包括两种形式：<strong>私人</strong>垄断资本主义和<strong>国家</strong>垄断资本主义</li></ul></li></ul></li><li><p><strong>垄断</strong>：少数资本主义大企业，为了获得高额利润，通过互相<strong>协议或联合</strong>，对一个或几个部门商品的生产、销售和价格进行操作和控制。</p><ul><li><p>垄断的形成方式</p><p><em>自由竞争引起生产集中和资本集中，生产集中和资本集中发展到一定阶段必然引起垄断，这是资本主义发展的客观规律。</em> </p><ul><li><p>生产集中：<strong>生产资料、劳动力和商品</strong>的生产日益集中于少数大企业的过程，其结果是大企业所占的比重不断增加。</p></li><li><p>资本集中：大资本吞并小资本，或由许多小资本合并而成大资本的过程，其结果是越来越多的资本为少数大资本家所支配。</p><blockquote><p>钱集中。</p></blockquote></li></ul></li><li><p>垄断的形成原因：</p><ol><li>获得高额利润</li><li>形成竞争限制</li><li>避免两败俱伤</li></ol></li><li><p>垄断组织的<strong>本质</strong>：通过联合实现独占和瓜分商品生产和销售市场，操作垄断价格，以攫（jue）取高额垄断利润。</p></li></ul></li><li><p>垄断条件下的竞争</p><ul><li>垄断资本主义阶段存在<strong>竞争</strong>的主要原因：<ol><li>垄断没有消除产生竞争的经济条件（私有制）</li><li>垄断必须通过竞争来维持</li><li>不存在由一个垄断组织囊括一切部门、一切社会生产的绝对垄断</li></ol></li><li>垄断条件下的竞争同自由竞争相比，具有的<strong>新特点</strong> ：<ol><li>竞争的目的：<ul><li>自由竞争主要是为获得更多的利润或超额利润，不断扩大资本的积累</li><li>垄断条件下的竞争则是为获取高额垄断利润，并不断巩固、扩大已有的垄断地位</li></ul></li><li>竞争手段：<ul><li>自由竞争主要运用经济手段，如通过改进技术、提高劳动生产率、降低产品成本来战胜对手</li><li>垄断条件下的竞争不仅采取经济手段还采取非经济手段，使经济更加复杂、激烈</li></ul></li><li>竞争范围：<ul><li>自由竞争时期，竞争主要在经济领域，而且主要是国内市场上进行</li><li>垄断时期，国际市场上的竞争规模扩大，范围遍及各个领域和部门，并由国内扩展到国外</li></ul></li></ol></li></ul></li><li><p>金融资本：工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本</p><ul><li>金融资本形成的主要途径：金融联系、资本参与和人事参与</li></ul></li><li><p>金融寡头：操纵国民经济命脉，并在实际上<strong>控制国家政权</strong>的少数垄断资本家或垄断资本家集团</p><ul><li><p><strong>经济</strong>领域的统治：通过”参与制“实现的。</p><p><em>所谓参与制，即金融寡头通过掌握一定数量的股票来层层控制企业的制度</em> </p></li><li><p><strong>政治</strong>上的统治（金融寡头对国家机器的控制）：通过同政府的”个人联合“来实现的。</p><p>这种联合有多种途径：</p><ul><li>金融寡头直接出马把自己的代理人送进政府或议会，掌握政权，利用政治力量为其垄断统治服务</li><li>收买政府高官或国会议员，让他们在其政治活动中为金融寡头的利益服务</li><li>聘请曾在政府任职的高官到公司担任高级职务</li><li>建立政策咨询机构等方式对政府的政策施加影响，掌握新闻出版、广播电视、科学教育、文化体育等上层建筑的各个领域，左右国家的内政外交及社会生活。</li></ul></li></ul></li><li><p><strong>垄断利润</strong>：垄断资本家凭借其在社会生产和流通中的垄断地位而获得的超过平均利润的高额利润。</p><ul><li><p>垄断利润的来源：归根到底来自无产阶级和其他劳动人民所创造的剩余价值</p><ol><li>来自对<strong>本国无产阶级</strong>和其他劳动人民剥削的加强</li><li>通过控制市场占有<strong>其他企业</strong>特别是非垄断企业的利润</li><li>通过加强对其他国家劳动人民对剥削和掠夺获取的国外利润</li><li>通过资本主义国家政权进行有利于垄断资本的再分配，从而将劳动人民创造的国民收入的一部分变成垄断资本的收入。</li></ol></li><li><p>垄断利润的实现：垄断利润主要是通过垄断组织制定的<strong>垄断价格</strong>实现的 </p></li><li><p>垄断价格：垄断组织在销售或购买商品时，凭借其垄断地位规定的、旨在保证获取最大限度利润的市场价格。</p><ul><li><p><strong>垄断价格 = 成本价格 + 平均利润 + 垄断利润</strong> </p></li><li><p>垄断价格包括垄断高价和垄断低价</p><ul><li>垄断高价：垄断组织出售商品时规定的高于生产价格的价格</li><li>垄断低价：垄断组织在购买非垄断企业所生产的原材料等生产资料时规定的低于生产价格的价格</li></ul></li><li><p>垄断价格的产生并没有否定价值规律，它是价值规律在垄断资本主义阶段作用的具体表现。</p><ul><li><p>商品的价格围绕着商品的垄断价格自发波动</p><blockquote><p>价值规律的基本内容不变</p><p>表现形式：</p><p>简单商品经济：商品的价格围绕着商品的价值自发波动</p><p>自由竞争的资本主义商品经济：商品的价格围绕着商品的生产价格自发波动</p><p>垄断资本主义阶段：商品的价格围绕着商品的垄断价格自发波动</p></blockquote></li></ul></li></ul></li></ul></li></ul><h3 id="72-垄断资本主义的发展"><a href="#72-垄断资本主义的发展" class="headerlink" title="72.垄断资本主义的发展"></a>72.垄断资本主义的发展</h3><ul><li><p><strong>国家垄断资本主义</strong>：<strong>国家政权</strong>和<strong>私人垄断资本</strong>融合在一起的垄断资本主义</p><ul><li><p>国家垄断资本主义的<strong>形成原因</strong>：</p><ul><li>首先，（根本原因）社会生产力的发展，要求资本主义生产资料在更大范围内被支配，从而促进了国家垄断资本主义的产生</li><li>其次，经济波动和经济危机的深化，要求国家垄断资本主义的产生。</li><li>最后，缓和社会矛盾、协调利益关系，也要求国家垄断资本主义的产生。</li></ul></li><li><p>国家垄断资本主义的<strong>主要形式</strong>：</p><ul><li><p>国家所有并直接经营的企业</p></li><li><p>国家与私人共有、合营企业</p></li><li><p>国家通过多种形式参与私人垄断资本的再生产过程，包括国家作为商品和劳务的采购者，向私人垄断企业订货、提供补贴</p></li><li><p><strong>宏观调节</strong>：国家运用财政政策、货币政策等经济手段，对社会总供给和总需求进行调节</p><ul><li>目标：经济快速增长、充分就业、物价稳定和国际收支平衡</li></ul></li><li><p><strong>微观规制</strong> ：国家运用法律手段规范市场秩序，限制垄断，保护竞争、维护社会公众的合法利益</p><ul><li><p>目标：规范市场秩序，限制垄断，保护竞争、维护社会公众的合法利益</p></li><li><p>类型：其一是反托拉斯法（反垄断法）；其二是公共事业规制；其三是社会经济规制</p></li></ul></li></ul></li><li><p>对国家垄断资本主义的评价</p><ul><li>国家垄断资本主义是垄断资本主义的新发展，它对资本主义经济的发展产生了积极的作用</li><li>但是，国家垄断资本主义的出现并没有改变垄断资本主义的性质。</li><li>国家垄断资本主义的出现是资本主义<strong>经济制度内</strong>的经济关系调整，并没有从根本上消除资本主义的基本矛盾。</li></ul></li></ul></li><li><p>金融垄断资本的发展</p><ul><li>金融自由化和金融创新是金融垄断资本得以形成和壮大的重要制度条件</li><li>垄断资本主义的金融化程度不断提高：（体现在）<ol><li>金融业在国民经济中的地位大幅上升</li><li>实体经济的资本利润率下降</li><li>造业就业人数严重减少</li><li>虚拟经济越来越脱离实体经济</li></ol></li><li>金融垄断资本的发展，一方面促进了资本主义的发展，另一方面也造成了经济过度虚拟化，导致金融危机频繁发生，不仅给资本主义经济，也给全球经济带来灾难。</li></ul></li><li><p>垄断资本在世界范围的扩展</p><ul><li><p>垄断资本向世界范围扩展到经济动因：</p><ol><li>将国内过剩的资本输出</li><li>将部分非要害技术转移到国外</li><li>争夺商品销售市场</li><li>确保原材料和能源的可靠来源</li></ol></li><li><p>垄断资本向世界范围扩展到基本形式：</p><ol><li>借贷资本输出</li><li>生产资本输出</li><li>商品资本输出</li></ol><ul><li>输出资本的来源：一是私人资本输出；二是国家资本输出。</li></ul></li><li><p>经济社会后果：对资本输出国来说是有利的，对资本输入国来说是一把双刃剑。</p></li></ul></li><li><p><strong>国际垄断同盟</strong>：在经济上瓜分世界是通过垄断组织间的协议实现的，而协议的订立、瓜分的结果又以经济实力为后盾和基础。</p><ul><li>早期的国际垄断同盟主要是<strong>国际卡特尔</strong>。</li><li>当代的国际垄断同盟的形式以跨国公司和<strong>国家垄断资本主义的国际联盟</strong>为主。<ul><li>国家垄断资本主义的国际联盟：是由一些资本主义国家的政府出面缔结协定所组成的国际经济集团，如西方七国集团、欧盟。</li></ul></li></ul></li><li><p>第二次世界大战后，从事国际经济协调、维护国际经济秩序的<strong>国际性协调组织</strong>主要有三个：</p><ul><li>国际货币基金组织</li><li>世界银行</li><li>世界贸易组织</li></ul></li><li><p>评价：</p><p><em>垄断国际化条件下各种形式的国际垄断组织、国际垄断同盟和国际经济协调机构的发展，在一定程度上促进了经济全球化的发展，但它们从根本上说是<strong>为了维护资产阶级的利益</strong>、为他们攫取高额垄断利润服务的。</em></p></li><li><p><em>垄断资本主义的五个基本特征：</em></p><ol><li>垄断组织在经济生活中起决定作用</li><li>在金融资本的基础上形成金融寡头的统治</li><li>资本输出有了特别重要的意义</li><li>瓜分世界的资本家国际垄断同盟已经形成</li><li>最大资本主义列强已把世界上的领土分割完毕</li></ol></li></ul><h3 id="73-经济全球化及其后果"><a href="#73-经济全球化及其后果" class="headerlink" title="73.经济全球化及其后果"></a>73.经济全球化及其后果</h3><ul><li>经济全球化的表现<ul><li>国际分工进一步分化</li><li>贸易的全球化</li><li>金融的全球化（资本）</li><li>企业经营的全球化</li></ul></li><li>导致经济全球化迅猛发展的因素：<ul><li>科学技术的进步和生产力的发展（根本因素）</li><li>跨国公司的发展</li><li>各国经济体制的变革</li></ul></li><li>经济全球化的影响：“双刃剑”<ul><li>消极后果：<ol><li>发达国家与发展中国家在经济全球化过程中的地位和收益不平等、不平衡</li><li>加剧了发展中国家资源短缺和环境污染恶化</li><li>一定程度上增加经济风险</li></ol></li></ul></li></ul><h1 id="科学社会主义"><a href="#科学社会主义" class="headerlink" title="科学社会主义"></a>科学社会主义</h1><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这学期马原毛概并举，政治知识储备达到巅峰qwq&lt;/p&gt;
&lt;p&gt;看着徐涛老师的政治课复习，做了些许笔记，做个总结分享出来。&lt;/p&gt;
&lt;p&gt;「哲学们只是用不同的方式解释世界，而问题在于改变世界。——卡尔·马克思」&lt;/p&gt;
&lt;p&gt;马克思主义真是大智慧！！！&lt;/p&gt;
    
    </summary>
    
    
      <category term="政治" scheme="https://f7ed.com/categories/%E6%94%BF%E6%B2%BB/"/>
    
    
      <category term="政治" scheme="https://f7ed.com/tags/%E6%94%BF%E6%B2%BB/"/>
    
      <category term="马克思主义" scheme="https://f7ed.com/tags/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>「区块链」：Solidity-advanced</title>
    <link href="https://f7ed.com/2020/11/05/solidity-advanced/"/>
    <id>https://f7ed.com/2020/11/05/solidity-advanced/</id>
    <published>2020-11-04T16:00:00.000Z</published>
    <updated>2021-05-22T02:30:52.874Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity的<a href="https://cryptozombies.io/zh/course">官方教程</a>笔记：advanced。 </p><a id="more"></a><h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><h2 id="第1章-智能协议的永固性"><a href="#第1章-智能协议的永固性" class="headerlink" title="第1章: 智能协议的永固性"></a>第1章: 智能协议的永固性</h2><p>到现在为止，我们讲的 Solidity 和其他语言没有质的区别，它长得也很像 JavaScript。</p><p>但是，在有几点以太坊上的 DApp 跟普通的应用程序有着天壤之别。</p><p>第一个例子，在你把智能协议传上以太坊之后，它就变得<strong>不可更改</strong>, 这种永固性意味着你的代码永远不能被调整或更新。</p><p>你编译的程序会一直，永久的，不可更改的，存在以太坊上。这就是 Solidity 代码的安全性如此重要的一个原因。如果你的智能协议有任何漏洞，即使你发现了也无法补救。你只能让你的用户们放弃这个智能协议，然后转移到一个新的修复后的合约上。</p><p>但这恰好也是智能合约的一大优势。代码说明一切。如果你去读智能合约的代码，并验证它，你会发现，一旦函数被定义下来，每一次的运行，程序都会严格遵照函数中原有的代码逻辑一丝不苟地执行，完全不用担心函数被人篡改而得到意外的结果。</p><h3 id="外部依赖关系"><a href="#外部依赖关系" class="headerlink" title="外部依赖关系"></a>外部依赖关系</h3><p>在第2课中，我们将加密小猫（CryptoKitties）合约的地址硬编码到 DApp 中去了。有没有想过，如果加密小猫出了点问题，比方说，集体消失了会怎么样？ 虽然这种事情几乎不可能发生，但是，如果小猫没了，我们的 DApp 也会随之失效 – 因为我们在 DApp 的代码中用“硬编码”的方式指定了加密小猫的地址，如果这个根据地址找不到小猫，我们的僵尸也就吃不到小猫了，而按照前面的描述，我们却没法修改合约去应付这个变化！</p><p>我们不能硬编码，而要采用“函数”，以便于 DApp 的关键部分可以以参数形式修改。</p><p>我们不再一开始就把猎物地址给写入代码，而是写个函数 <code>setKittyContractAddress</code>, 运行时再设定猎物的地址，这样我们就可以随时去锁定新的猎物，也不用担心加密小猫集体消失了。</p><h2 id="第2章-Ownable-Contracts"><a href="#第2章-Ownable-Contracts" class="headerlink" title="第2章: Ownable Contracts"></a>第2章: Ownable Contracts</h2><h3 id="OpenZeppelin库的Ownable-合约"><a href="#OpenZeppelin库的Ownable-合约" class="headerlink" title="OpenZeppelin库的Ownable 合约"></a>OpenZeppelin库的<code>Ownable</code> 合约</h3><p>OpenZeppelin 是主打安保和社区审查的智能合约库，您可以在自己的 DApps中引用。等把这一课学完，您不要催我们发布下一课，最好利用这个时间把 OpenZeppelin 的网站看看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title <span class="variable">Ownable</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dev </span>The Ownable contract has an owner address, and provides basic authorization control</span></span><br><span class="line"><span class="comment"> * functions, this simplifies the implementation of "user permissions".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@dev </span>The Ownable constructor sets the original `owner` of the contract to the sender</span></span><br><span class="line"><span class="comment">   * account.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Ownable</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@dev </span>Throws if called by any account other than the owner.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@dev </span>Allows the current owner to transfer control of the contract to a newOwner.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>newOwner The address to transfer ownership to.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">transferOwnership</span>(<span class="params">address newOwner</span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(newOwner != address(<span class="number">0</span>));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面有没有您没学过的东东？</p><ul><li>构造函数：<code>function Ownable()</code>是一个 <strong>constructor</strong> (构造函数)，构造函数不是必须的，它与合约同名，构造函数一生中唯一的一次执行，就是在合约最初被创建的时候。</li><li>函数修饰符：<code>modifier onlyOwner()</code>。 修饰符跟函数很类似，不过是用来修饰其他已有函数用的， 在其他语句执行前，为它检查下先验条件。 在这个例子中，我们就可以写个修饰符 <code>onlyOwner</code> 检查下调用者，确保只有合约的主人才能运行本函数。我们下一章中会详细讲述修饰符，以及那个奇怪的<code>_;</code>。</li><li><code>indexed</code> 关键字：别担心，我们还用不到它。</li></ul><p>所以<code>Ownable</code> 合约基本都会这么干：</p><ol><li>合约创建，构造函数先行，将其 <code>owner</code> 设置为<code>msg.sender</code>（其部署者）</li><li>为它加上一个修饰符 <code>onlyOwner</code>，它会限制陌生人的访问，将访问某些函数的权限锁定在 <code>owner</code> 上。</li><li>允许将合约所有权转让给他人。</li></ol><p><code>onlyOwner</code> 简直人见人爱，大多数人开发自己的 Solidity DApps，都是从复制/粘贴 <code>Ownable</code> 开始的，从它再继承出的子类，并在之上进行功能开发。</p><p>既然我们想把 <code>setKittyContractAddress</code> 限制为 <code>onlyOwner</code> ，我们也要做同样的事情。</p><h2 id="第3章-onlyOwner-函数修饰符"><a href="#第3章-onlyOwner-函数修饰符" class="headerlink" title="第3章: onlyOwner 函数修饰符"></a>第3章: onlyOwner 函数修饰符</h2><p>现在我们有了个基本版的合约 <code>ZombieFactory</code> 了，它继承自 <code>Ownable</code> 接口，我们也可以给 <code>ZombieFeeding</code> 加上 <code>onlyOwner</code> 函数修饰符。</p><p>ZombieFeeding 是个 ZombieFactory </p><p>ZombieFactory 是个 Ownable</p><p>因此 <code>ZombieFeeding</code> 也是个 <code>Ownable</code>, 并可以通过 <code>Ownable</code> 接口访问父类中的函数/事件/修饰符。往后，<code>ZombieFeeding</code> 的继承者合约们同样也可以这么延续下去。</p><h3 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h3><p>函数修饰符看起来跟函数没什么不同，不过关键字<code>modifier</code> 告诉编译器，这是个<code>modifier(修饰符)</code>，而不是个<code>function(函数)</code>。它不能像函数那样被直接调用，只能被添加到函数定义的末尾，用以改变函数的行为。</p><p>咱们仔细读读 <code>onlyOwner</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dev </span>调用者不是‘主人’，就会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">modifier onlyOwner() &#123;</span><br><span class="line">  <span class="built_in">require</span>(msg.sender == owner);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onlyOwner</code> 函数修饰符是这么用的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract is Ownable &#123;</span><br><span class="line">  event LaughManiacally(string laughter);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意！ `onlyOwner`上场 :</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">likeABoss</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    LaughManiacally(<span class="string">"Muahahahaha"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>likeABoss</code> 函数上的 <code>onlyOwner</code> 修饰符。 当你调用 <code>likeABoss</code> 时：</p><ol><li><strong>首先执行</strong> <code>onlyOwner</code> 中的代码。</li><li>执行到 <code>onlyOwner</code> 中的 <code>_;</code> 语句时，程序再返回并执行 <code>likeABoss</code> 中的代码。</li></ol><p>可见，尽管函数修饰符也可以应用到各种场合，但最常见的还是放在函数执行之前添加快速的 <code>require</code>检查。</p><p>因为给函数添加了修饰符 <code>onlyOwner</code>，使得<strong>唯有合约的主人</strong>（也就是部署者）才能调用它。</p><blockquote><p>注意：主人对合约享有的特权当然是正当的，不过也可能被恶意使用。比如，万一，主人添加了个后门，允许他偷走别人的僵尸呢？</p></blockquote><blockquote><p>所以非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心，你需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门；作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心你，从而愿意把数据放在你的 DApp 中，这确实需要个微妙的平衡。</p></blockquote><h2 id="第4章-Gas"><a href="#第4章-Gas" class="headerlink" title="第4章: Gas"></a>第4章: Gas</h2><p>现在我们懂了如何在禁止第三方修改我们的合约的同时，留个后门给咱们自己去修改。</p><p>让我们来看另一种使得 Solidity 编程语言与众不同的特征：</p><h3 id="Gas-驱动以太坊DApps的能源"><a href="#Gas-驱动以太坊DApps的能源" class="headerlink" title="Gas - 驱动以太坊DApps的能源"></a>Gas - 驱动以太坊DApps的能源</h3><p>在 Solidity 中，你的用户想要每次执行你的 DApp 都需要支付一定的 <strong>gas</strong>，gas 可以用以太币购买，因此，用户每次跑 DApp 都得花费以太币。</p><p>一个 DApp 收取多少 gas 取决于功能逻辑的复杂程度。每个操作背后，都在计算完成这个操作所需要的计算资源，（比如，存储数据就比做个加法运算贵得多）， 一次操作所需要花费的 <strong>gas</strong> 等于这个操作背后的所有运算花销的总和。</p><p>由于运行你的程序需要花费用户的真金白银，在以太坊中代码的编程语言，比其他任何编程语言都更强调优化。</p><h3 id="为什么要用-gas-来驱动？"><a href="#为什么要用-gas-来驱动？" class="headerlink" title="为什么要用 gas 来驱动？"></a>为什么要用 gas 来驱动？</h3><p>以太坊就像一个巨大、缓慢、但非常安全的电脑。当你运行一个程序的时候，网络上的每一个节点都在进行相同的运算，以验证它的输出 —— 这就是所谓的“去中心化” 由于数以千计的节点同时在验证着每个功能的运行，这可以确保它的数据不会被被监控，或者被刻意修改。</p><p>可能会有用户用无限循环堵塞网络，抑或用密集运算来占用大量的网络资源，为了防止这种事情的发生，以太坊的创建者为以太坊上的资源制定了价格，想要在以太坊上运算或者存储，你需要先付费。</p><blockquote><p><em>注意：如果你使用侧链，倒是不一定需要付费，比如咱们在 Loom Network 上构建的 CryptoZombies 就免费。你不会想要在以太坊主网上玩儿“魔兽世界”吧？ - 所需要的 gas 可能会买到你破产。但是你可以找个算法理念不同的侧链来玩它。我们将在以后的课程中咱们会讨论到，什么样的 DApp 应该部署在太坊主链上，什么又最好放在侧链。</em></p></blockquote><h3 id="省-gas-的招数：结构封装-（Struct-packing）"><a href="#省-gas-的招数：结构封装-（Struct-packing）" class="headerlink" title="省 gas 的招数：结构封装 （Struct packing）"></a>省 gas 的招数：结构封装 （Struct packing）</h3><p>在第1课中，我们提到除了基本版的 <code>uint</code> 外，还有其他变种 <code>uint</code>：<code>uint8</code>，<code>uint16</code>，<code>uint32</code>等。</p><p>通常情况下我们不会考虑使用 <code>uint</code> 变种，因为无论如何定义 <code>uint</code>的大小，Solidity 为它保留256位的存储空间。例如，使用 <code>uint8</code> 而不是<code>uint</code>（<code>uint256</code>）不会为你节省任何 gas。</p><p>除非，把 <code>uint</code> 绑定到 <code>struct</code> 里面。</p><p>如果一个 <code>struct</code> 中有多个 <code>uint</code>，则尽可能使用较小的 <code>uint</code>, Solidity 会将这些 <code>uint</code> 打包在一起，从而占用较少的存储空间。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct NormalStruct &#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct MiniMe &#123;</span><br><span class="line">  uint32 a;</span><br><span class="line">  uint32 b;</span><br><span class="line">  uint c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为使用了结构打包，`mini` 比 `normal` 占用的空间更少</span></span><br><span class="line">NormalStruct normal = NormalStruct(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">MiniMe mini = MiniMe(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>所以，当 <code>uint</code> 定义在一个 <code>struct</code> 中的时候，尽量使用最小的整数子类型以节约空间。 并且把同样类型的变量放一起（即在 struct 中将把变量按照类型依次放置），这样 Solidity 可以将存储空间最小化。例如，有两个 <code>struct</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint</span> c; <span class="keyword">uint32</span> a; <span class="keyword">uint32</span> b;<span class="string">` 和 `</span><span class="keyword">uint32</span> a; <span class="keyword">uint</span> c; <span class="keyword">uint32</span> b;</span><br></pre></td></tr></table></figure><p>前者比后者需要的gas更少，因为前者把<code>uint32</code>放一起了。</p><h2 id="第5章-时间单位"><a href="#第5章-时间单位" class="headerlink" title="第5章: 时间单位"></a>第5章: 时间单位</h2><p><code>level</code> 属性表示僵尸的级别。以后，在我们创建的战斗系统中，打胜仗的僵尸会逐渐升级并获得更多的能力。</p><p><code>readyTime</code> 稍微复杂点。我们希望增加一个“冷却周期”，表示僵尸在两次猎食或攻击之之间必须等待的时间。如果没有它，僵尸每天可能会攻击和繁殖1,000次，这样游戏就太简单了。</p><p>为了记录僵尸在下一次进击前需要等待的时间，我们使用了 Solidity 的时间单位。</p><h3 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h3><p>Solidity 使用自己的本地时间单位。</p><p>变量now:</p><p>变量 <code>now</code> 将返回当前的unix时间戳（自1970年1月1日以来经过的秒数）。我写这句话时 unix 时间是 <code>1604319686</code>。</p><blockquote><p>注意：Unix时间传统用一个32位的整数进行存储。这会导致“2038年”问题，当这个32位的unix时间戳不够用，产生溢出，使用这个时间的遗留系统就麻烦了。所以，如果我们想让我们的 DApp 跑够20年，我们可以使用64位整数表示时间，但为此我们的用户又得支付更多的 gas。真是个两难的设计啊！</p></blockquote><p>时间单位：seconds minutes hours days weeks years</p><p>Solidity 还包含<code>秒(seconds)</code>，<code>分钟(minutes)</code>，<code>小时(hours)</code>，<code>天(days)</code>，<code>周(weeks)</code> 和 <code>年(years)</code> 等时间单位。它们都会转换成对应的秒数放入 <code>uint</code> 中。所以 <code>1分钟</code> 就是 <code>60</code>，<code>1小时</code>是 <code>3600</code>（60秒×60分钟），<code>1天</code>是<code>86400</code>（24小时×60分钟×60秒）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint lastUpdated;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将‘上次更新时间’ 设置为 ‘现在’</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTimestamp</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">  lastUpdated = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果到上次`updateTimestamp` 超过5分钟，返回 'true'</span></span><br><span class="line"><span class="comment">// 不到5分钟返回 'false'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fiveMinutesHavePassed</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (now &gt;= (lastUpdated + <span class="number">5</span> minutes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这些工具，我们可以为僵尸设定“冷静时间”功能。</p><h2 id="第6章-僵尸冷却"><a href="#第6章-僵尸冷却" class="headerlink" title="第6章: 僵尸冷却"></a>第6章: 僵尸冷却</h2><p>首先，我们要定义一些辅助函数，设置并检查僵尸的 <code>readyTime</code>。</p><h3 id="将结构体作为参数传入"><a href="#将结构体作为参数传入" class="headerlink" title="将结构体作为参数传入"></a>将结构体作为参数传入</h3><p>由于结构体的存储指针可以以参数的方式传递给一个 <code>private</code> 或 <code>internal</code> 的函数，因此结构体可以在多个函数之间相互传递。</p><p>把结构体作为指针，因此传递参数前需要加<code>storage</code> </p><p>遵循这样的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_doStuff</span>(<span class="params">Zombie storage _zombie</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// do stuff with _zombie</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以将某僵尸的引用直接传递给一个函数，而不用是通过参数传入僵尸ID后，函数再依据ID去查找。</p><h2 id="第7章-公有函数和安全性"><a href="#第7章-公有函数和安全性" class="headerlink" title="第7章: 公有函数和安全性"></a>第7章: 公有函数和安全性</h2><p>你必须仔细地检查所有声明为 <code>public</code> 和 <code>external</code>的函数，一个个排除用户滥用它们的可能，谨防安全漏洞。请记住，如果这些函数没有类似 <code>onlyOwner</code> 这样的函数修饰符，用户能利用各种可能的参数去调用它们。</p><h2 id="第8章-进一步了解函数修饰符"><a href="#第8章-进一步了解函数修饰符" class="headerlink" title="第8章: 进一步了解函数修饰符"></a>第8章: 进一步了解函数修饰符</h2><p>我们打算让僵尸在达到一定水平后，获得特殊能力。但是达到这个小目标，我们还需要学一学什么是“函数修饰符”。</p><h3 id="带参数的函数修饰符"><a href="#带参数的函数修饰符" class="headerlink" title="带参数的函数修饰符"></a>带参数的函数修饰符</h3><p>之前我们已经读过一个简单的函数修饰符了：<code>onlyOwner</code>。函数修饰符也可以带参数。例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储用户年龄的映射</span></span><br><span class="line">mapping (uint =&gt; uint) public age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定用户年龄的修饰符</span></span><br><span class="line">modifier older<span class="constructor">Than(<span class="params">uint</span> <span class="params">_age</span>, <span class="params">uint</span> <span class="params">_userId</span>)</span> &#123;</span><br><span class="line">  require(age<span class="literal">[<span class="identifier">_userId</span>]</span> &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span></span><br><span class="line"><span class="comment">// 我们可以用如下参数调用`olderThan` 修饰符:</span></span><br><span class="line"><span class="keyword">function</span> drive<span class="constructor">Car(<span class="params">uint</span> <span class="params">_userId</span>)</span> public older<span class="constructor">Than(16, <span class="params">_userId</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 其余的程序逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了吧， <code>olderThan</code> 修饰符可以像函数一样接收参数，是“宿主”函数 <code>driveCar</code> 把参数传递给它的修饰符的。</p><p>来，我们自己生产一个修饰符，通过传入的<code>level</code>参数来限制僵尸使用某些特殊功能。</p><h3 id="带参数的函数修饰符-1"><a href="#带参数的函数修饰符-1" class="headerlink" title="带参数的函数修饰符"></a>带参数的函数修饰符</h3><p>之前我们已经读过一个简单的函数修饰符了：<code>onlyOwner</code>。函数修饰符也可以带参数。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储用户年龄的映射</span></span><br><span class="line">mapping (<span class="function"><span class="params">uint</span> =&gt;</span> uint) public age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定用户年龄的修饰符</span></span><br><span class="line">modifier olderThan(uint _age, uint _userId) &#123;</span><br><span class="line">  <span class="built_in">require</span>(age[_userId] &gt;= _age);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须年满16周岁才允许开车 (至少在美国是这样的).</span></span><br><span class="line"><span class="comment">// 我们可以用如下参数调用`olderThan` 修饰符:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">driveCar</span>(<span class="params">uint _userId</span>) <span class="title">public</span> <span class="title">olderThan</span>(<span class="params"><span class="number">16</span>, _userId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 其余的程序逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了吧， <code>olderThan</code> 修饰符可以像函数一样接收参数，是“宿主”函数 <code>driveCar</code> 把参数传递给它的修饰符的。</p><p>来，我们自己生产一个修饰符，通过传入的<code>level</code>参数来限制僵尸使用某些特殊功能。</p><ol><li>记住，修饰符的最后一行为 <code>_;</code>，表示修饰符调用结束后返回，并执行调用函数余下的部分。</li></ol><h2 id="第10章-利用-‘View’-函数节省-Gas"><a href="#第10章-利用-‘View’-函数节省-Gas" class="headerlink" title="第10章: 利用 ‘View’ 函数节省 Gas"></a>第10章: 利用 ‘View’ 函数节省 Gas</h2><p>现在需要添加的一个功能是：我们的 DApp 需要一个方法来查看某玩家的整个僵尸军团 - 我们称之为 <code>getZombiesByOwner</code>。</p><p>实现这个功能只需从区块链中读取数据，所以它可以是一个 <code>view</code> 函数。这让我们不得不回顾一下“gas优化”这个重要话题。</p><h3 id="“view”-函数不花-“gas”"><a href="#“view”-函数不花-“gas”" class="headerlink" title="“view” 函数不花 “gas”"></a>“view” 函数不花 “gas”</h3><p>当玩家从外部调用一个<code>view</code>函数，是不需要支付一分 gas 的。</p><p>这是因为 <code>view</code> 函数不会真正改变区块链上的任何数据 - 它们只是读取。因此用 <code>view</code> 标记一个函数，意味着告诉 <code>web3.js</code>，运行这个函数只需要查询你的本地以太坊节点，而不需要在区块链上创建一个事务（事务需要运行在每个节点上，因此花费 gas）。</p><p>稍后我们将介绍如何在自己的节点上设置 web3.js。但现在，你关键是要记住，在所能只读的函数上标记上表示“只读”的“<code>external view</code> 声明，就能为你的玩家减少在 DApp 中 gas 用量。</p><blockquote><p><em>注意：如果一个</em> <code>view</code> <em>函数在另一个函数的内部被调用，而调用函数与</em> <code>view</code> <em>函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为</em> <code>view</code> <em>的函数只有在外部调用时才是免费的。</em></p></blockquote><h2 id="第11章-存储非常昂贵"><a href="#第11章-存储非常昂贵" class="headerlink" title="第11章: 存储非常昂贵"></a>第11章: 存储非常昂贵</h2><p>Solidity 使用<code>storage</code>(存储)是相当昂贵的，”写入“操作尤其贵。</p><p>这是因为，无论是写入还是更改一段数据， 这都将永久性地写入区块链。”永久性“啊！需要在全球数千个节点的硬盘上存入这些数据，随着区块链的增长，拷贝份数更多，存储量也就越大。这是需要成本的！</p><p>为了降低成本，不到万不得已，避免将数据写入存储。这也会导致效率低下的编程逻辑 - 比如每次调用一个函数，都需要在 <code>memory</code>(内存) 中重建一个数组，而不是简单地将上次计算的数组给存储下来以便快速查找。</p><p>遍历大数据集合都是昂贵的。但是在 Solidity 中，使用一个标记了<code>external view</code>的函数，遍历比 <code>storage</code> 要便宜太多，因为 <code>view</code> 函数不会产生任何花销。 （gas可是真金白银啊！）。</p><p>我们将在下一章讨论<code>for</code>循环，现在我们来看一下看如何如何在内存中声明数组。</p><h3 id="在内存中声明数组"><a href="#在内存中声明数组" class="headerlink" title="在内存中声明数组"></a>在内存中声明数组</h3><p>在数组后面加上 <code>memory</code>关键字， 表明这个数组是仅仅在内存中创建，不需要写入外部存储，并且在函数调用结束时它就解散了。与在程序结束时把数据保存进 <code>storage</code> 的做法相比，内存运算可以大大节省gas开销 – 把这数组放在<code>view</code>里用，完全不用花钱。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArray</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">pure</span> <span class="title">returns</span>(<span class="params">uint[]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化一个长度为3的内存数组</span></span><br><span class="line">  uint[] memory values = <span class="keyword">new</span> uint[](<span class="number">3</span>);</span><br><span class="line">  <span class="comment">// 赋值</span></span><br><span class="line">  values.push(<span class="number">1</span>);</span><br><span class="line">  values.push(<span class="number">2</span>);</span><br><span class="line">  values.push(<span class="number">3</span>);</span><br><span class="line">  <span class="comment">// 返回数组</span></span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个小例子展示了一些语法规则，下一章中，我们将通过一个实际用例，展示它和 <code>for</code> 循环结合的做法。</p><blockquote><p>注意：内存数组 <strong>必须</strong> 用长度参数（在本例中为<code>3</code>）创建。目前不支持 <code>array.push()</code>之类的方法调整数组大小，在未来的版本可能会支持长度修改。</p></blockquote><h2 id="第12章-For-循环"><a href="#第12章-For-循环" class="headerlink" title="第12章: For 循环"></a>第12章: For 循环</h2><p>我们提到过，函数中使用的数组是运行时在内存中通过 <code>for</code> 循环实时构建，而不是预先建立在存储中的。</p><p>为什么要这样做呢？</p><p>为了实现 <code>getZombiesByOwner</code> 函数，一种“无脑式”的解决方案是在 <code>ZombieFactory</code> 中存入”主人“和”僵尸军团“的映射。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint[]) <span class="keyword">public</span> ownerToZombies</span><br></pre></td></tr></table></figure><p>然后我们每次创建新僵尸时，执行 <code>ownerToZombies [owner] .push（zombieId）</code> 将其添加到主人的僵尸数组中。而 <code>getZombiesByOwner</code> 函数也非常简单：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getZombiesByOwner</span><span class="params">(address _owner)</span> <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> <span class="params">(uint[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ownerToZombies[_owner];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="这个做法有问题"><a href="#这个做法有问题" class="headerlink" title="这个做法有问题"></a>这个做法有问题</h3><p>做法倒是简单。可是如果我们需要一个函数来把一头僵尸转移到另一个主人名下（我们一定会在后面的课程中实现的），又会发生什么？</p><p>这个“换主”函数要做到：</p><p>1.将僵尸push到新主人的 <code>ownerToZombies</code> 数组中， 2.从旧主的 <code>ownerToZombies</code> 数组中移除僵尸， 3.将旧主僵尸数组中“换主僵尸”之后的的每头僵尸都往前挪一位，把挪走“换主僵尸”后留下的“空槽”填上， 4.将数组长度减1。</p><p>但是第三步实在是太贵了！因为每挪动一头僵尸，我们都要执行一次写操作。如果一个主人有20头僵尸，而第一头被挪走了，那为了保持数组的顺序，我们得做19个写操作。</p><p>由于写入存储是 Solidity 中最费 gas 的操作之一，使得换主函数的每次调用都非常昂贵。更糟糕的是，每次调用的时候花费的 gas 都不同！具体还取决于用户在原主军团中的僵尸头数，以及移走的僵尸所在的位置。以至于用户都不知道应该支付多少 gas。</p><blockquote><p>注意：当然，我们也可以把数组中最后一个僵尸往前挪来填补空槽，并将数组长度减少一。但这样每做一笔交易，都会改变僵尸军团的秩序。</p></blockquote><p>由于从外部调用一个 <code>view</code> 函数是免费的，我们也可以在 <code>getZombiesByOwner</code> 函数中用一个for循环遍历整个僵尸数组，把属于某个主人的僵尸挑出来构建出僵尸数组。那么我们的 <code>transfer</code> 函数将会便宜得多，因为我们不需要挪动存储里的僵尸数组重新排序，总体上这个方法会更便宜，虽然有点反直觉。</p><h3 id="使用-for-循环"><a href="#使用-for-循环" class="headerlink" title="使用 for 循环"></a>使用 <code>for</code> 循环</h3><p><code>for</code>循环的语法在 Solidity 和 JavaScript 中类似。</p><p>来看一个创建偶数数组的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEvens</span>(<span class="params"></span>) <span class="title">pure</span> <span class="title">external</span> <span class="title">returns</span>(<span class="params">uint[]</span>) </span>&#123;</span><br><span class="line">  uint[] memory evens = <span class="keyword">new</span> uint[](<span class="number">5</span>);</span><br><span class="line">  <span class="comment">// 在新数组中记录序列号</span></span><br><span class="line">  uint counter = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 在循环从1迭代到10：</span></span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果 `i` 是偶数...</span></span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 把它加入偶数数组</span></span><br><span class="line">      evens[counter] = i;</span><br><span class="line">      <span class="comment">//索引加一， 指向下一个空的‘even’</span></span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> evens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数将返回一个形为 <code>[2,4,6,8,10]</code> 的数组。</p><h1 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h1><h1 id="第1章-可支付"><a href="#第1章-可支付" class="headerlink" title="第1章: 可支付"></a>第1章: 可支付</h1><p>截至目前，我们只接触到很少的 <strong>函数修饰符</strong>。 要记住所有的东西很难，所以我们来个概览：</p><ol><li>我们有决定函数何时和被谁调用的可见性修饰符: <code>private</code> 意味着它只能被合约内部调用； <code>internal</code> 就像 <code>private</code> 但是也能被继承的合约调用； <code>external</code> 只能从合约外部调用；最后 <code>public</code> 可以在任何地方调用，不管是内部还是外部。</li><li>我们也有状态修饰符， 告诉我们函数如何和区块链交互: <code>view</code> 告诉我们运行这个函数不会更改和保存任何数据； <code>pure</code> 告诉我们这个函数不但不会往区块链写数据，它甚至不从区块链读取数据。这两种在被从合约外部调用的时候都不花费任何gas（但是它们在被内部其他函数调用的时候将会耗费gas）。</li><li>然后我们有了自定义的 <code>modifiers</code>，例如在第三课学习的: <code>onlyOwner</code> 和 <code>aboveLevel</code>。 对于这些修饰符我们可以自定义其对函数的约束逻辑。</li></ol><p>这些修饰符可以同时作用于一个函数定义上：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> <span class="title">external</span> <span class="title">view</span> <span class="title">onlyOwner</span> <span class="title">anotherModifier</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>在这一章，我们来学习一个新的修饰符 <code>payable</code>.</p><h2 id="payable-修饰符"><a href="#payable-修饰符" class="headerlink" title="payable 修饰符"></a><code>payable</code> 修饰符</h2><p><code>payable</code> 方法是让 Solidity 和以太坊变得如此酷的一部分 —— 它们是一种可以接收以太的特殊函数。</p><p>当你在调用一个普通网站服务器上的API函数的时候，你无法用你的函数传送美元——你也不能传送比特币。</p><p>但是在以太坊中， 因为钱 (<em>以太</em>), 数据 (<em>事务负载</em>)， 以及合约代码本身都存在于以太坊。你可以在同时调用函数 <strong>并</strong>付钱给另外一个合约。</p><p>这就允许出现很多有趣的逻辑， 比如向一个合约要求支付一定的钱来运行一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract OnlineStore &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buySomething</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查以确定0.001以太发送出去来运行函数:</span></span><br><span class="line">    <span class="built_in">require</span>(msg.value == <span class="number">0.001</span> ether);</span><br><span class="line">    <span class="comment">// 如果为真，一些用来向函数调用者发送数字内容的逻辑</span></span><br><span class="line">    transferThing(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>msg.value</code> 可以查看<code>msg.sender</code> 向合约发送了多少以太的方法，另外 <code>ether</code> 是一个内置单位。</p><p>这里发生的事是，一些人会从 web3.js 调用这个函数 (从DApp的前端)， 像这样 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 `OnlineStore` 在以太坊上指向你的合约:</span></span><br><span class="line">OnlineStore.buySomething().send(<span class="keyword">from</span>: web3.eth.defaultAccount, <span class="attr">value</span>: web3.utils.toWei(<span class="number">0.001</span>))</span><br></pre></td></tr></table></figure><p>注意这个 <code>value</code> 字段， JavaScript 调用来指定发送多少(0.001)<code>以太</code>。如果把事务想象成一个信封，你发送到函数的参数就是信的内容。 添加一个 <code>value</code> 很像在信封里面放钱 —— 信件内容和钱同时发送给了接收者。</p><blockquote><p>注意： 如果一个函数没标记为<code>payable</code>， 而你尝试利用上面的方法发送以太，函数将拒绝你的事务。</p></blockquote><h1 id="第2章-提现"><a href="#第2章-提现" class="headerlink" title="第2章: 提现"></a>第2章: 提现</h1><p>在你发送以太之后，它将被存储进该合约的以太坊账户中， 并冻结在哪里 —— 除非你添加一个函数来从合约中把以太提现。</p><p>你可以写一个函数来从合约中提现以太，类似这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract GetPaid is Ownable &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    owner.transfer(<span class="keyword">this</span>.balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们使用 <code>Ownable</code> 合约中的 <code>owner</code> 和 <code>onlyOwner</code>，假定它已经被引入了。</p><p>你可以通过 <code>transfer</code> 函数向一个地址发送以太， 然后 <code>this.balance</code> 将返回当前合约存储了多少以太。 所以如果100个用户每人向我们支付1以太， <code>this.balance</code> 将是100以太。</p><p>你可以通过 <code>transfer</code> 向任何以太坊地址付钱。 比如，你可以有一个函数在 <code>msg.sender</code> 超额付款的时候给他们退钱：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint itemFee = <span class="number">0.001</span> ether;</span><br><span class="line">msg.sender.transfer(msg.value - itemFee);</span><br></pre></td></tr></table></figure><p>或者在一个有买家和卖家的合约中， 你可以把卖家的地址存储起来， 当有人买了它的东西的时候，把买家支付的钱发送给它 <code>seller.transfer(msg.value)</code>。</p><p>有很多例子来展示什么让以太坊编程如此之酷 —— 你可以拥有一个不被任何人控制的去中心化市场。</p><h1 id="第3章-僵尸战斗"><a href="#第3章-僵尸战斗" class="headerlink" title="第3章: 僵尸战斗"></a>第3章: 僵尸战斗</h1><h1 id="第4章-随机数"><a href="#第4章-随机数" class="headerlink" title="第4章: 随机数"></a>第4章: 随机数</h1><p>优秀的游戏都需要一些随机元素，那么我们在 Solidity 里如何生成随机数呢？</p><p>真正的答案是你不能，或者最起码，你无法安全地做到这一点。</p><h2 id="用-keccak256-来制造随机数。"><a href="#用-keccak256-来制造随机数。" class="headerlink" title="用 keccak256 来制造随机数。"></a>用 <code>keccak256</code> 来制造随机数。</h2><p><strong>SHA-3</strong>第三代安全散列算法(Secure Hash Algorithm 3)，之前名为<strong>Keccak</strong>（念作<a href="https://zh.wikipedia.org/wiki/Help:英語國際音標">/ˈkɛtʃæk/</a>或<a href="https://zh.wikipedia.org/wiki/Help:英語國際音標">/kɛtʃɑːk/</a>)）算法.</p><p>Solidity 中最好的随机数生成器是 <code>keccak256</code> 哈希函数.</p><p>我们可以这样来生成一些随机数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个0到100的随机数:</span></span><br><span class="line"><span class="built_in">uint</span> randNonce = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">uint</span> random = <span class="built_in">uint</span>(keccak256(now, msg.sender, randNonce)) % <span class="number">100</span>;</span><br><span class="line">randNonce++;</span><br><span class="line"><span class="built_in">uint</span> random2 = <span class="built_in">uint</span>(keccak256(now, msg.sender, randNonce)) % <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>这个方法首先拿到 <code>now</code> 的时间戳、 <code>msg.sender</code>、 以及一个自增数 <code>nonce</code> （一个仅会被使用一次的数，这样我们就不会对相同的输入值调用一次以上哈希函数了）。</p><p>然后利用 <code>keccak</code> 把输入的值转变为一个哈希值, 再将哈希值转换为 <code>uint</code>, 然后利用 <code>% 100</code> 来取最后两位, 就生成了一个0到100之间随机数了。</p><h3 id="这个方法很容易被不诚实的节点攻击"><a href="#这个方法很容易被不诚实的节点攻击" class="headerlink" title="这个方法很容易被不诚实的节点攻击"></a>这个方法很容易被不诚实的节点攻击</h3><p>在以太坊上, 当你在和一个合约上调用函数的时候, 你会把它广播给一个节点或者在网络上的 <strong><em>transaction\</em></strong> 节点们。 网络上的节点将收集很多事务, 试着成为第一个解决计算密集型数学问题的人，作为“工作证明”，然后将“工作证明”(Proof of Work, PoW)和事务一起作为一个 <strong><em>block\</em></strong> 发布在网络上。</p><p>一旦一个节点解决了一个PoW, 其他节点就会停止尝试解决这个 PoW, 并验证其他节点的事务列表是有效的，然后接受这个节点转而尝试解决下一个节点。</p><p><strong>这就让我们的随机数函数变得可利用了</strong></p><p>我们假设我们有一个硬币翻转合约——正面你赢双倍钱，反面你输掉所有的钱。假如它使用上面的方法来决定是正面还是反面 (<code>random &gt;= 50</code> 算正面, <code>random &lt; 50</code> 算反面)。</p><p>如果我正运行一个节点，我可以 <strong>只对我自己的节点</strong> 发布一个事务，且不分享它。 我可以运行硬币翻转方法来偷窥我的输赢 — 如果我输了，我就不把这个事务包含进我要解决的下一个区块中去。我可以一直运行这个方法，直到我赢得了硬币翻转并解决了下一个区块，然后获利。</p><h2 id="所以我们该如何在以太坊上安全地生成随机数呢"><a href="#所以我们该如何在以太坊上安全地生成随机数呢" class="headerlink" title="所以我们该如何在以太坊上安全地生成随机数呢"></a>所以我们该如何在以太坊上安全地生成随机数呢</h2><p>因为区块链的全部内容对所有参与者来说是透明的， 这就让这个问题变得很难，它的解决方法不在本课程讨论范围，你可以阅读 <a href="https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract">这个 StackOverflow 上的讨论</a> 来获得一些主意。 一个方法是利用 <strong><em>oracle\</em></strong> 来访问以太坊区块链之外的随机数函数。</p><p>因为网络上成千上万的以太坊节点都在竞争解决下一个区块，我能成功解决下一个区块的几率非常之低。 这将花费我们巨大的计算资源来开发这个获利方法 — 但是如果奖励异常地高(比如我可以在硬币翻转函数中赢得 1个亿)， 那就很值得去攻击了。</p><p>所以尽管这个方法在以太坊上不安全，在实际中，除非我们的随机函数有一大笔钱在上面，你游戏的用户一般是没有足够的资源去攻击的。</p><h1 id="第5章-僵尸对战"><a href="#第5章-僵尸对战" class="headerlink" title="第5章: 僵尸对战"></a>第5章: 僵尸对战</h1><h1 id="第6章-重构通用逻辑"><a href="#第6章-重构通用逻辑" class="headerlink" title="第6章: 重构通用逻辑"></a>第6章: 重构通用逻辑</h1><h1 id="第7章-更多重构"><a href="#第7章-更多重构" class="headerlink" title="第7章: 更多重构"></a>第7章: 更多重构</h1><h1 id="第8章-回到攻击！"><a href="#第8章-回到攻击！" class="headerlink" title="第8章: 回到攻击！"></a>第8章: 回到攻击！</h1><h1 id="第9章-僵尸的输赢"><a href="#第9章-僵尸的输赢" class="headerlink" title="第9章: 僵尸的输赢"></a>第9章: 僵尸的输赢</h1><p>对我们的僵尸游戏来说，我们将要追踪我们的僵尸输赢了多少场。有了这个我们可以在游戏里维护一个 “僵尸排行榜”。</p><p>有多种方法在我们的DApp里面保存一个数值 — 作为一个单独的映射，作为一个“排行榜”结构体，或者保存在 <code>Zombie</code> 结构体内。</p><h1 id="第10章-僵尸胜利了-😄"><a href="#第10章-僵尸胜利了-😄" class="headerlink" title="第10章: 僵尸胜利了 😄"></a>第10章: 僵尸胜利了 😄</h1><h1 id="第11章-僵尸失败-😞"><a href="#第11章-僵尸失败-😞" class="headerlink" title="第11章: 僵尸失败 😞"></a>第11章: 僵尸失败 😞</h1><p>在我们的游戏中，僵尸输了后并不会降级 —— 只是简单地给 <code>lossCount</code> 加一，并触发冷却，等待一天后才能再次参战。</p><p>实现这个逻辑，我们需要一个 <code>else</code> 语句。</p><p><code>else</code> 语句和 JavaScript 以及很多其他语言的 else 语句一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zombieCoins[msg.sender] &gt; <span class="number">100000000</span>) &#123;</span><br><span class="line">  <span class="comment">// 你好有钱!!!</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 我们需要更多的僵尸币...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h1><h1 id="第1章-以太坊上的代币"><a href="#第1章-以太坊上的代币" class="headerlink" title="第1章: 以太坊上的代币"></a>第1章: 以太坊上的代币</h1><p>让我们来聊聊 <strong><em>代币</em></strong>.(tokens)</p><p>如果你对以太坊的世界有一些了解，你很可能听过人们聊到代币——尤其是 <strong><em>ERC20 代币\</em></strong>.</p><p>A <strong><em>token\</em></strong> on Ethereum is basically just a smart contract that follows some common rules — namely it implements a standard set of functions that all other token contracts share, such as <code>transferFrom(address _from, address _to, uint256 _tokenId)</code> and <code>balanceOf(address _owner)</code>.</p><p>一个代币就是一个智能合约。</p><p>一个 <strong><em>代币</em></strong> 在以太坊基本上就是一个遵循一些共同规则的智能合约——即它实现了所有其他代币合约共享的一组标准函数，例如</p><p><code>transfer(address _to, uint256 _value)</code> 和 <code>balanceOf(address _owner)</code>.</p><p>在智能合约内部，通常有一个映射， <code>mapping(address =&gt; uint256) balances</code>，用于追踪每个地址还有多少余额。</p><p>所以基本上一个代币只是一个追踪谁拥有多少该代币的合约，和一些可以让那些用户将他们的代币转移到其他地址的函数。</p><h3 id="它为什么重要呢？"><a href="#它为什么重要呢？" class="headerlink" title="它为什么重要呢？"></a>它为什么重要呢？</h3><p>由于所有 ERC20 代币共享具有相同名称的同一组函数，它们都可以以相同的方式进行交互。</p><p>这意味着如果你构建的应用程序能够与一个 ERC20 代币进行交互，那么它就也能够与任何 ERC20 代币进行交互。 这样一来，将来你就可以轻松地将更多的代币添加到你的应用中，而无需进行自定义编码。 你可以简单地插入新的代币合约地址，然后哗啦，你的应用程序有另一个它可以使用的代币了。</p><p>其中一个例子就是交易所。 当交易所添加一个新的 ERC20 代币时，实际上它只需要添加与之对话的另一个智能合约。 用户可以让那个合约将代币发送到交易所的钱包地址，然后交易所可以让合约在用户要求取款时将代币发送回给他们。</p><p>交易所只需要实现这种转移逻辑一次，然后当它想要添加一个新的 ERC20 代币时，只需将新的合约地址添加到它的数据库即可。</p><h3 id="其他代币标准"><a href="#其他代币标准" class="headerlink" title="其他代币标准"></a>其他代币标准</h3><p>对于像货币一样的代币来说，ERC20 代币非常酷。 但是要在我们僵尸游戏中代表僵尸就并不是特别有用。</p><p>首先，僵尸不像货币可以分割 —— 我可以发给你 0.237 以太，但是转移给你 0.237 的僵尸听起来就有些搞笑。</p><p>其次，并不是所有僵尸都是平等的。 你的2级僵尸”<strong>Steve</strong>“完全不能等同于我732级的僵尸”<strong>H4XF13LD MORRIS 💯💯😎💯💯</strong>“。（你差得远呢，<em>Steve</em>）。</p><p>有另一个代币标准更适合如 CryptoZombies 这样的加密收藏品——它们被称为<strong><em>ERC721 代币.\</em></strong></p><p><strong><em>ERC721 代币\</em></strong>是<strong>不</strong>能互换的，因为每个代币都被认为是唯一且不可分割的。 你只能以整个单位交易它们，并且每个单位都有唯一的 ID。 这些特性正好让我们的僵尸可以用来交易。</p><blockquote><p><em>请注意，使用像 ERC721 这样的标准的优势就是，我们不必在我们的合约中实现拍卖或托管逻辑，这决定了玩家能够如何交易／出售我们的僵尸。 如果我们符合规范，其他人可以为加密可交易的 ERC721 资产搭建一个交易所平台，我们的 ERC721 僵尸将可以在该平台上使用。 所以使用代币标准相较于使用你自己的交易逻辑有明显的好处。</em></p></blockquote><h1 id="第2章-ERC721-标准-多重继承"><a href="#第2章-ERC721-标准-多重继承" class="headerlink" title="第2章: ERC721 标准, 多重继承"></a>第2章: ERC721 标准, 多重继承</h1><p>让我们来看一看 ERC721 标准：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract ERC721 &#123;</span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _owner</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256 _balance</span>);</span></span><br><span class="line"><span class="function">  <span class="title">function</span> <span class="title">ownerOf</span>(<span class="params">uint256 _tokenId</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address _owner</span>);</span></span><br><span class="line"><span class="function">  <span class="title">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _tokenId</span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">  <span class="title">function</span> <span class="title">approve</span>(<span class="params">address _to, uint256 _tokenId</span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">  <span class="title">function</span> <span class="title">takeOwnership</span>(<span class="params">uint256 _tokenId</span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>这是我们需要实现的方法列表，我们将在接下来的章节中逐个学习。</p><blockquote><p><em>注意： ERC721目前是一个</em> <em>草稿**，还没有正式商定的实现。在本教程中，我们使用的是 OpenZeppelin 库中的当前版本，但在未来正式发布之前它可能会有更改。 所以把这</em> <strong>一个</strong> <em>可能的实现当作考虑，但不要把它作为 ERC721 代币的官方标准。</em></p></blockquote><h3 id="实现一个代币合约"><a href="#实现一个代币合约" class="headerlink" title="实现一个代币合约"></a>实现一个代币合约</h3><p>在实现一个代币合约的时候，我们首先要做的是将接口复制到它自己的 Solidity 文件并导入它，<code>import &quot;./erc721.sol&quot;;</code>。 接着，让我们的合约继承它，然后我们用一个函数定义来重写每个方法。</p><p>幸运的是在Solidity，你的合约可以继承自多个合约，参考如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract SatoshiNakamoto <span class="keyword">is</span> NickSzabo, HalFinney &#123;</span><br><span class="line">  <span class="comment">// 啧啧啧，宇宙的奥秘泄露了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如你所见，当使用多重继承的时候，你只需要用逗号 <code>,</code> 来隔开几个你想要继承的合约。在上面的例子中，我们的合约继承自 <code>NickSzabo</code> 和 <code>HalFinney</code>。</p><h1 id="第3章-balanceOf-和-ownerOf"><a href="#第3章-balanceOf-和-ownerOf" class="headerlink" title="第3章: balanceOf 和 ownerOf"></a>第3章: balanceOf 和 ownerOf</h1><h3 id="balanceOf"><a href="#balanceOf" class="headerlink" title="balanceOf"></a><code>balanceOf</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _owner</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256 _balance</span>);</span></span><br></pre></td></tr></table></figure><p>这个函数只需要一个传入 <code>address</code> 参数，然后返回这个 <code>address</code> 拥有多少代币。</p><p>在我们的例子中，我们的“代币”是僵尸。你还记得在我们 DApp 的哪里存储了一个主人拥有多少只僵尸吗？</p><h3 id="ownerOf"><a href="#ownerOf" class="headerlink" title="ownerOf"></a><code>ownerOf</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ownerOf</span>(<span class="params">uint256 _tokenId</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address _owner</span>);</span></span><br></pre></td></tr></table></figure><p>这个函数需要传入一个代币 ID 作为参数 (我们的情况就是一个僵尸 ID)，然后返回该代币拥有者的 <code>address</code>。</p><p>同样的，因为在我们的 DApp 里已经有一个 <code>mapping</code> (映射) 存储了这个信息，所以对我们来说这个实现非常直接清晰。我们可以只用一行 <code>return</code> 语句来实现这个函数。</p><blockquote><p>注意：要记得， <code>uint256</code> 等同于<code>uint</code>。我们从课程的开始一直在代码中使用 <code>uint</code>，但从现在开始我们将在这里用 <code>uint256</code>，因为我们直接从规范中复制粘贴。</p></blockquote><h1 id="第4章-重构"><a href="#第4章-重构" class="headerlink" title="第4章: 重构"></a>第4章: 重构</h1><p>如果你尝试编译这段代码，编译器会给你一个错误说你不能有相同名称的修饰符和函数。</p><p>所以我们应该把在 <code>ZombieOwnership</code> 里的函数名称改成别的吗？</p><p>不，我们不能那样做！！！要记得，我们正在用 ERC721 代币标准，意味着其他合约将期望我们的合约以这些确切的名称来定义函数。这就是这些标准实用的原因——如果另一个合约知道我们的合约符合 ERC721 标准，它可以直接与我们交互，而无需了解任何关于我们内部如何实现的细节。</p><p>所以，那意味着我们将必须重构我们第4课中的代码，将 <code>modifier</code> 的名称换成别的。</p><h1 id="第5章-ERC721-Transfer-Logic"><a href="#第5章-ERC721-Transfer-Logic" class="headerlink" title="第5章: ERC721: Transfer Logic"></a>第5章: ERC721: Transfer Logic</h1><p>注意 ERC721 规范有两种不同的方法来转移代币：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">transfer</span>(address _to, uint256 _tokenId) <span class="keyword">public</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> approve(address _to, uint256 _tokenId) <span class="keyword">public</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span></span> takeOwnership(uint256 _tokenId) <span class="keyword">public</span>;</span><br></pre></td></tr></table></figure><ol><li>第一种方法是代币的拥有者调用<code>transfer</code> 方法，传入他想转移到的 <code>address</code> 和他想转移的代币的 <code>_tokenId</code>。</li><li>第二种方法是代币拥有者首先调用 <code>approve</code>，然后传入与以上相同的参数。接着，该合约会存储谁被允许提取代币，通常存储到一个 <code>mapping (uint256 =&gt; address)</code> 里。然后，当有人调用 <code>takeOwnership</code> 时，合约会检查 <code>msg.sender</code> 是否得到拥有者的批准来提取代币，如果是，则将代币转移给他。</li></ol><p>你注意到了吗，<code>transfer</code> 和 <code>takeOwnership</code> 都将包含相同的转移逻辑，只是以相反的顺序。 （一种情况是代币的发送者调用函数；另一种情况是代币的接收者调用它）。</p><h1 id="第7章-ERC721-Approval"><a href="#第7章-ERC721-Approval" class="headerlink" title="第7章: ERC721: Approval"></a>第7章: ERC721: Approval</h1><p>记住，使用 <code>approve</code> 或者 <code>takeOwnership</code> 的时候，转移有2个步骤：</p><ol><li>你，作为所有者，用新主人的 <code>address</code> 和你希望他获取的 <code>_tokenId</code> 来调用 <code>approve</code></li><li>新主人用 <code>_tokenId</code> 来调用 <code>takeOwnership</code>，合约会检查确保他获得了批准，然后把代币转移给他。</li></ol><p>因为这发生在2个函数的调用中，所以在函数调用之间，我们需要一个数据结构来存储什么人被批准获取什么。</p><h1 id="第8章-ERC721-takeOwnership"><a href="#第8章-ERC721-takeOwnership" class="headerlink" title="第8章: ERC721: takeOwnership"></a>第8章: ERC721: takeOwnership</h1><p>最后一个函数 <code>takeOwnership</code>， 应该只是简单地检查以确保 <code>msg.sender</code> 已经被批准来提取这个代币或者僵尸。若确认，就调用 <code>_transfer</code>；</p><h1 id="第9章-预防溢出"><a href="#第9章-预防溢出" class="headerlink" title="第9章: 预防溢出"></a>第9章: 预防溢出</h1><p>不过要记住那只是最简单的实现。还有很多的特性我们也许想加入到我们的实现中来，比如一些额外的检查，来确保用户不会不小心把他们的僵尸转移给<code>0</code> 地址（这被称作 “烧币”, 基本上就是把代币转移到一个谁也没有私钥的地址，让这个代币永远也无法恢复）。 或者在 DApp 中加入一些基本的拍卖逻辑。（你能想出一些实现的方法么？）</p><p>但是为了让我们的课程不至于离题太远，所以我们只专注于一些基础实现。如果你想学习一些更深层次的实现，可以在这个教程结束后，去看看 OpenZeppelin 的 ERC721 合约。</p><h3 id="合约安全增强-溢出和下溢"><a href="#合约安全增强-溢出和下溢" class="headerlink" title="合约安全增强: 溢出和下溢"></a>合约安全增强: 溢出和下溢</h3><p>我们将来学习你在编写智能合约的时候需要注意的一个主要的安全特性：防止溢出和下溢。</p><p>什么是 <strong><em>溢出</em></strong> (<strong><em>overflow\</em></strong>)?</p><p>假设我们有一个 <code>uint8</code>, 只能存储8 bit数据。这意味着我们能存储的最大数字就是二进制 <code>11111111</code> (或者说十进制的 2^8 - 1 = 255).</p><p>来看看下面的代码。最后 <code>number</code> 将会是什么值？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uint</span>8 number = <span class="number">255</span>;</span><br><span class="line">number++;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们导致了溢出 — 虽然我们加了1， 但是 <code>number</code> 出乎意料地等于 <code>0</code>了。 (如果你给二进制 <code>11111111</code> 加1, 它将被重置为 <code>00000000</code>，就像钟表从 <code>23:59</code> 走向 <code>00:00</code>)。</p><p>下溢(<code>underflow</code>)也类似，如果你从一个等于 <code>0</code> 的 <code>uint8</code> 减去 <code>1</code>, 它将变成 <code>255</code> (因为 <code>uint</code> 是无符号的，其不能等于负数)。</p><p>虽然我们在这里不使用 <code>uint8</code>，而且每次给一个 <code>uint256</code> 加 <code>1</code> 也不太可能溢出 (2^256 真的是一个很大的数了)，在我们的合约中添加一些保护机制依然是非常有必要的，以防我们的 DApp 以后出现什么异常情况。</p><h3 id="使用-SafeMath"><a href="#使用-SafeMath" class="headerlink" title="使用 SafeMath"></a>使用 SafeMath</h3><p>为了防止这些情况，OpenZeppelin 建立了一个叫做 SafeMath 的 <strong><em>库</em></strong>(<strong><em>library\</em></strong>)，默认情况下可以防止这些问题。</p><p>不过在我们使用之前…… 什么叫做库?</p><p>一个<strong><em>库</em></strong> 是 Solidity 中一种特殊的合约。其中一个有用的功能是给原始数据类型增加一些方法。</p><p>比如，使用 SafeMath 库的时候，我们将使用 <code>using SafeMath for uint256</code> 这样的语法。 SafeMath 库有四个方法 — <code>add</code>， <code>sub</code>， <code>mul</code>， 以及 <code>div</code>。现在我们可以这样来让 <code>uint256</code> 调用这些方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using SafeMath <span class="keyword">for</span> uint256;</span><br><span class="line"></span><br><span class="line">uint256 a = <span class="number">5</span>;</span><br><span class="line">uint256 b = a.add(<span class="number">3</span>); <span class="comment">// 5 + 3 = 8</span></span><br><span class="line">uint256 c = a.mul(<span class="number">2</span>); <span class="comment">// 5 * 2 = 10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity的&lt;a href=&quot;https://cryptozombies.io/zh/course&quot;&gt;官方教程&lt;/a&gt;笔记：advanced。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链" scheme="https://f7ed.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="blockchain" scheme="https://f7ed.com/tags/blockchain/"/>
    
      <category term="solidity" scheme="https://f7ed.com/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>「区块链」：Solidity-basic</title>
    <link href="https://f7ed.com/2020/11/03/solidity-basic/"/>
    <id>https://f7ed.com/2020/11/03/solidity-basic/</id>
    <published>2020-11-02T16:00:00.000Z</published>
    <updated>2021-05-22T02:30:41.268Z</updated>
    
    <content type="html"><![CDATA[<p>Solidity的<a href="https://cryptozombies.io/zh/course">官方教程</a>笔记：basic。 </p><a id="more"></a><h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><h2 id="第2章-合约"><a href="#第2章-合约" class="headerlink" title="第2章: 合约"></a>第2章: 合约</h2><p>从最基本的开始入手:</p><p>Solidity 的代码都包裹在<strong>合约</strong>里面. 一份<code>合约</code>就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点.</p><p>一份名为 <code>HelloWorld</code> 的空合约如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">contract</span> <span class="selector-tag">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="版本指令"><a href="#版本指令" class="headerlink" title="版本指令"></a>版本指令</h3><p>所有的 Solidity 源码都必须冠以 “version pragma” — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。</p><p>例如: <code>pragma solidity ^0.4.19;</code> (当前 Solidity 的最新版本是 0.4.19).</p><p><strong>要有分号！</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.19</span>;</span><br><span class="line">contract HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第3章-状态变量和整数"><a href="#第3章-状态变量和整数" class="headerlink" title="第3章: 状态变量和整数"></a>第3章: 状态变量和整数</h2><p><strong>状态变量</strong>是被永久地保存在合约中。也就是说它们被写入以太币区块链中. 想象成写入一个数据库。</p><h3 id="无符号整数-uint"><a href="#无符号整数-uint" class="headerlink" title="无符号整数: uint"></a>无符号整数: <code>uint</code></h3><p><code>uint</code> 无符号数据类型， 指<strong>其值不能是负数</strong>，对于有符号的整数存在名为 <code>int</code> 的数据类型。</p><p><em>注: Solidity中，</em> <code>uint</code> <em>实际上是</em> <code>uint256</code><em>代名词， 一个256位的无符号整数。你也可以定义位数少的uints —</em> <code>uint8</code><em>，</em> <code>uint16</code><em>，</em> <code>uint32</code><em>， 等…… 但一般来讲你愿意使用简单的</em> <code>uint</code><em>， 除非在某些特殊情况下，这我们后面会讲。</em></p><h2 id="第4章-数学运算"><a href="#第4章-数学运算" class="headerlink" title="第4章: 数学运算"></a>第4章: 数学运算</h2><p>在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同:</p><ul><li>加法: <code>x + y</code></li><li>减法: <code>x - y</code>,</li><li>乘法: <code>x * y</code></li><li>除法: <code>x / y</code></li><li>取模 / 求余: <code>x % y</code> <em>(例如, <code>13 % 5</code> 余 <code>3</code>, 因为13除以5，余3)</em></li></ul><p>Solidity 还支持 <strong><em>乘方操作\</em></strong> (如：x 的 y次方） </p><p>如： 5 ** 2 = 25</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint x &#x3D; 5 ** 2; &#x2F;&#x2F; equal to 5^2 &#x3D; 25</span><br></pre></td></tr></table></figure><h2 id="第5章-结构体"><a href="#第5章-结构体" class="headerlink" title="第5章: 结构体"></a>第5章: 结构体</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">  uint age;</span><br><span class="line">  string name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第6章-数组"><a href="#第6章-数组" class="headerlink" title="第6章: 数组"></a>第6章: 数组</h2><p>如果你想建立一个集合，可以用 <strong><em>数组</em></strong>这样的数据类型. Solidity 支持两种数组: <strong><em>静态</em></strong> 数组和<strong><em>动态</em></strong> 数组:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定长度为2的静态数组:</span></span><br><span class="line">uint[<span class="number">2</span>] fixedArray;</span><br><span class="line"><span class="comment">// 固定长度为5的string类型的静态数组:</span></span><br><span class="line">string[<span class="number">5</span>] stringArray;</span><br><span class="line"><span class="comment">// 动态数组，长度不固定，可以动态添加元素:</span></span><br><span class="line">uint[] dynamicArray;</span><br></pre></td></tr></table></figure><p>记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。</p><h3 id="公共数组"><a href="#公共数组" class="headerlink" title="公共数组"></a>公共数组</h3><p>你可以定义 <code>public</code> 数组, Solidity 会自动创建 <strong>getter</strong> 方法. 语法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person[] public people;</span><br></pre></td></tr></table></figure><p>其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。</p><h2 id="第7章-定义函数"><a href="#第7章-定义函数" class="headerlink" title="第7章: 定义函数"></a>第7章: 定义函数</h2><p>在 Solidity 中函数定义的句法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eatHamburgers</span>(<span class="params">string _name, uint _amount</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：习惯上函数里的变量都是以(*<code>_</code>)开头 (但不是硬性规定) 以区别全局变量。(整个教程都会沿用这个习惯。)</p><h2 id="第8章-使用结构体和数组"><a href="#第8章-使用结构体和数组" class="headerlink" title="第8章: 使用结构体和数组"></a>第8章: 使用结构体和数组</h2><p>现在我们学习创建新的 <code>Person</code> 结构，然后把它加入到名为 <code>people</code> 的数组中.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的Person:</span></span><br><span class="line">Person satoshi = Person(<span class="number">172</span>, <span class="string">"Satoshi"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新创建的satoshi添加进people数组:</span></span><br><span class="line">people.push(satoshi);</span><br></pre></td></tr></table></figure><p>你也可以两步并一步，用一行代码更简洁:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.push(Person(<span class="number">16</span>, <span class="string">"Vitalik"</span>));</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>array.push()</code> 在数组的 <strong>尾部</strong> 加入新元素 ，所以元素在数组中的顺序就是我们添加的顺序， 如:</p></blockquote><h2 id="第9章-私有-公共函数"><a href="#第9章-私有-公共函数" class="headerlink" title="第9章: 私有 / 公共函数"></a>第9章: 私有 / 公共函数</h2><p>Solidity 定义的函数的属性默认为<code>公共</code>。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。</p><p>显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。 所以将自己的函数定义为<code>私有</code>是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为<code>公共</code>。</p><p>如何定义一个私有的函数呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[] numbers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_addToArray</span>(<span class="params">uint _number</span>) <span class="title">private</span> </span>&#123;</span><br><span class="line">  numbers.push(_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着只有我们合约中的其它函数才能够调用这个函数，给 <code>numbers</code> 数组添加新成员。</p><p>可以看到，在函数名字后面使用关键字 <code>private</code> 即可。和函数的参数类似，私有函数的名字用(<code>_</code>)起始。</p><h2 id="第10章-函数的更多属性"><a href="#第10章-函数的更多属性" class="headerlink" title="第10章: 函数的更多属性"></a>第10章: 函数的更多属性</h2><p>本章中我们将学习函数的返回值和修饰符。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>要想函数返回一个数值，按如下定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string greeting = <span class="string">"What's up dog"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> greeting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 <code>string</code>)。</p><h3 id="函数的修饰符"><a href="#函数的修饰符" class="headerlink" title="函数的修饰符"></a>函数的修饰符</h3><p>上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。</p><p>这种情况下我们可以把函数定义为 <strong>view</strong>, 意味着它只能读取数据不能更改数据:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">string</span>) </span>&#123;</span><br></pre></td></tr></table></figure><p>Solidity 还支持 <strong>pure</strong> 函数, 表明这个函数甚至都不访问应用里的数据，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_multiply</span>(<span class="params">uint a, uint b</span>) <span class="title">private</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 <strong>pure</strong>.</p><blockquote><p>注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。</p></blockquote><h2 id="第11章-Keccak256-和-类型转换"><a href="#第11章-Keccak256-和-类型转换" class="headerlink" title="第11章: Keccak256 和 类型转换"></a>第11章: Keccak256 和 类型转换</h2><p>如何让 <code>_generateRandomDna</code> 函数返回一个全(半) 随机的 <code>uint</code>?</p><p>Ethereum 内部有一个散列函数<code>keccak256</code>，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。</p><p>例子:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5</span></span><br><span class="line"><span class="selector-tag">keccak256</span>(<span class="string">"aaaab"</span>);</span><br><span class="line"><span class="comment">//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9</span></span><br><span class="line"><span class="selector-tag">keccak256</span>(<span class="string">"aaaac"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注: 在区块链中<strong><em>安全地</em></strong>产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。*</p></blockquote><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>有时你需要变换数据类型。例如:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uint</span>8 a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">uint</span> b = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:</span></span><br><span class="line"><span class="built_in">uint</span>8 c = a * b;</span><br><span class="line"><span class="comment">// 我们需要将 b 转换为 uint8:</span></span><br><span class="line"><span class="built_in">uint</span>8 c = a * <span class="built_in">uint</span>8(b);</span><br></pre></td></tr></table></figure><p>上面, <code>a * b</code> 返回类型是 <code>uint</code>, 但是当我们尝试用 <code>uint8</code> 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 <code>uint8</code>, 就可以了，编译器也不会出错。</p><h2 id="第13章-事件"><a href="#第13章-事件" class="headerlink" title="第13章: 事件"></a>第13章: 事件</h2><p><strong>事件</strong> 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</p><p>例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里建立事件</span></span><br><span class="line">event IntegersAdded(uint x, uint y, uint result);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">uint _x, uint _y</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">  uint result = _x + _y;</span><br><span class="line">  <span class="comment">//触发事件，通知app</span></span><br><span class="line">  IntegersAdded(_x, _y, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的 app 前端可以监听这个事件。JavaScript 实现如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourContract.IntegersAdded(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 干些事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>array.push()</code> 返回数组的长度类型是<code>uint</code> - 因为数组的第一个元素的索引是 0， <code>array.push() - 1</code> 将是我们加入的僵尸的索引。 <code>zombies.push() - 1</code> 就是 <code>id</code>，数据类型是 <code>uint</code>。</p><h2 id="第14章-Web3-js"><a href="#第14章-Web3-js" class="headerlink" title="第14章: Web3.js"></a>第14章: Web3.js</h2><p>以太坊有一个 JavaScript 库，名为<strong>Web3.js</strong>。</p><p>在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置Web3.js。 但是现在我们通过一段代码来了解 Web3.js 是如何和我们发布的合约交互的吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是调用合约的方式:</span></span><br><span class="line"><span class="keyword">var</span> abi = <span class="comment">/* abi是由编译器生成的 */</span></span><br><span class="line"><span class="keyword">var</span> ZombieFactoryContract = web3.eth.contract(abi)</span><br><span class="line"><span class="keyword">var</span> contractAddress = <span class="comment">/* 发布之后在以太坊上生成的合约地址 */</span></span><br><span class="line"><span class="keyword">var</span> ZombieFactory = ZombieFactoryContract.at(contractAddress)</span><br><span class="line"><span class="comment">// `ZombieFactory` 能访问公共的函数以及事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个监听文本输入的监听器:</span></span><br><span class="line">$(<span class="string">"#ourButton"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = $(<span class="string">"#nameInput"</span>).val()</span><br><span class="line">  <span class="comment">//调用合约的 `createRandomZombie` 函数:</span></span><br><span class="line">  ZombieFactory.createRandomZombie(name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 `NewZombie` 事件, 并且更新UI</span></span><br><span class="line"><span class="keyword">var</span> event = ZombieFactory.NewZombie(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span></span><br><span class="line">  generateZombie(result.zombieId, result.name, result.dna)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Zombie 的 dna, 更新图像</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateZombie</span>(<span class="params">id, name, dna</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dnaStr = <span class="built_in">String</span>(dna)</span><br><span class="line">  <span class="comment">// 如果dna少于16位,在它前面用0补上</span></span><br><span class="line">  <span class="keyword">while</span> (dnaStr.length &lt; <span class="number">16</span>)</span><br><span class="line">    dnaStr = <span class="string">"0"</span> + dnaStr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> zombieDetails = &#123;</span><br><span class="line">    <span class="comment">// 前两位数构成头部.我们可能有7种头部, 所以 % 7</span></span><br><span class="line">    <span class="comment">// 得到的数在0-6,再加上1,数的范围变成1-7</span></span><br><span class="line">    <span class="comment">// 通过这样计算：</span></span><br><span class="line">    headChoice: dnaStr.substring(<span class="number">0</span>, <span class="number">2</span>) % <span class="number">7</span> + <span class="number">1</span>，</span><br><span class="line">    <span class="comment">// 我们得到的图片名称从head1.png 到 head7.png</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的两位数构成眼睛, 眼睛变化就对11取模:</span></span><br><span class="line">    eyeChoice: dnaStr.substring(<span class="number">2</span>, <span class="number">4</span>) % <span class="number">11</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 再接下来的两位数构成衣服，衣服变化就对6取模:</span></span><br><span class="line">    shirtChoice: dnaStr.substring(<span class="number">4</span>, <span class="number">6</span>) % <span class="number">6</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//最后6位控制颜色. 用css选择器: hue-rotate来更新</span></span><br><span class="line">    <span class="comment">// 360度:</span></span><br><span class="line">    skinColorChoice: <span class="built_in">parseInt</span>(dnaStr.substring(<span class="number">6</span>, <span class="number">8</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    eyeColorChoice: <span class="built_in">parseInt</span>(dnaStr.substring(<span class="number">8</span>, <span class="number">10</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    clothesColorChoice: <span class="built_in">parseInt</span>(dnaStr.substring(<span class="number">10</span>, <span class="number">12</span>) / <span class="number">100</span> * <span class="number">360</span>),</span><br><span class="line">    zombieName: name,</span><br><span class="line">    zombieDescription: <span class="string">"A Level 1 CryptoZombie"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> zombieDetails</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的 JavaScript 所做的就是获取由<code>zombieDetails</code> 产生的数据, 并且利用浏览器里的 JavaScript 神奇功能 (我们用 Vue.js)，置换出图像以及使用CSS过滤器。在后面的课程中，你可以看到全部的代码。</p><hr><h1 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h1><h2 id="第2章-映射（Mapping）和地址（Address）"><a href="#第2章-映射（Mapping）和地址（Address）" class="headerlink" title="第2章: 映射（Mapping）和地址（Address）"></a>第2章: 映射（Mapping）和地址（Address）</h2><p>如此一来，我们需要引入2个新的数据类型：<code>mapping</code>（映射） 和 <code>address</code>（地址）。</p><h3 id="Addresses-（地址）"><a href="#Addresses-（地址）" class="headerlink" title="Addresses （地址）"></a>Addresses （地址）</h3><p>以太坊区块链由 <strong>account ** (账户)组成，你可以把它想象成银行账户。一个帐户的余额是 **<em>以太</em></strong> （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。</p><p>每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0cE446255506E92DF41614C46F1d6df9Cc969183</span></span><br></pre></td></tr></table></figure><p>现在你只需要了解<strong>地址属于特定用户（或智能合约）的</strong>。</p><h3 id="Mapping（映射）"><a href="#Mapping（映射）" class="headerlink" title="Mapping（映射）"></a>Mapping（映射）</h3><p>在第1课中，我们看到了 <strong>结构体 ** 和 **数组</strong> 。 <strong>映射</strong> 是另一种在 Solidity 中存储有组织数据的方法。</p><p>映射是这样定义的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：</span></span><br><span class="line">mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) <span class="keyword">public</span> accountBalance;</span><br><span class="line"><span class="comment">//或者可以用来通过userId 存储/查找的用户名</span></span><br><span class="line">mapping (<span class="function"><span class="params">uint</span> =&gt;</span> <span class="built_in">string</span>) userIdToName;</span><br></pre></td></tr></table></figure><p>映射本质上是存储和查找数据所用的键-值对。</p><h2 id="第3章-Msg-sender"><a href="#第3章-Msg-sender" class="headerlink" title="第3章: Msg.sender"></a>第3章: Msg.sender</h2><h3 id="msg-sender"><a href="#msg-sender" class="headerlink" title="msg.sender"></a>msg.sender</h3><p>在 Solidity 中，有一些全局变量可以被所有函数调用。 其中一个就是 <code>msg.sender</code>，它指的是当前调用者（或智能合约）的 <code>address</code>。</p><blockquote><p><em>注意：在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以</em> <code>msg.sender</code><em>总是存在的。</em></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) favoriteNumber;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMyNumber</span>(<span class="params">uint _myNumber</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 更新我们的 `favoriteNumber` 映射来将 `_myNumber`存储在 `msg.sender`名下</span></span><br><span class="line">  favoriteNumber[msg.sender] = _myNumber;</span><br><span class="line">  <span class="comment">// 存储数据至映射的方法和将数据存储在数组相似</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatIsMyNumber</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到存储在调用者地址名下的值</span></span><br><span class="line">  <span class="comment">// 若调用者还没调用 setMyNumber， 则值为 `0`</span></span><br><span class="line">  <span class="keyword">return</span> favoriteNumber[msg.sender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个小小的例子中，任何人都可以调用 <code>setMyNumber</code> 在我们的合约中存下一个 <code>uint</code> 并且与他们的地址相绑定。 然后，他们调用 <code>whatIsMyNumber</code> 就会返回他们存储的 <code>uint</code>。</p><p>使用 <code>msg.sender</code> 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。</p><p>跟在 JavaScript 中一样， 在 Solidity 中你也可以用 <code>++</code> 使 <code>uint</code> 递增。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint number = <span class="number">0</span>;</span><br><span class="line">number++;</span><br><span class="line"><span class="comment">// `number` 现在是 `1`了</span></span><br></pre></td></tr></table></figure><h2 id="第4章-Require"><a href="#第4章-Require" class="headerlink" title="第4章: Require"></a>第4章: Require</h2><p> <code>require</code>使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHiToVitalik</span>(<span class="params">string _name</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 比较 _name 是否等于 "Vitalik". 如果不成立，抛出异常并终止程序</span></span><br><span class="line">  <span class="comment">// (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较</span></span><br><span class="line">  <span class="comment">// 两字符串的 keccak256 哈希值来进行判断)</span></span><br><span class="line">  <span class="built_in">require</span>(keccak256(_name) == keccak256(<span class="string">"Vitalik"</span>));</span><br><span class="line">  <span class="comment">// 如果返回 true, 运行如下语句</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hi!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你这样调用函数 <code>sayHiToVitalik（“Vitalik”）</code> ,它会返回“Hi！”。而如果调用的时候使用了其他参数，它则会抛出错误并停止执行。</p><p>因此，在调用一个函数之前，用 <code>require</code> 验证前置条件是非常有必要的。</p><h2 id="第5章-继承（Inheritance）"><a href="#第5章-继承（Inheritance）" class="headerlink" title="第5章: 继承（Inheritance）"></a>第5章: 继承（Inheritance）</h2><p> 当代码过于冗长的时候，最好将代码和逻辑分拆到多个不同的合约中，以便于管理。</p><p>有个让 Solidity 的代码易于管理的功能，就是合约 <strong>inheritance</strong> (继承)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Doge &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">catchphrase</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"So Wow CryptoDoge"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BabyDoge is Doge &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">anotherCatchphrase</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Such Moon BabyDoge"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>BabyDoge</code> 是从 <code>Doge</code> 那里 <strong>inherits</strong> （继承)过来的。 这意味着当你编译和部署了 <code>BabyDoge</code>，它将可以访问 <code>catchphrase()</code> 和 <code>anotherCatchphrase()</code>和其他我们在 <code>Doge</code> 中定义的其他公共函数。</p><p>这可以用于逻辑继承（比如表达子类的时候，<code>Cat</code> 是一种 <code>Animal</code>）。 但也可以简单地将类似的逻辑组合到不同的合约中以组织代码。</p><h2 id="第6章-引入（Import）"><a href="#第6章-引入（Import）" class="headerlink" title="第6章: 引入（Import）"></a>第6章: 引入（Import）</h2><p>在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 <code>import</code> 语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./someothercontract.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract newContract is SomeOtherContract &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们在合约（contract）目录下有一个名为 <code>someothercontract.sol</code> 的文件（ <code>./</code> 就是同一目录的意思），它就会被编译器导入。</p><h2 id="第7章-Storage与Memory"><a href="#第7章-Storage与Memory" class="headerlink" title="第7章: Storage与Memory"></a>第7章: Storage与Memory</h2><p>在 Solidity 中，有两个地方可以存储变量 —— <code>storage</code> 或 <code>memory</code>。</p><p><strong>Storage</strong> 变量是指永久存储在区块链中的变量。 <strong>Memory</strong> 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。</p><p>大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</p><p>然而也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 <strong>结构体</strong> 和 <strong>数组</strong> 时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">contract SandwichFactory &#123;</span><br><span class="line">  struct Sandwich &#123;</span><br><span class="line">    string name;</span><br><span class="line">    string status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Sandwich[] sandwiches;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">eatSandwich</span>(<span class="params">uint _index</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Sandwich mySandwich = sandwiches[_index];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ^ 看上去很直接，不过 Solidity 将会给出警告</span></span><br><span class="line">    <span class="comment">// 告诉你应该明确在这里定义 `storage` 或者 `memory`。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所以你应该明确定义 `storage`:把他当指针</span></span><br><span class="line">    Sandwich storage mySandwich = sandwiches[_index];</span><br><span class="line">    <span class="comment">// ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针</span></span><br><span class="line">    <span class="comment">// 在存储里，另外...</span></span><br><span class="line">    mySandwich.status = <span class="string">"Eaten!"</span>;</span><br><span class="line">    <span class="comment">// ...这将永久把 `sandwiches[_index]` 变为区块链上的存储</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你只想要一个副本，可以使用`memory`:在内存的临时副本</span></span><br><span class="line">    Sandwich memory anotherSandwich = sandwiches[_index + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了</span></span><br><span class="line">    <span class="comment">// 另外</span></span><br><span class="line">    anotherSandwich.status = <span class="string">"Eaten!"</span>;</span><br><span class="line">    <span class="comment">// ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响</span></span><br><span class="line">    <span class="comment">// 不过你可以这样做:</span></span><br><span class="line">    sandwiches[_index + <span class="number">1</span>] = anotherSandwich;</span><br><span class="line">    <span class="comment">// ...如果你想把副本的改动保存回区块链存储</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你不得不使用到这些关键字的时候，Solidity 编译器会发警示提醒你的。</p><h2 id="第9章-更多关于函数可见性"><a href="#第9章-更多关于函数可见性" class="headerlink" title="第9章: 更多关于函数可见性"></a>第9章: 更多关于函数可见性</h2><p>错误在于，我们尝试从 <code>ZombieFeeding</code> 中调用 <code>_createZombie</code> 函数，但 <code>_createZombie</code> 却是 <code>ZombieFactory</code> 的 <code>private</code> （私有）函数。这意味着任何继承自 <code>ZombieFactory</code> 的子合约都不能访问它。</p><h3 id="internal-和-external"><a href="#internal-和-external" class="headerlink" title="internal 和 external"></a>internal 和 external</h3><p>除 <code>public</code> 和 <code>private</code> 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：<code>internal</code>（内部） 和 <code>external</code>（外部）。</p><p><code>internal</code> 和 <code>private</code> 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。而private只允许合约内部函数访问。</p><p><code>external</code> 与<code>public</code> 类似，只不过这些函数只能在合约之外调用，它们不能被合约内的其他函数调用。稍后我们将讨论什么时候使用 <code>external</code> 和 <code>public</code>。而public允许合约内和合约外的函数调用。</p><p>声明函数 <code>internal</code> 或 <code>external</code> 类型的语法，与声明 <code>private</code> 和 <code>public</code>类 型相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract Sandwich &#123;</span><br><span class="line">  uint private sandwichesEaten = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">eat</span>(<span class="params"></span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">    sandwichesEaten++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BLT is Sandwich &#123;</span><br><span class="line">  uint private baconSandwichesEaten = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">eatWithBacon</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">    baconSandwichesEaten++;</span><br><span class="line">    <span class="comment">// 因为eat() 是internal 的，所以我们能在这里调用</span></span><br><span class="line">    eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与其他合约的交互"><a href="#与其他合约的交互" class="headerlink" title="与其他合约的交互"></a>与其他合约的交互</h3><p>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 <strong>interface</strong> (接口)。</p><p>先举一个简单的栗子。 假设在区块链上有这么一个合约：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract LuckyNumber &#123;</span><br><span class="line">  mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) numbers;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setNum</span>(<span class="params">uint _num</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    numbers[msg.sender] = _num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params">address _myAddress</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers[_myAddress];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。</p><p>现在假设我们有一个外部合约，使用 <code>getNum</code> 函数可读取其中的数据。</p><p>首先，我们定义 <code>LuckyNumber</code> 合约的 <strong>interface</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params">address _myAddress</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p><p>首先，我们只声明了要与之交互的函数 （在本例中为 <code>getNum</code> ），在其中我们没有使用到任何其他的函数或状态变量。</p><p>其次，我们并没有使用大括号（<code>{</code> 和 <code>}</code>）定义函数体，我们单单用分号（<code>;</code>）结束了函数声明。这使它看起来像一个合约框架。</p><p>编译器就是靠这些特征认出它是一个接口的。</p><p>在我们的 app 代码中使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。</p><p>我们已经为你查看过了 CryptoKitties 的源代码，并且找到了一个名为 <code>getKitty</code>的函数，它返回所有的加密猫的数据，包括它的“基因”（我们的僵尸游戏要用它生成新的僵尸）。</p><p>该函数如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKitty</span>(<span class="params">uint256 _id</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    bool isGestating,</span></span></span><br><span class="line"><span class="function"><span class="params">    bool isReady,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 cooldownIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 nextActionAt,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 siringWithId,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 birthTime,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 matronId,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 sireId,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 generation,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint256 genes</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    Kitty storage kit = kitties[_id];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if this variable is 0 then it's not gestating</span></span><br><span class="line">    isGestating = (kit.siringWithId != <span class="number">0</span>);</span><br><span class="line">    isReady = (kit.cooldownEndBlock &lt;= block.number);</span><br><span class="line">    cooldownIndex = uint256(kit.cooldownIndex);</span><br><span class="line">    nextActionAt = uint256(kit.cooldownEndBlock);</span><br><span class="line">    siringWithId = uint256(kit.siringWithId);</span><br><span class="line">    birthTime = uint256(kit.birthTime);</span><br><span class="line">    matronId = uint256(kit.matronId);</span><br><span class="line">    sireId = uint256(kit.sireId);</span><br><span class="line">    generation = uint256(kit.generation);</span><br><span class="line">    genes = kit.genes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数看起来跟我们习惯的函数不太一样。 它竟然返回了…一堆不同的值！ 在 Solidity中，可以让一个函数返回多个值。</p><h2 id="第11章-使用接口"><a href="#第11章-使用接口" class="headerlink" title="第11章: 使用接口"></a>第11章: 使用接口</h2><p>继续前面 <code>NumberInterface</code> 的例子，我们既然将接口定义为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract NumberInterface &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getNum</span><span class="params">(address _myAddress)</span> <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> <span class="params">(uint)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在合约中这样使用：</p><ol><li>获得合约地址（该合约必须为external或者public）</li><li>定义一个变量：指向该合约地址的合约对象（之前定义的与之交互的接口对象）</li><li>调用该合约对象中的函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract &#123;</span><br><span class="line">  address NumberInterfaceAddress = <span class="number">0xab38</span>...;</span><br><span class="line">  <span class="comment">// ^ 这是FavoriteNumber合约在以太坊上的地址</span></span><br><span class="line">  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);</span><br><span class="line">  <span class="comment">// 现在变量 `numberContract` 指向另一个合约对象</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">someFunction</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 现在我们可以调用在那个合约中声明的 `getNum`函数:</span></span><br><span class="line">    uint num = numberContract.getNum(msg.sender);</span><br><span class="line">    <span class="comment">// ...在这儿使用 `num`变量做些什么</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，只要将您合约的可见性设置为<code>public</code>(公共)或<code>external</code>(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</p><h2 id="第12章-处理多返回值"><a href="#第12章-处理多返回值" class="headerlink" title="第12章: 处理多返回值"></a>第12章: 处理多返回值</h2><p><code>getKitty</code> 是我们所看到的第一个返回多个值的函数。我们来看看是如何处理的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multipleReturns</span>(<span class="params"></span>) <span class="title">internal</span> <span class="title">returns</span>(<span class="params">uint a, uint b, uint c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processMultipleReturns</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">  uint a;</span><br><span class="line">  uint b;</span><br><span class="line">  uint c;</span><br><span class="line">  <span class="comment">// 这样来做批量赋值:</span></span><br><span class="line">  (a, b, c) = multipleReturns();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者如果我们只想返回其中一个变量:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLastReturnValue</span>(<span class="params"></span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">  uint c;</span><br><span class="line">  <span class="comment">// 可以对其他字段留空:</span></span><br><span class="line">  (,,c) = multipleReturns();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第13章-奖励-Kitty-基因"><a href="#第13章-奖励-Kitty-基因" class="headerlink" title="第13章: 奖励: Kitty 基因"></a>第13章: 奖励: Kitty 基因</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>if语句的语法在 Solidity 中，与在 JavaScript 中差不多：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eatBLT</span>(<span class="params">string sandwich</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 看清楚了，当我们比较字符串的时候，需要比较他们的 keccak256 哈希码</span></span><br><span class="line">  <span class="keyword">if</span> (keccak256(sandwich) == keccak256(<span class="string">"BLT"</span>)) &#123;</span><br><span class="line">    eat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第14章-放在一起"><a href="#第14章-放在一起" class="headerlink" title="第14章: 放在一起"></a>第14章: 放在一起</h2><h3 id="JavaScript-实现"><a href="#JavaScript-实现" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><p>我们只用编译和部署 <code>ZombieFeeding</code>，就可以将这个合约部署到以太坊了。我们最终完成的这个合约继承自 <code>ZombieFactory</code>，因此它可以访问自己和父辈合约中的所有 public 方法。</p><p>我们来看一个与我们的刚部署的合约进行交互的例子， 这个例子使用了 JavaScript 和 web3.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abi = <span class="comment">/* abi generated by the compiler */</span></span><br><span class="line"><span class="keyword">var</span> ZombieFeedingContract = web3.eth.contract(abi)</span><br><span class="line"><span class="keyword">var</span> contractAddress = <span class="comment">/* our contract address on Ethereum after deploying */</span></span><br><span class="line"><span class="keyword">var</span> ZombieFeeding = ZombieFeedingContract.at(contractAddress)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们有我们的僵尸ID和要攻击的猫咪ID</span></span><br><span class="line"><span class="keyword">let</span> zombieId = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> kittyId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要拿到猫咪的DNA，我们需要调用它的API。这些数据保存在它们的服务器上而不是区块链上。</span></span><br><span class="line"><span class="comment">// 如果一切都在区块链上，我们就不用担心它们的服务器挂了，或者它们修改了API，</span></span><br><span class="line"><span class="comment">// 或者因为不喜欢我们的僵尸游戏而封杀了我们</span></span><br><span class="line"><span class="keyword">let</span> apiUrl = <span class="string">"https://api.cryptokitties.co/kitties/"</span> + kittyId</span><br><span class="line">$.<span class="keyword">get</span>(apiUrl, function(data) &#123;</span><br><span class="line">  <span class="keyword">let</span> imgUrl = data.image_url</span><br><span class="line">  <span class="comment">// 一些显示图片的代码</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户点击一只猫咪的时候:</span></span><br><span class="line">$(<span class="string">".kittyImage"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用我们合约的 `feedOnKitty` 函数</span></span><br><span class="line">  ZombieFeeding.feedOnKitty(zombieId, kittyId)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 侦听来自我们合约的新僵尸事件好来处理</span></span><br><span class="line">ZombieFactory.NewZombie(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 这个函数用来显示僵尸:</span></span><br><span class="line">  generateZombie(result.zombieId, result.name, result.dna)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Solidity的&lt;a href=&quot;https://cryptozombies.io/zh/course&quot;&gt;官方教程&lt;/a&gt;笔记：basic。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链" scheme="https://f7ed.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="blockchain" scheme="https://f7ed.com/tags/blockchain/"/>
    
      <category term="solidity" scheme="https://f7ed.com/tags/solidity/"/>
    
  </entry>
  
  <entry>
    <title>「机器学习-李宏毅」:Unsupervised-PCA</title>
    <link href="https://f7ed.com/2020/10/31/unsupervised-learning-pca/"/>
    <id>https://f7ed.com/2020/10/31/unsupervised-learning-pca/</id>
    <published>2020-10-30T16:00:00.000Z</published>
    <updated>2020-10-31T14:38:26.963Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章详细讲解了无监督学习（Unsupervised learning）的PCA（主成分分析法）。</p><p>文章开篇从聚类（Clustering）引出Distributed Represention，其中粗略阐述了聚类中K-means和HAC（层次聚类）的思想。</p><p>文章的后半部分具体阐述了PCA的数学细节，PCA的去相关性性质，PCA的另一种解释角度（component的角度），PCA的不足等。</p><a id="more"></a><h1 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h1><p>无监督学习分为两种：</p><ul><li><p>Dimension Reduction：化繁为简。</p><p>function 只有input，能将高维、复杂的输入，抽象为低维的输出。</p><p>如下图，能将3D的折叠图像，抽象为一个2D的表示（把他摊开）。</p><img src="https://s1.ax1x.com/2020/10/31/BaoiAe.png" alt="BaodiAe.png" style="zoom:25%;" /></li><li><p>Generation：无中生有。</p><p>function 只有output。</p><p>（后面的博客会提及）</p></li></ul><h2 id="Dimension-Reduction"><a href="#Dimension-Reduction" class="headerlink" title="Dimension Reduction"></a>Dimension Reduction</h2><p>此前，在<a href="/2020/07/03/semi-supervised/" title="semi-supervised learning">semi-supervised learning</a>的最后，提及过better presentation的思想，Dimension Reduction 其实就是这样的思想：去芜存菁，化繁为简。</p><p>比如，在MNIST中，一个数字的表示是28*28维度的向量（图如左），但大多28 *28维度的向量（图为右）都不是数字。</p><img src="https://s1.ax1x.com/2020/10/31/BaopnK.png" alt="BaopnK.png" style="zoom:33%;" /> <p>因此，在表达下图一众“3”的图像中，根本不需要28*28维的向量表示，1-D即可表示一张图（图片的旋转角度）。28 * 28的图像表示就像左边中老者的头发，1-D的表示就像老者的头，是对头发运动轨迹一种更简单的表达。</p><img src="https://s1.ax1x.com/2020/10/31/Bao90O.png" alt="Bao90O.png" style="zoom:30%;" /><h2 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h2><p>在将Dimension Reduction之前，先将一种经典的无监督学习——clustering.</p><p>clustering也是一种降维的表达，将复杂的向量空间抽象为简单的类别，用某一个类别来表示该数据点。</p><p>这里主要讲述cluster的主要思想，算法细节可参考<a href="https://zhuanlan.zhihu.com/p/34168766">其他资料</a> 。（待补充）</p><h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><p>K-means的做法是：</p><ol><li><p>Clustering $X=\left\{x^{1}, \cdots, x^{n}, \cdots, x^{N}\right\}$ into K clusters.</p><p>把所有data分为K个类，K的确定是empirical的，需要自己确定</p></li><li><p>Initialize cluster center $c^i, i=1,2,…,K$ .(K random $x^n$ from $X$)</p><p>初始化K个类的中心数据点，建议从training set $X$ 中随机选K 个点作为初始点。</p><p>不建议直接在向量空间中随机初始化K个中心点，因为很可能随机的中心点不属于任何一个cluster。</p></li><li><p>Repeat：根据中心点标记所属类，再更新新的中心点，重复直收敛。</p><ol><li><p>For all $x^n$ in $X$ : 标记所属类。</p>      $$      b_{i}^{n}\left\{\begin{array}{ll}1 & x^{n} \text { is most "close" to } c^{i} \\ 0 & \text { Otherwise }\end{array}\right.      $$      </li><li><p>Updating all $c^i$ :   $c^{i}=\sum_{x^{n}} b_{i}^{n} x^{n} / \sum_{x^{n}} b_{i}^{n}$  (计算该类中心点)</p></li></ol></li></ol><h3 id="HAC：Hierarchical-Agglomerative-Clustering-HAC"><a href="#HAC：Hierarchical-Agglomerative-Clustering-HAC" class="headerlink" title="HAC：Hierarchical Agglomerative Clustering(HAC)"></a>HAC：Hierarchical Agglomerative Clustering(HAC)</h3><p>另一种clustering的方法是层次聚类（Hierarchical Clustering），这里介绍Agglomerative（自下而上）的策略。</p><img src="https://s1.ax1x.com/2020/10/31/BaIzX6.png" alt="BaIzX6.png" style="zoom:33%;" /><ol><li><p>Build a tree.</p><ol><li>如上图中，计算当前两两数据点（点或组合）的相似度（欧几里得距离或其他）。</li><li>选出最相近的两个合为一组（即连接在同一父子结点上，如最左边的两个）</li><li>重复1-2直至最后合为root。</li></ol><p>该树中，越早分支的点集合，说明越不像。</p></li><li><p>Pick a threshold.</p><p>选一个阈值，即从哪个地方开始划开，比如选上图中红色的线作为阈值，那么点集分为两个cluseter，蓝色、绿色同理。</p></li></ol><p>HAC和K-means相比，HAC不直接决定cluster的数目，而是通过决定threshold的值间接决定cluster的数目。</p><h2 id="Distributed-Representation"><a href="#Distributed-Representation" class="headerlink" title="Distributed Representation"></a>Distributed Representation</h2><p>Cluster：an object must belong to one cluster.</p><p>在做聚类时，一个数据点必须标注为某一具体类别。这往往会丢失很多信息，比如一个人可能是70%的外向，30%的内敛，如果做clustering，就将这个人直接归为外向，这样的表示过于粗糙。</p><p>因此仍用vector来表示这个人，如下图。</p><img src="https://s1.ax1x.com/2020/10/31/BaIv11.png" alt="BaIv11.png" style="zoom:33%;" /> <p>Distributed Representation（也叫Dimension Reduction）就是：一个高维的vector通过function，得到一个低维的vector。</p><img src="https://s1.ax1x.com/2020/10/31/BaIOh9.png" alt="BaIOh9.png" style="zoom:33%;" /><p>Distributed的方法有常见的两种：</p><ul><li><p>Feature selection：</p><p>如下图数据点的分布，可以直接选择feature $x_2$ .</p><img src="https://s1.ax1x.com/2020/10/31/BaILtJ.png" alt="BaIdLtJ.png" style="zoom:33%;" /> <p>但这种方法往往只能处理2-D的情况，对于下图这种3-D情况往往不好做特征选择。</p><img src="https://s1.ax1x.com/2020/10/31/Ba70p9.png" alt="Ba70pd9.png" style="zoom:50%;" /> </li><li><p>Principle component analysis（PCA）</p><p>另一种方法就是著名的PCA，主成分分析法。</p><p>PCA中，这个function就是一个简单的linear function（$W$），通过 $z=Wx$ ，将高维的 $x$ 转化为低维的 $z$ .</p></li></ul><h1 id="PCA：Principle-Component-Analysis"><a href="#PCA：Principle-Component-Analysis" class="headerlink" title="PCA：Principle Component Analysis"></a>PCA：Principle Component Analysis</h1><p>PCA的参考资料见Bishop, Chapter12.</p><p>PCA就是要找 $z=Wx$ 中的 $W$ .</p><h2 id="Main-Idea"><a href="#Main-Idea" class="headerlink" title="Main Idea"></a>Main Idea</h2><h3 id="Reduce-1-D"><a href="#Reduce-1-D" class="headerlink" title="Reduce 1-D"></a>Reduce 1-D</h3><p>如果将dimension reduce to 1-D，那么可以得出 $z_1 = w^1\cdot x$ .</p><p>$w^1$ 是vector，$x$ 是vector，做内积。</p><p>如下图，内积即投影，将所有的点 $x$ 投影到 $w^1$ 方向上，然后得到对应的 $z_1$  值。</p><img src="https://s1.ax1x.com/2020/10/31/BaIjpR.png" alt="BaIjpR.png" style="zoom:33%;" /> <p>而对于得到的一系列 $z_1$ 值，我们希望 $z_1$ 的variance越大越好。</p><p>因为 $z_1$ 的分布越大，用 $z_1$ 来刻画数据，才能更好的区分数据点。</p><p>如下图，如果 $w^1$ 的方向是small variance的方向，那么这些点会集中在一起，而large variance方向，$z_1$ 能更好的刻画数据。</p><img src="https://s1.ax1x.com/2020/10/31/BaIH7F.png" alt="BadIH7F.png" style="zoom:33%;" /><p>$z_1$ 的数学表达是： $ \operatorname{Var}\left(z_{1}\right)=\frac{1}{N} \sum_{z_{1}}\left(z_{1}-\overline{z_{1}}\right)^{2} \quad \left\|w^{1}\right\|_{2}=1$  (后文解释为什么要 $w^1$ 的长度为1)</p><h3 id="Reduce-2-D"><a href="#Reduce-2-D" class="headerlink" title="Reduce 2-D"></a>Reduce 2-D</h3><p>同理，如果将dimension reduce to 2-D .</p><p>$z=Wx$ 即</p>$$\left\{ \begin{array}{11}z_1=w^1\cdot x \\ z_2=w^2 \cdot x  \end{array} \right. ,\quad W=\begin{bmatrix}(w^1)^T \\ (w^2)^T \end{bmatrix}$$<ul><li><p>将所有点 $x$ 投影到 $w^1$ 方向，得到对应的 $z_1$ ，且让 $z_1$ 的分布尽可能的大：</p>  $$  \operatorname{Var}\left(z_{1}\right)=\frac{1}{N} \sum_{z_{1}}\left(z_{1}-\overline{z_{1}}\right)^{2} ,\quad \left\|w^{1}\right\|_{2}=1  $$  </li><li><p>将所有点投影到 $w^2$ 方向，得到对应的 $z_2$ ，同样让 $z_2$ 的分布也尽可能大，再加一个约束条件，让 $w^2$ 和 $w^1$ 正交（后文会具体解释为什么）</p>  $$  \operatorname{Var}\left(z_{2}\right)=\frac{1}{N} \sum_{z_{2}}\left(z_{2}-\overline{z_{2}}\right)^{2} ,\quad \left\|w^{2}\right\|_{2}=1 ,\quad w^1\cdot w^2=0  $$  <p>因此矩阵 $W$ 是Orthogonal matrix (正交矩阵)。</p></li></ul><h2 id="Detail-Warning-of-Math"><a href="#Detail-Warning-of-Math" class="headerlink" title="Detail[Warning of Math"></a><font color=#f00>Detail[Warning of Math</font></h2><p><strong>想跳过math部分的，可以直接看Conclusion。</strong> </p><p>1-D中：</p><p>Goal：find $w^1$ to  maximum $(w^1)^T S w^1$  s.t.$(w^1)^Tw^1=1$</p><p><strong>结论：$w^1$ 就是协方差矩阵 $S$ 最大特征值 $\lambda_1 $  对应的特征向量。 s.t.$(w^1)^Tw^1=1$</strong> </p><p>2-D中：</p><p>Goal：find $w^2$ to maximum $(w^2)^TSw^2 $  s.t. $(w^2)^Tw^2=1, (w^2)^Tw^1=0$ </p><p><strong>结论：$w^2$ 就是协方差矩阵$S$ 第二大特征值 $\lambda_2 $   对应的特征向量。 s.t.$(w^2)^Tw^2=1$</strong>  </p><p>k-D中：</p><p><strong>结论：$w$ 就是协方差矩阵 $S$ 前 $k$ 大的特征值对应的特征向量。s.t. $W$ 是正交矩阵。</strong></p><h3 id="1-D"><a href="#1-D" class="headerlink" title="1-D"></a>1-D</h3><p><strong>Goal：Find $w^1$  to maximum the variance of $z_1$ .</strong> </p><ul><li> $\operatorname{Var}\left(z_{1}\right)=\frac{1}{N} \sum_{z_{1}}\left(z_{1}-\overline{z_{1}}\right)^{2}$  <ul><li> $z_1=w^1\cdot x  ,\quad \overline{z_{1}}=\frac{1}{N} \sum_{z_{1}}=\frac{1}{N} \sum w^{1} \cdot x=w^{1} \cdot \frac{1}{N} \sum x=w^{1} \cdot \bar{x}$  </li></ul></li><li>   $\operatorname{Var}\left(z_{1}\right)=\frac{1}{N} \sum_{z_{1}}\left(z_{1}-\overline{z_{1}}\right)^{2}=(w^1)^T\operatorname{Cov}(x)w^1$  <ul><li>  $=\frac{1}{N} \sum_{x}\left(w^{1} \cdot x-w^{1} \cdot \bar{x}\right)^{2} $ </li><li>  $=\frac{1}{N} \sum\left(w^{1} \cdot(x-\bar{x})\right)^{2}$ <ul><li><p>$a,b$ 是vector：</p> $(a\cdot b)^2=(a^Tb)^2=a^Tba^Tb$ </li><li><p>$a^Tb$ 是scalar:</p> $(a\cdot b)^2  = (a^Tb)^2=a^Tba^Tb =a^Tb(a^Tb)^T=a^Tbb^Ta$ </li></ul></li><li> $=\frac{1}{N} \sum\left(w^{1}\right)^{T}(x-\bar{x})(x-\bar{x})^{T} w^{1}$ </li><li> $ = \left(w^{1}\right)^{T}\sum\frac{1}{N}(x-\bar{x})(x-\bar{x})^{T} \ w^{1}$ </li><li> $=(w^1)^T\operatorname{Cov}(x)w^1$ </li></ul></li><li><p>令 $S=\operatorname{Cov}(x)$ </p></li></ul><p>之前遗留的两个问题：</p><ol><li>$\left|w^1\right|_2=1$ ?</li><li>$w^1\cdot w^2=1$ ?</li></ol><p>现在来看第一个问题，为什么要 $\left|w^1\right|_2=1$ ？</p><p>现在的目标，变成了 maximum $(w^1)^T S w^1$ ，如果不限制 $\left|w^1\right|_2$ ，让 $\left|w^1\right|_2$ 无穷大，那么 $(w^1)^T S w^1$ 的值也会无穷大，问题无解了。</p><hr><p><strong>Goal：maximum $(w^1)^T S w^1$  s.t. $(w^1)^Tw^1=1$</strong></p><ul><li><p>Lagrange multiplier[挖坑] 求解多元变量在有限制条件下的驻点。</p><p>构造拉格朗日函数： $g\left(w^{1}\right)=\left(w^{1}\right)^{T} S w^{1}-\alpha\left(\left(w^{1}\right)^{T} w^{1}-1\right)$   ，$\alpha\neq 0$ 为拉格朗日乘数</p><ul><li>$\nabla_{w^1}g=0$ 的值为驻点（会单独写一篇博客来讲拉格朗日乘数）</li><li>$\frac{\partial g}{\partial \alpha}=0$ 为限制函数</li></ul></li><li><p>对矩阵微分：详情见<a href="https://en.wikipedia.org/wiki/Matrix_calculus#Derivatives_with_vectors">wiki</a> </p><ul><li><p>scalar-by-vector(scalar对vector微分)</p><img src="https://s1.ax1x.com/2020/10/31/BaIIXV.png" alt="BaIIddXV.png" style="zoom:67%;" /></li><li><p>$S$ 是对称矩阵，不是 $w^1$ 的函数，结果用 $w^1$ 表达：$2Sw^1-2\alpha w^1=0$ </p></li></ul></li><li><p>maximum: $(w^1)^T S w^1=\alpha (w^1)^Tw^1=\alpha$ </p></li></ul><p>*<em>Goal：find $w^1$to maximum $\alpha$   *</em>    </p><ul><li><p>$\alpha$ 满足等式：$Sw^1=\alpha w^1$ </p></li><li><p>$\alpha$ 是 $S$ 的特征向量，$w^1$ 是 $S$ 对应于特征值 $\alpha$  的特征向量。</p><ul><li>关于特征值和特征向量的知识参考：参考下面线代知识</li></ul></li><li><p>$w^1$ is the eigenvector(特征向量) of the covarivance matrix S corresponding to the largest eigenvalue $\lambda_1$ . </p><p><strong>结论：$w^1$ 就是协方差矩阵最大特征值对应的特征向量。</strong> </p></li></ul><hr><blockquote><p><strong>梦回线代</strong>QWQ（自己线代学的太差啦 啊这！</p><ol><li><p>特征向量，特征值定义：</p><p>$A$ 是n阶方阵，如果存在数 $\lambda$ 和n维非零向量 $\alpha$ ，满足 $A\alpha=\lambda \alpha$ ,</p><p>则称 $\lambda$ 为方阵 $A$ 的一个特征值，$\alpha$ 为方阵 $A$ 对应于特征值 $\lambda$ 的一个特征向量。</p></li><li><p>求解特征向量和特征值：</p><p>$A\alpha -\lambda \alpha=(A-\lambda I)\alpha=0$ </p><p>齐次方程有非零解的充要条件是特征方程 $det(A-\lambda I)=0$ （行列式为0）</p><ul><li>根据特征方程先求解出 $\lambda$ 的所有值。</li><li>再根将 $\lambda$ 代入齐次方程，求解齐次方程的解 $\alpha$ ，即为对应 $\lambda$ 的特征向量。</li></ul></li></ol></blockquote><h3 id="2-D"><a href="#2-D" class="headerlink" title="2-D"></a>2-D</h3><p><strong>Goal：find $w^2$ to maximum $(w^2)^TSw^2 $  s.t. $(w^2)^Tw^2=1, (w^2)^Tw^1=0$</strong>  </p><ul><li>构造拉格朗日函数： $g\left(w^{2}\right)=\left(w^{2}\right)^{T} S w^{2}-\alpha\left(\left(w^{2}\right)^{T} w^{2}-1\right)-\beta\left(\left(w^{2}\right)^{T} w^{1}-0\right)$ </li><li>对 $w^2$ 求微分，所求点满足等式： $S w^{2}-\alpha w^{2}-\beta w^{1}=0$ <ul><li>左乘 $(w^1) ^T$： $(w^1)^TSw^2-\alpha (w^1)^Tw^2-\beta(w^1)^Tw^1=0$ </li><li>已有： $(w^1)^Tw^2=0, (w^1)^Tw^1=1$  </li><li>证明：$ (w^1)^TSw^2=0$ <ul><li>$\because (w^1)^TSw^2$ 是scalar</li><li> $\therefore (w^1)^TSw^2=((w^1)^TSw^2)^T=(w^2)^TS^Tw^1$  </li><li>$\because S^T=S$ (协方差矩阵是对称矩阵)</li><li>$\because Sw^1=\lambda_1 w^1$ </li><li>$\therefore (w^1)^TSw^2=(w^2)^TSw^1=\lambda_1(w^2)^Tw^1=0$  </li></ul></li><li> $(w^1)^TSw^2-\alpha (w^1)^Tw^2-\beta(w^1)^Tw^1=0-\alpha\cdot 0-\beta \cdot 1=0$ </li><li>$\therefore \beta=0$  </li></ul></li><li>$w^2$ 满足等式：$S w^{2}-\alpha w^{2}=0$ </li><li>和1-D的情况相同：find $w^2$ maximum $(w^2)^TSw^2$ <ul><li>$(w^2)^TSw^2=\alpha$ </li><li>$w^2$  is the eigenvector(特征向量) of the covarivance matrix S corresponding to the largest eigenvalue $\lambda_2$ .</li></ul></li><li>OVER!</li></ul><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>最后解决之前的Q2：$(w^1)^Tw^2=0$ ?</p><ul><li><p>先说明一下$S$ 的性质：</p><p>是对称矩阵，对应不同特征值对应的特征向量都是正交的。</p><p>（参考1，2）</p><p>也是半正定矩阵，其特征值都是非负的。</p><p>（参考4，5，6）</p></li><li><p>其次关于 $W$ 的性质 $ W=\begin{bmatrix}(w^1)^T \\ (w^2)^T \\ ...\end{bmatrix}$ ,易得 $W$ 是orthogonal matrix(正交矩阵)。</p></li><li><p>所以这是一个约束条件，能让PCA的最优化问题转化为求其特征值的问题。</p></li><li><p>（具体见下一小节：PCA-decorrelation）</p><p>其次 $z=Wx$ ，也因为 $W$ 的正交性质，让 $z$ 的各维度（特征）decorrelation，去掉相关性，降维后的特征相互独立，方便后面generative model的假设。</p></li></ul><blockquote><ol><li><p>$S=Cov(x)$ 为实对称矩阵。</p></li><li><p>实对称矩阵的性质：$A$ 是一个实对称矩阵，对于于 $A$ 的不同特征值的特征向量彼此正交。</p></li><li><p>正交矩阵的性质：$W^TW=WW^T=I$ </p></li><li><p>$Var(z)=(w^1)^T S w^1\geq 0$ ，方差一定大于等于0 。</p></li><li><p>半正定矩阵的定义：</p><p>实对称矩阵 $A$ ，对任意非零实向量 $X$ ，如果二次型 $f(X)=X^TAX\geq0$ ，</p><p>则有实对称矩阵 $A$ 是半正定矩阵。</p></li><li><p>半正定矩阵的性质：半正定矩阵的特征值都是非负的。</p></li></ol></blockquote><hr><p>1-D中：</p><p>Goal：find $w^1$ to  maximum $(w^1)^T S w^1$  s.t.$(w^1)^Tw^1=1$</p><p><strong>结论：$w^1$ 就是协方差矩阵 $S$ 最大特征值 $\lambda_1 $  对应的特征向量。 s.t.$(w^1)^Tw^1=1$</strong> </p><p>2-D中：</p><p>Goal：find $w^2$ to maximum $(w^2)^TSw^2 $  s.t. $(w^2)^Tw^2=1, (w^2)^Tw^1=0$ </p><p><strong>结论：$w^2$ 就是协方差矩阵$S$ 第二大特征值 $\lambda_2 $   对应的特征向量。 s.t.$(w^2)^Tw^2=1$</strong>  </p><p>k-D中：</p><p><strong>结论：$w$ 就是协方差矩阵 $S$ 前 $k$ 大的特征值对应的特征向量。s.t. $W$ 是正交矩阵。</strong> </p><h2 id="PCA-decorrelation"><a href="#PCA-decorrelation" class="headerlink" title="PCA-decorrelation"></a>PCA-decorrelation</h2><p>$z=Wx$ </p><p>通过PCA找到的 $W$ ，$x$ 得到新的presentation $z$ ，如下图。</p><img src="https://s1.ax1x.com/2020/10/31/BaITmT.png" alt="BaIdTmT.png" style="zoom:40%;" /><p>可见，经过PCA后，original data变为decorrelated data，各维度（feature）是去相关性的，即各维度是独立的，方便generative model的假设（比如Gaussian distribution).</p><p> $z$ 是docorrelated，即 $Cov(z)=D$ 是diagonal matrix(对角矩阵)</p><p>证明：$Cov(z)=D$ is diagonal matrix</p><ul><li> $W=\begin{bmatrix}(w^1)^T \\ (w^2)^T \\ ...\end{bmatrix}$ ，$S=\operatorname{Cov}(x)$ </li><li> $\operatorname{Cov}(z)=\frac{1}{N} \sum(z-\bar{z})(z-\bar{z})^{T}=W S W^{T}$ </li><li> $=W S\left[\begin{array}{lll}w^{1} & \cdots & w^{K}\end{array}\right]=W\left[\begin{array}{lll}S{w}^{1} & \cdots & S w^{K}\end{array}\right]$ </li><li> $=W\left[\lambda_{1} w^{1} \quad \cdots \quad \lambda_{K} w^{K}\right]=\left[\lambda_{1} W w^{1} \quad \cdots \quad \lambda_{K} W w^{K}\right]$   ($\lambda$ is scalar) </li><li> $=\left[\begin{array}{lll}\lambda_{1} e_{1} & \cdots & \lambda_{K} e_{K}\end{array}\right]=D$ ($W$ is orthogonal matrix) </li></ul><h2 id="PCA-Another-Point-of-View"><a href="#PCA-Another-Point-of-View" class="headerlink" title="PCA-Another Point of View"></a>PCA-Another Point of View</h2><h3 id="Main-Idea-Component"><a href="#Main-Idea-Component" class="headerlink" title="Main Idea: Component"></a>Main Idea: Component</h3><p>PCA看作是一些basic component的组成，如下图，手写数字都是一些基本笔画组成的，记做  $\{u^1,u^2,u^3,...\}$ </p><img src="https://s1.ax1x.com/2020/10/31/BaI4lq.png" alt="BaId4lq.png" style="zoom:25%;" /><p>因此，下图的”7”的组成为 $\{u^1,u^3,u^5\}$ </p><img src="https://s1.ax1x.com/2020/10/31/BaIhpn.png" alt="BadIhpn.png" style="zoom:25%;" /><p>所以原28*28 vector $x$ 表示的图像能近似表示为：</p>$$x \approx c_{1} u^{1}+c_{2} u^{2}+\cdots+c_{K} u^{K}+\bar{x}$$<p>其中  $\{u^1,u^2,u^3,...\}$ 是compoment的vector表示， $\{c^1,c^2,c^3,...\}$ 是component的系数，$\bar{x}$ 是所有images的平均值。</p><p>因此 $\begin{bmatrix}c_1 \\c_2 \\... \\ c_k \end{bmatrix}$ 也能表示一个数字图像。</p><p>现在问题是找到这些component $\{u^1,u^2,u^3,...\}$ , 再得到 他的线形表出 $\begin{bmatrix}c_1 \\c_2 \\... \\ c_k \end{bmatrix}$ 就是我们想得到的better presentation.</p><h3 id="Detail"><a href="#Detail" class="headerlink" title="Detail"></a>Detail</h3><p>要满足：$x \approx c_{1} u^{1}+c_{2} u^{2}+\cdots+c_{K} u^{K}+\bar{x}$  </p><p>即，$x -\bar{x}\approx c_{1} u^{1}+c_{2} u^{2}+\cdots+c_{K} u^{K}$ ，等式两边的误差要尽量小。</p><p>问题变成：找 $\{u^1,u^2,u^3,...\}$ minimize the reconstruction error = $\|(x-\bar{x})-\hat{x}\|_2$ .</p><p>损失函数： $L=\min _{\left\{u^{1}, \ldots, u^{K}\right\}} \sum\left\|(x-\bar{x})-\left(\sum_{k=1}^{K} c_{k} u^{k}\right)\right\|_{2}$ </p><p>而求解PCA的过程就是在minimize损失函数 $L$ ，PCA中求解出的  $\{w^1,w^2,...,w^K\}$ 就是这里的component  $\{u^1,u^2,...,u^K\}$ .(Proof 见Bisho, Chapter 12.1.2)</p><p>*<em>Goal:  minimize the reconstruction error = $\|(x-\bar{x})-\hat{x}\|_2$ *</em>  </p><ul><li><p>$x -\bar{x}\approx c_{1} u^{1}+c_{2} u^{2}+\cdots+c_{K} u^{K}$ </p></li><li><p>每个sample:  $\left\{ \begin{matrix} x^{1}-\bar{x} \approx c_{1}^{1} u^{1}+c_{2}^{1} u^{2}+\cdots \\ x^{2}-\bar{x} \approx c_{1}^{2} u^{1}+c_{2}^{2} u^{2}+\cdots \\x^{3}-\bar{x} \approx c_{1}^{3} u^{1}+c_{2}^{3} u^{2}+\cdots \\ ...\end{matrix} \right.$  </p><ul><li><p>下图中 $X=x-\bar{x}$ 矩阵的第一列都和上面的 $x^1-\bar{x}$ 对应：</p><img src="https://s1.ax1x.com/2020/10/31/BaIWfs.png" alt="BaIWfds.png" style="zoom:25%;" /> </li><li><p>而上面的 $c_{1}^{1} u^{1}+c_{2}^{1} u^{2}+\cdots$ 和下图的component矩阵乘系数矩阵的第一列对应：</p><img src="https://s1.ax1x.com/2020/10/31/BaIRYj.png" alt="BaIRYj.png" style="zoom:25%;" /> </li></ul></li><li><p>因此，是要让下图矩阵的结果 minimize error：</p><img src="https://s1.ax1x.com/2020/10/31/Ba7dfJ.png" alt="Ba7dfJ.png" style="zoom:40%;" /> </li><li><p>如何求解: SVD矩阵分解-其实就是最大近似分解（挖坑）</p><p>SVD能将一个任意的矩阵，分解为下面三个矩阵的乘积。</p><img src="https://s1.ax1x.com/2020/10/31/BaIym8.png" alt="BaIym8.png" style="zoom:30%;" /><p>$X = U\Sigma V$ </p><ul><li>$U,V$ 都是orthogonal matrix，$\Sigma$ 是diagonal matrix。</li><li>组成$U$ (M*K) 的K个列向量是 $XX^T$ 矩阵的前K大特征值对应的特征向量。</li><li>组成 $V$ (K*N)的K个行向量是 $X^TX$ 矩阵的前K大特征值对应的特征向量。</li><li>$XX^T$ 和 $X^TX$ 的特征值相同</li><li>$\Sigma$ 的对角值 $\sigma_i=\sqrt{\lambda_i}$ </li></ul></li><li><p>解：$U$ 矩阵作为 component矩阵， $\Sigma V$ 乘在一起作为系数矩阵。</p></li></ul><hr> $U=\{u^1,u^2,u^3,...\}$ 矩阵是$XX^T$ 的特征向量组成正交矩阵。<p>而PCA的解 $W^T=\{w^1,w^2,...,w^K\}$ 也是特征向量组成的正交矩阵。</p><p><strong>所以和PCA的关系：$U$ 矩阵是 $XX^T=Cov(x)$ 的特征向量，所以$U$ 矩阵就是PCA的解。</strong></p><h3 id="PCA-NN：Autoencoder"><a href="#PCA-NN：Autoencoder" class="headerlink" title="PCA-NN：Autoencoder"></a>PCA-NN：Autoencoder</h3><p>上文说到求解PCA的解 $\{w^1,w^2,...,w^K\}$ 就是在最小化restruction error $x -\bar{x}\approx \sum_{k=1}^K c_kw^k$ .</p><p>两者的联系就是PCA的解 $\{w^1,w^2,...,w^K\}$ 就是component $\{u^1,u^2,u^3,...\}$ ,且PCA的表示是 $z$  对应这里的 $c_k$  (第k个image的表示）.</p><p>PCA视角： $z=c_k=(x-\bar{x})\cdot w^k$  </p><p>PCA looks like a neural network with one hidden layer(linear activation function)。</p><p>把PCA视角看作一个NN，如下图，其hidden layer的激活函数是一个简单的线性激活函数。</p><p><img src="https://s1.ax1x.com/2020/10/31/BaIBlt.png" alt="BaIdBlt.png" style="zoom:25%;" /><img src="https://s1.ax1x.com/2020/10/31/BaI0SI.png" alt="BaI0dSI.png" style="zoom:25%;" /></p><p>再看component视角： $\hat{x}=\sum_{k=1}^K c_kw^k\approx x-\bar{x}$ </p><p><img src="https://s1.ax1x.com/2020/10/31/BaID6P.png" alt="BaIdD6P.png" style="zoom:25%;" /><img src="https://s1.ax1x.com/2020/10/31/BaIJeO.png" alt="BaIdJeO.png" style="zoom:25%;" /></p><p>PCA就构成了下面的NN，hidden layer可以是deep，这就是autoencoder(后面的博客会再详细讲)。</p><img src="https://s1.ax1x.com/2020/10/31/BaIdfA.png" alt="BaIdfA.png" style="zoom:30%;" /><p>用Gradient Descent对输入输出做minimize error，hidden layer的输出 $c$ 就是我们想要的编码（降维后的编码）。 </p><p>Q：用PCA求出的结果和用Gradient Descent训练NN的结果一样吗？</p><p>A：当然不一样，PCA的 $w$ 都是正交的，而NN的结果是gradient descent迭代出来的，并且该结果还会于初值有关。</p><p>Q：有了PCA，为什么还要用NN呢？</p><p>A：因为PCA只能处理linear的情况，对前文那种高维的非线形的无法处理，而NN可以是deep的，能较好处理非线形的情况。</p><h2 id="tips-how-many-components"><a href="#tips-how-many-components" class="headerlink" title="tips: how many components?"></a>tips: how many components?</h2><p>比如在对Pokemon进行PCA时，有六个features，如何确定principle component的数目？</p><p>往往在实际操作中，会对每个component计算一个ratio，如图中的公式：</p><img src="https://s1.ax1x.com/2020/10/31/BaIUFH.png" alt="BaIUFH.png" style="zoom:25%;" /> <p>因为每一个component对应一个eigenvector，每个eigenvector对应一个eigenvalue，而这个eigenvalue的值代表了在这个component的维度的variance有多大，越大当然能更好的表示。</p><p>因此计算eigenvalue的ratio，来找出分布较大的component作为主成分。</p><h2 id="More-About-PCA"><a href="#More-About-PCA" class="headerlink" title="More About PCA"></a>More About PCA</h2><p>如果对MNIST做PCA分析，结果如下图，会发现下面eigen-digits这些并不像数字的某个组成部分：</p><img src="https://s1.ax1x.com/2020/10/31/Ba7ym6.png" alt="Ba7dym6.png" style="zoom:35%;" /><p>同样，对face做PCA分析，结果下图：</p><img src="https://s1.ax1x.com/2020/10/31/Ba7BlR.png" alt="Ba7BlR.png" style="zoom:35%;" /><p>为什么呢？</p><p>在MNIST中，一张image的表示如下图：</p><img src="https://s1.ax1x.com/2020/10/31/BaIYwD.png" alt="BaIYwD.png" style="zoom:33%;" /> <p>其中，$\alpha$ 可以是任意实数，那么就有正有负，所以PCA的解包含了一些真正component的adding up and subtracting，所以MNIST的解不像这些数字的一部分。</p><p>如果想得到的解看起来像真正的component，可以规定图像只能是加，即 $\alpha$ 都是非负的。</p><ul><li>Non-negative matrix factorization(NMF)<ul><li>Forcing $\alpha$ be non-negative: additive combination</li><li>Forcing $w$ be non-negative: components more like “parts of digits”</li></ul></li></ul><h2 id="Weakness-of-PCA"><a href="#Weakness-of-PCA" class="headerlink" title="Weakness of PCA"></a>Weakness of PCA</h2><ol><li><p>PCA是unsupervised，因此可能不能区分本来是两个类别的东西。</p><img src="https://s1.ax1x.com/2020/10/31/BaItTe.png" alt="BaItTe.png" style="zoom:33%;" /> <p>如图，PCA的结果可能是上图的维度方向，但如果引入labeled data，更好的表达应该按照下图LDA的维度方向。</p><ul><li>LDA (Linear Discriminant Analysis) 是一种supervised的分析方法。</li></ul></li><li><p>PCA是Linear的，前文已经提及过，除了可以用NN的方式也有很多其他的non-linear的解法。</p><img src="https://s1.ax1x.com/2020/10/31/BaIaYd.png" alt="BaIaYd.png" style="zoom:45%;" /></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><p>HAC的算法细节待补充完善：<a href="https://zhuanlan.zhihu.com/p/34168766">https://zhuanlan.zhihu.com/p/34168766</a></p></li><li><p>PCA: Bishop, Chapter12. </p></li><li><p>线代知识：特征值、特征向量、实对称矩阵等：</p></li><li><p>拉格朗日乘数：Bishop, Appendix E</p></li><li><p>矩阵微分：<a href="https://en.wikipedia.org/wiki/Matrix_calculus#Derivatives_with_vectors">https://en.wikipedia.org/wiki/Matrix_calculus#Derivatives_with_vectors</a></p></li><li><p>Proof-PCA的过程就是在minimize损失函数 $L$ :Bisho, Chapter 12.1.2</p></li><li><p>SVD：</p><p><a href="https://www.cnblogs.com/pinard/p/6251584.html">https://www.cnblogs.com/pinard/p/6251584.html</a> </p><p><a href="https://www.youtube.com/watch?v=rYz83XPxiZo">https://www.youtube.com/watch?v=rYz83XPxiZo</a></p></li><li><p>NMF：Non-negative matrix factorization</p></li><li><p>LDA：Linear Discriminant Analysis</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章详细讲解了无监督学习（Unsupervised learning）的PCA（主成分分析法）。&lt;/p&gt;
&lt;p&gt;文章开篇从聚类（Clustering）引出Distributed Represention，其中粗略阐述了聚类中K-means和HAC（层次聚类）的思想。&lt;/p&gt;
&lt;p&gt;文章的后半部分具体阐述了PCA的数学细节，PCA的去相关性性质，PCA的另一种解释角度（component的角度），PCA的不足等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习-李宏毅" scheme="https://f7ed.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9D%8E%E5%AE%8F%E6%AF%85/"/>
    
    
      <category term="Machine-Learning" scheme="https://f7ed.com/tags/Machine-Learning/"/>
    
      <category term="open-classes" scheme="https://f7ed.com/tags/open-classes/"/>
    
      <category term="Unsupervised" scheme="https://f7ed.com/tags/Unsupervised/"/>
    
      <category term="PCA" scheme="https://f7ed.com/tags/PCA/"/>
    
  </entry>
  
  <entry>
    <title>「PyTorch」：2-Tensors Explained And Operations</title>
    <link href="https://f7ed.com/2020/10/21/pytorch-tensors/"/>
    <id>https://f7ed.com/2020/10/21/pytorch-tensors/</id>
    <published>2020-10-20T16:00:00.000Z</published>
    <updated>2021-02-28T14:13:23.746Z</updated>
    
    <content type="html"><![CDATA[<p>PyTorch框架学习。</p><p>本篇文章主要介绍PyTorch中的Tensor及其基本操作，主要分为四个方面：Reshape, Element-wise, Reduction和Access。</p><p>Tensor的具体操作介绍，建议配合Colab笔记使用：</p><p><a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/PyTorch%20Tensors%20Explained.ipynb">PyTorch Tensors Explained</a> </p><p><a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReshape.ipynb">Tensor Operations: Reshape</a> </p><p> <a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AElement-Wise.ipynb">Tensor Operations: Element-wise</a>  </p><p><a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReduction%20and%20Access.ipynb">Tensor Operation: Reduction and Access</a>  </p><p>英文的表达解释都是比较清晰且精确的，所以以英语的形式作为主要记录，文中会夹带一些中文总结语句，方便阅读。</p><a id="more"></a><h1 id="Introducing-Tensors"><a href="#Introducing-Tensors" class="headerlink" title="Introducing Tensors"></a>Introducing Tensors</h1><h2 id="Tensor-Explained-Data-Structures-of-Deep-Learning"><a href="#Tensor-Explained-Data-Structures-of-Deep-Learning" class="headerlink" title="Tensor Explained - Data Structures of Deep Learning"></a>Tensor Explained - Data Structures of Deep Learning</h2><h3 id="What-Is-A-Tensor"><a href="#What-Is-A-Tensor" class="headerlink" title="What Is A Tensor?"></a>What Is A Tensor?</h3><p>A tensor is the primary data structure used by neural networks.</p><p>【Tensor是NN中最主要的数据结构】</p><h4 id="Indexes-Required-To-Access-An-Element"><a href="#Indexes-Required-To-Access-An-Element" class="headerlink" title="Indexes Required To Access An Element"></a>Indexes Required To Access An Element</h4><p>The relationship within each of these pairs is that both elements require the same number of indexes to refer to a specific element within the data structure.</p><p>【以下pairs都是需要同等数量的indexes才能确定特定的元素。】</p><p>【而tensor是generalizations，是一种统一而普遍的定义。】</p><table><thead><tr><th>Indexes required</th><th>Computer science</th><th>Mathematics</th></tr></thead><tbody><tr><td>0</td><td>number</td><td>scalar</td></tr><tr><td>1</td><td>array</td><td>vector</td></tr><tr><td>2</td><td>2d-array</td><td>matrix</td></tr></tbody></table><h3 id="Tensors-Are-Generalizations"><a href="#Tensors-Are-Generalizations" class="headerlink" title="Tensors Are Generalizations"></a>Tensors Are Generalizations</h3><p>When more than two indexes are required to access a specific element, we stop giving specific names to the structures, and we begin using more general language.</p><h4 id="Mathematics"><a href="#Mathematics" class="headerlink" title="Mathematics"></a>Mathematics</h4><p>In mathematics, we stop using words like scalar, vector, and matrix, and we start using the word <em>tensor</em> or nd-tensor. The n tells us the number of indexes required to access a specific element within the structure.</p><p>【数学中，当我们需要用大于两个的indexes才能确定特点元素时，我们使用tensor或者nd-tensor来表示该数据结构，说明需要n个index才能确定该数据结构中的特定元素。】</p><h4 id="Computer-Science"><a href="#Computer-Science" class="headerlink" title="Computer Science"></a>Computer Science</h4><p>In computer science, we stop using words like, number, array, 2d-array, and start using the word <em>multidimensional array</em> or nd-array. The <code>n</code> tells us the number of indexes required to access a specific element within the structure.</p><p>【计算机科学中，我们使用nd-array来表示，因此，nd-array和tensor实则是一个东西。】</p><table><thead><tr><th>Indexes required</th><th>Computer science</th><th>Mathematics</th></tr></thead><tbody><tr><td>n</td><td>nd-array</td><td>nd-tensor</td></tr></tbody></table><p>Tensors and nd-arrays are the same thing!</p><p>One thing to note about the dimension of a tensor is that it differs from what we mean when we refer to the dimension of a vector in a vector space. The dimension of a tensor does not tell us how many components exist within the tensor.</p><p>【需要注意的地方是，tensor中的维度和vector向量空间中的维度不是同一个东西，vector向量空间中的维度表示该vector有多少个元素组成的，而tensor中的维度是下文中rank的含义。】</p><h2 id="Rank-Axes-And-Shape-Explained"><a href="#Rank-Axes-And-Shape-Explained" class="headerlink" title="Rank, Axes, And Shape Explained"></a>Rank, Axes, And Shape Explained</h2><p>【下文会详细解释深度学习tensor的几个重要性质：Rank, Axes, Shape.】</p><p>The concepts of rank, axes, and shape are the tensor attributes that will concern us most in deep learning.</p><ul><li>Rank</li><li>Axes</li><li>Shape</li></ul><h3 id="Rank-And-Indexes"><a href="#Rank-And-Indexes" class="headerlink" title="Rank And Indexes"></a>Rank And Indexes</h3><p>We are introducing the word <em>rank</em> here because it is commonly used in deep learning when referring to the number of dimensions present within a given tensor. </p><p>The rank of a tensor tells us how many indexes are required to access (refer to) a specific data element contained within the tensor data structure.</p><p>A tensor’s rank tells us how many indexes are needed to refer to a specific element within the tensor.</p><p>【这里的rank实则就是tensor的维度。】</p><p>【tensor的rank值告诉我们需要多少个indexes才能确定该tensor中的特定元素。】</p><h3 id="Axes-Of-A-Tensor"><a href="#Axes-Of-A-Tensor" class="headerlink" title="Axes Of A Tensor"></a>Axes Of A Tensor</h3><p>If we have a tensor, and we want to refer to a specific <em>dimension</em>, we use the word <em>axis</em> in deep learning.</p><p>An axis of a tensor is a specific dimension of a tensor.</p><p>Elements are said to exist or run along an axis. This <em>running</em> is constrained by the length of each axis. Let’s look at the length of an axis now.</p><h4 id="Length-Of-An-Axis"><a href="#Length-Of-An-Axis" class="headerlink" title="Length Of An Axis"></a>Length Of An Axis</h4><p>The length of each axis tells us how many indexes are available along each axis.</p><p>【当我们关注tensor的某一具体维度时，在深度学习中我们使用axis来表达。】</p><p>【元素被认为是在某一axie上存在或延伸的，元素延伸的长度取决于axis的长度。】</p><p>【Axis的长度表示在每一维度（axis）上有多少个索引】</p><h3 id="Shape-Of-A-Tensor"><a href="#Shape-Of-A-Tensor" class="headerlink" title="Shape Of A Tensor"></a>Shape Of A Tensor</h3><p>The <em>shape</em> of a tensor is determined by the length of each axis, so if we know the shape of a given tensor, then we know the length of each axis, and this tells us how many indexes are available along each axis.</p><p>The shape of a tensor gives us the length of each axis of the tensor.</p><p>【tensor的shape由每一axis的长度决定，即每一axis的索引数目】</p><p>Additionally, one of the types of operations we must perform frequently when we are programming our neural networks is called <em>reshaping</em>.</p><p>Reshaping changes the shape but not the underlying data elements.</p><p>【tensor的常见操作reshape只改变tensor的shape，而不改变底层的数据。】</p><h2 id="CNN-Tensors-Shape-Explained"><a href="#CNN-Tensors-Shape-Explained" class="headerlink" title="CNN Tensors Shape Explained"></a>CNN Tensors Shape Explained</h2><p>CNN的相关介绍，可见 <a href="/2020/04/25/CNN/" title="这篇文章">这篇文章</a></p><p>What I want to do now is put the concepts of rank, axes, and shape to use with a practical example. To do this, we’ll consider an image input as a tensor to a CNN.</p><p>Remember that the shape of a tensor encodes all the relevant information about a tensor’s axes, rank, and indexes, so we’ll consider the shape in our example, and this will enable us to work out the other values. </p><p>【tensor的shape能体现tensor的axes、rank、index所有信息】</p><p>【以CNN为例来说明rank, axes, shape.】</p><h3 id="Shape-Of-A-CNN-Input"><a href="#Shape-Of-A-CNN-Input" class="headerlink" title="Shape Of A CNN Input"></a>Shape Of A CNN Input</h3><p>The shape of a CNN input typically has a length of four. This means that we have a rank-4 tensor with four axes. Each index in the tensor’s shape represents a specific axis, and the value at each index gives us the length of the corresponding axis.</p><p>【CNN的input 是一个rank4-tensor.】</p><p>Each axis of a tensor usually represents some type of real world or logical feature of the input data. If we understand each of these features and their axis location within the tensor, then we can have a pretty good understanding of the tensor data structure overall.</p><p>【tensor的每个axis往往代表着某一个逻辑feature，所以理解features和tensor中axis的位置的关系能帮助我们更好的理解tensor。】</p><h4 id="Image-Height-And-Width"><a href="#Image-Height-And-Width" class="headerlink" title="Image Height And Width"></a>Image Height And Width</h4><p>To represent two dimensions, we need two axes.</p><p>The image height and width are represented on the last two axes.</p><p>【表示图像的height和width，需要2个axes，使用最后两个axes表示。】</p><h4 id="Image-Color-Channels"><a href="#Image-Color-Channels" class="headerlink" title="Image Color Channels"></a>Image Color Channels</h4><p>The next axis represents the color channels. Typical values here are <code>3</code> for RGB images or <code>1</code> if we are working with grayscale images. This color channel interpretation only applies to the input tensor.</p><p>【下一个axis(从右至左)表示图像的color channels（颜色通道，如灰度图像就有1个颜色通道，RGB图像有三个）。】</p><p>【注意：color channel的说法只适用于input tensor。】</p><h4 id="Image-Batches"><a href="#Image-Batches" class="headerlink" title="Image Batches"></a>Image Batches</h4><p>This brings us to the first axis of the four which represents the batch size. In neural networks, we usually work with batches of samples opposed to single samples, so the length of this axis tells us how many samples are in our batch.</p><p>Suppose we have the following shape <code>[3, 1, 28, 28]</code> for a given tensor. Using the shape, we can determine that we have a batch of three images.</p><p>【第一个axis表示batch属性，表明该batch的size。在深度学习中，我们通常使用一批样本，而不是一个单独的样本，所以这一维度表明了我们的batch中有多少样本。】</p><p>tensor：[Batch, Channels, Height, Width]</p><p>Each image has a single color channel, and the image height and width are <code>28 x 28</code> respectively.</p><ol><li>Batch size</li><li>Color channels</li><li>Height</li><li>Width</li></ol><h4 id="NCHW-vs-NHWC-vs-CHWN"><a href="#NCHW-vs-NHWC-vs-CHWN" class="headerlink" title="NCHW vs NHWC vs CHWN"></a>NCHW vs NHWC vs CHWN</h4><p>It’s common when reading API documentation and academic papers to see the <code>B</code> replaced by an <code>N</code>. The <code>N</code> standing for <em>number of samples</em> in a batch.</p><p>【在API文档或学术论文中，N经常会代替代替B，表示the number of samples in a batch。】</p><p>Furthermore, another difference we often encounter in the wild is a <em>reordering</em> of the dimensions. Common orderings are as follows:</p><ul><li><code>NCHW</code></li><li><code>NHWC</code></li><li><code>CHWN</code></li></ul><p>【除此之外，也会经常遇到这些axes的其他顺序。】</p><p>As we have seen, PyTorch uses <code>NCHW</code>, and it is the case that TensorFlow and Keras use <code>NHWC</code> by default (it can be configured). Ultimately, the choice of which one to use depends mainly on performance. Some libraries and algorithms are more suited to one or the other of these orderings.</p><p>【PyTorch 默认使用NCHW，而TensorFlow和Keras使用NHWC】</p><h3 id="Output-Channels-And-Feature-Maps"><a href="#Output-Channels-And-Feature-Maps" class="headerlink" title="Output Channels And Feature Maps"></a>Output Channels And Feature Maps</h3><p>Let’s look at how the interpretation of the color channel axis changes after the tensor is transformed by a convolutional layer.</p><p>Suppose we have three convolutional filters, and lets just see what happens to the channel axis.</p><p>Since we have three convolutional filters, we will have three channel outputs from the convolutional layer. These channels are outputs from the convolutional layer, hence the name output <em>channels opposed</em> to <em>color channels</em>.</p><p>【tensor送入convolutional layer（卷积层）后，color channel 这一axis的长度发生变化。</p><p>【在中解释到，有几个convolutional filters，卷积层输出的tensor就有几个channel（channel代替color channel的表达）。】</p><h4 id="Feature-Maps"><a href="#Feature-Maps" class="headerlink" title="Feature Maps"></a>Feature Maps</h4><p>With the output channels, we no longer have color channels, but modified channels that we call <em>feature maps</em>. These so-called feature maps are the outputs of the convolutions that take place using the input color channels and the convolutional filters.</p><p>Feature maps are the output channels created from the convolutions.</p><p>【卷积层输出tensor的channel维度代替color channels的叫法。】</p><p>【卷积层的输出也叫叫feature maps】</p><h1 id="PyTorch-Tensors"><a href="#PyTorch-Tensors" class="headerlink" title="PyTorch Tensors"></a>PyTorch Tensors</h1><p>When programming neural networks, data preprocessing is often one of the first steps in the overall process, and one goal of data preprocessing is to transform the raw input data into tensor form.</p><p>【数据预处理往往是编写NN的第一步，将原始数据转换为tensor form。】</p><p>Tensor的基本操作见Colab运行笔记链接：<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/PyTorch%20Tensors%20Explained.ipynb">PyTorch Tensors Explained</a> </p><p>(不会用的也可以直接看<a href="https://github.com/f1ed/PyTorch-Notebook/blob/master/PyTorch%20Tensors%20Explained.ipynb">github</a> 上的)</p><h2 id="PyTorch-Tensors-Attributes"><a href="#PyTorch-Tensors-Attributes" class="headerlink" title="PyTorch Tensors Attributes"></a>PyTorch Tensors Attributes</h2><ul><li><p>torch.dtype：tensor包含数据类型。</p><p>常见数据类型：</p><table><thead><tr><th>Data type</th><th>dtype</th><th>CPU tensor</th><th>GPU tensor</th></tr></thead><tbody><tr><td>32-bit floating point</td><td>torch.float32</td><td>torch.FloatTensor</td><td>torch.cuda.FloatTensor</td></tr><tr><td>64-bit floating point</td><td>torch.float64</td><td>torch.DoubleTensor</td><td>torch.cuda.DoubleTensor</td></tr><tr><td>16-bit floating point</td><td>torch.float16</td><td>torch.HalfTensor</td><td>torch.cuda.HalfTensor</td></tr><tr><td>8-bit integer (unsigned)</td><td>torch.uint8</td><td>torch.ByteTensor</td><td>torch.cuda.ByteTensor</td></tr><tr><td>8-bit integer (signed)</td><td>torch.int8</td><td>torch.CharTensor</td><td>torch.cuda.CharTensor</td></tr><tr><td>16-bit integer (signed)</td><td>torch.int16</td><td>torch.ShortTensor</td><td>torch.cuda.ShortTensor</td></tr><tr><td>32-bit integer (signed)</td><td>torch.int32</td><td>torch.IntTensor</td><td>torch.cuda.IntTensor</td></tr><tr><td>64-bit integer (signed)</td><td>torch.int64</td><td>torch.LongTensor</td><td>torch.cuda.LongTensor</td></tr></tbody></table></li><li><p>torch.device: tensor数据所分配的设备，如CPU，cuda:0</p></li><li><p>torch.layout: tensor在内存中的存储方式。</p></li></ul><p>As neural network programmers, we need to be aware of the following:</p><ol><li>Tensors contain data of a uniform type (<code>dtype</code>).</li><li>Tensor computations between tensors depend on the <code>dtype</code> and the <code>device</code>.</li></ol><p>【Tensors包含相同类型的数据】</p><p>【Tensors之间的计算取决于他的类型和他所分配的设备】</p><h2 id="Creating-Tensors"><a href="#Creating-Tensors" class="headerlink" title="Creating Tensors"></a>Creating Tensors</h2><p>These are the primary ways of creating tensor objects (instances of the <code>torch.Tensor</code> class), with data (array-like) in PyTorch:</p><p>Creating Tensors with data.</p><p>【四种用数据创建tensor的方式】</p><ol><li><code>torch.Tensor(data)</code></li><li><code>torch.tensor(data)</code></li><li><code>torch.as_tensor(data)</code></li><li><code>torch.from_numpy(data)</code> </li></ol><h3 id="torch-Tensor-Vs-torch-tensor"><a href="#torch-Tensor-Vs-torch-tensor" class="headerlink" title="torch.Tensor() Vs torch.tensor()"></a><code>torch.Tensor()</code> Vs <code>torch.tensor()</code></h3><p>The first option with the uppercase <code>T</code> is the constructor of the <code>torch.Tensor</code> class, and the second option is what we call a <em>factory function</em> that constructs <code>torch.Tensor</code> objects and returns them to the caller.</p><p>However, the factory function <code>torch.tensor()</code> has better documentation and more configuration options, so it gets the winning spot at the moment.</p><p>【<code>torch.Tensor(data)</code> 是 <code>torch.Tensor</code> class的Constructor，而<code>torch.tensor(data)</code> 是生成/返回 torch.Tensor class的函数（factory functions)】</p><p>【因为<code>torch.tensor()</code> 有更多的选项设置，比如可以设置数据类型，所以一般用<code>torch.tensor()</code> 来生成。】</p><h3 id="Default-dtype-Vs-Inferred-dtype"><a href="#Default-dtype-Vs-Inferred-dtype" class="headerlink" title="Default dtype Vs Inferred dtype"></a>Default <code>dtype</code> Vs Inferred <code>dtype</code></h3><p>The difference here arises in the fact that the <code>torch.Tensor()</code> constructor uses the default <code>dtype</code> when building the tensor. The other calls choose a dtype based on the incoming data. This is called <em>type inference</em>. The <code>dtype</code> is inferred based on the incoming data.</p><p>【<code>torch.Tensor()</code> 在生成tensor时，使用的是默认<code>dtype=torch.float32</code> ，而其他三种是使用的引用<code>dtype</code> ，即生成tensor的数据类型和输入的数据类型一致。】</p><h3 id="Sharing-Memory-For-Performance-Copy-Vs-Share"><a href="#Sharing-Memory-For-Performance-Copy-Vs-Share" class="headerlink" title="Sharing Memory For Performance: Copy Vs Share"></a>Sharing Memory For Performance: Copy Vs Share</h3><p><code>torch.Tensor()</code> and <code>torch.tensor()</code> <em>copy</em> their input data while <code>torch.as_tensor()</code> and <code>torch.from_numpy()</code> <em>share</em> their input data in memory with the original input object.</p><p>This sharing just means that the actual data in memory exists in a single place. As a result, any changes that occur in the underlying data will be reflected in both objects, the <code>torch.Tensor</code> and the <code>numpy.ndarray</code>.</p><p>Sharing data is more efficient and uses less memory than copying data because the data is not written to two locations in memory.</p><p>【<code>torch.Tensor()</code> 和 <code>torch.tensor()</code> 在根据data创建tensor时，在内存中额外复制数据】</p><p>【<code>torch.as_tensor()</code> 和 <code>torch.from_numpy()</code> 在根据data创建tensor时，是和原输入数据共享的内存，即原numpy.ndarry的数据改变，相应的tensor也会改变。】</p><table><thead><tr><th>Share Data</th><th>Copy Data</th></tr></thead><tbody><tr><td>torch.as_tensor()</td><td>torch.tensor()</td></tr><tr><td>torch.from_numpy()</td><td>torch.Tensor()</td></tr></tbody></table><p>Some things to keep in mind about memory sharing (it works where it can):</p><ol><li><p>Since <code>numpy.ndarray</code> objects are allocated on the CPU, the <code>as_tensor()</code> function must copy the data from the CPU to the GPU when a GPU is being used.</p><p>【在使用GPU时， <code>as_tensor()</code> 也会将ndarray数据从CPU复制到GPU上。】</p></li><li><p>The memory sharing of <code>as_tensor()</code> doesn’t work with built-in Python data structures like lists.</p><p>【<code>as_tensor()</code> 在Python内置数据结构时不会共享内存】</p></li><li><p>The <code>as_tensor()</code> performance improvement will be greater if there are a lot of back and forth operations between <code>numpy.ndarray</code> objects and tensor objects. </p><p>【<code>as_tensor()</code> 在ndarry和tensor之间大量连续操作时能有效提高性能】</p></li></ol><h3 id="torch-as-tensor-Vs-torch-from-numpy"><a href="#torch-as-tensor-Vs-torch-from-numpy" class="headerlink" title="torch.as_tensor() Vs torch.from_numpy()"></a><code>torch.as_tensor()</code> Vs <code>torch.from_numpy()</code></h3><p>This establishes that <code>torch.as_tensor()</code> and <code>torch.from_numpy()</code> both share memory with their input data. However, which one should we use, and how are they different?</p><p>The <code>torch.from_numpy()</code> function only accepts <code>numpy.ndarray</code>s, while the <code>torch.as_tensor()</code> function accepts a wide variety of array-like objects, including other PyTorch tensors. </p><p>【这两个都是和输入数据共享内存，但 <code>torch.from_numpy()</code> 只能接受<code>numpy.ndarrays</code> 类型的数据，而<code>torch.as_tensor()</code> 能接受array-like(像list, tuple)等类型，所以一般<code>torch.as_tensor()</code> 更常用。】</p><p>If we have a <code>torch.Tensor</code> and we want to convert it to a <code>numpy.ndarray</code></p><p>【用<code>torch.numpy()</code> 把tensor转换为ndarray】</p><hr><p>Creating Tensors without data.</p><p>【还有几种创建常见tensor的方式】</p><ol><li><code>torch.eyes(n)</code> : 创建2-D tensor，即n*n的单位向量。</li><li><code>torch.zeros(shape)</code> : 创建shape=shape的全0tensor。</li><li><code>torch.ones(shape)</code> : 创建全1tensor。</li><li><code>torch.rand(shape)</code> : 创建随机值tensor。</li></ol><h1 id="Tensor-Operation"><a href="#Tensor-Operation" class="headerlink" title="Tensor Operation"></a>Tensor Operation</h1><p>关于Tensor 操作的Colab运行笔记。对照使用最佳。如果打不开也可以看<a href="https://github.com/f1ed/PyTorch-Notebook">github</a> </p><p><a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReshape.ipynb">Tensor Operations: Reshape</a> </p><p><a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AElement-Wise.ipynb">Tensor Operations: Element-wise</a> </p><p><a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AElement-Wise.ipynb">Tensor Operation: Reduction and Access</a> </p><p>We have the following high-level categories of operations:</p><ol><li>Reshaping operations</li><li>Element-wise operations</li><li>Reduction operations</li><li>Access operations</li></ol><p>【对tensor的操作主要分为4种：reshape, element-wise, reduction, access】</p><h2 id="Reshape"><a href="#Reshape" class="headerlink" title="Reshape"></a>Reshape</h2><p>As neural network programmers, we have to do the same with our tensors, and usually shaping and reshaping our tensors is a frequent task.</p><p>【reshape在NN编程中是很常见的操作】</p><p>（具体操作见colab运行笔记本:<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReshape.ipynb">Tensor Operations: Reshape</a> ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">t = torch.tensor([</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">], dtype=torch.float32)</span><br><span class="line">t.reshape([<span class="number">2</span>,<span class="number">6</span>])</span><br><span class="line">t.reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>Reshaping changes the tensor’s shape but not the underlying data. Our tensor has <code>12</code> elements, so any reshaping must account for exactly <code>12</code> elements.</p><p>【reshape操作不改变底层的数据，只是改变tensor的shape】</p><p> In PyTorch, the <code>-1</code> tells the <code>reshape()</code> function to figure out what the value should be based on the number of elements contained within the tensor.</p><p>【reshape中传入的-1参数，PyTorch可以自动计算该值，因为PyTorch要保证tensor的元素个数不变】</p><h3 id="Squeezing-And-Unsqueezing"><a href="#Squeezing-And-Unsqueezing" class="headerlink" title="Squeezing And Unsqueezing"></a>Squeezing And Unsqueezing</h3><ul><li><p><em>Squeezing</em> a tensor removes the dimensions or axes that have a length of one.</p><p>【Squeezing操作：移除tensor中axis长度为1的维度】</p></li><li><p><em>Unsqueezing</em> a tensor adds a dimension with a length of one.</p><p>【Unsqueezing操作：增加一个axis长度为1的维度】</p></li></ul><p>（具体操作见colab运行笔记本:<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReshape.ipynb">Tensor Operations: Reshape</a> ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.squeeze()</span><br><span class="line">t.squeeze().unsqueeze(dim=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="Concatenation-Tensors"><a href="#Concatenation-Tensors" class="headerlink" title="Concatenation Tensors"></a>Concatenation Tensors</h3><p>We combine tensors using the <code>cat()</code> function, and the resulting tensor will have a shape that depends on the shape of the two input tensors.</p><p>（具体操作见colab运行笔记本:<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReshape.ipynb">Tensor Operations: Reshape</a> ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.cat((t1,t2,t3), dim=<span class="number">0</span>)</span><br><span class="line">torch.cat((t1,t2,t3), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h3><p>这里从CNN的例子看Flatten，CNN的相关细节见：<a href="/2020/04/25/CNN/" title="这篇文章">这篇文章</a></p><p>A tensor flatten operation is a common operation inside convolutional neural networks. This is because convolutional layer outputs that are passed to fully connected layers must be flatted out before the fully connected layer will accept the input.</p><p>【flatten在卷积层网络很常见，因为输入必须flatten后才能连接到一个全连接网络层】</p><p>对于MNIST数据集中18*18的手写数字，在前文说到CNN的输入是<code>[Batch Size, Channels, Height, Width]</code> ，怎么才能flatten tensor的部分axis，而不是全部维度。</p><p>CNN的输入，需要flatten的axes：(C,H,W)</p><p>从dim1维度开始flatten（具体操作见colab运行笔记本:<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReshape.ipynb">Tensor Operations: Reshape</a> ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.flatten(start_dim=<span class="number">1</span>, end_dim=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="Broadcasting-and-Element-Wise"><a href="#Broadcasting-and-Element-Wise" class="headerlink" title="Broadcasting and Element-Wise"></a>Broadcasting and Element-Wise</h2><p>An <em>element-wise</em> operation operates on corresponding elements between tensors.</p><p>【element-wise操作两个tensor之间对应的元素。】</p><h3 id="Broadcasting"><a href="#Broadcasting" class="headerlink" title="Broadcasting"></a>Broadcasting</h3><p>Broadcasting describes how tensors with different shapes are treated during element-wise operations.</p><p>Broadcasting is the concept whose implementation allows us to add scalars to higher dimensional tensors.</p><p>【broadcast描述了不同shape之间的tensor如何进行element-wise操作】</p><p>【broadcast允许我们增加scalars到高维度】</p><p>Let’s think about the <code>t1 + 2</code> operation. Here, the scaler valued tensor is being broadcasted to the shape of <code>t1</code>, and then, the element-wise operation is carried out.</p><p>【在t1+2时，scalar 2实际是先被broadcast到和t1相同的shape, 再执行element-wise操作】</p><p>We have two tensors with different shapes. The goal of broadcasting is to make the tensors have the same shape so we can perform element-wise operations on them.</p><p>（具体操作见colab运行笔记本:<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AElement-Wise.ipynb">Tensor Operations: Element-wise</a> ）</p><h3 id="Broadcasting-Details"><a href="#Broadcasting-Details" class="headerlink" title="Broadcasting Details"></a>Broadcasting Details</h3><p>（具体操作见colab运行笔记本:<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AElement-Wise.ipynb">Tensor Operations: Element-wise</a> ）</p><ul><li><p>Same Shapes: 直接操作</p></li><li><p>Same Rank, Different Shape:</p><ol><li><p>Determine if tensors are compatible（兼容）.</p><p>【两个tensor兼容，才可以对tensor broadcast，再执行element-wise操作】</p><p>We compare the shapes of the two tensors, starting at their last dimensions and working backwards. Our goal is to determine whether each dimension between the two tensors’ shapes is compatible.</p><p>【从最后一个维度向前判断，每个维度是否兼容】</p><p>【判断该维度兼容的条件是满足下面两个条件其一：维度长度相同；或者其中一个为1】</p><p>The dimensions are compatible when either:</p><ul><li>They’re equal to each other.</li><li>One of them is 1.</li></ul></li><li><p>Determine the shape of the resulting tensor.</p><p>【操作的结果是一个新的tensor，结果tensor的每个维度长度是原tensors在该维度的最大值】</p></li></ol></li><li><p>Different Ranks:</p><ol><li><p>Determine if tensors are compatible.(同上)</p><p>When we’re in a situation where the ranks of the two tensors aren’t the same, like what we have here, then we simply substitute a one in for the missing dimensions of the lower-ranked tensor.</p><p>【对低维度的tensor的缺失维度，用1来代替，比如shape为(1,3) 和 ()，低维度的shape变为(1,1)】</p></li><li><p>Determine the shape of the resulting tensor.</p></li></ol></li></ul><h2 id="ArgMax-and-Reduction"><a href="#ArgMax-and-Reduction" class="headerlink" title="ArgMax and Reduction"></a>ArgMax and Reduction</h2><p>A <em>reduction operation</em> on a tensor is an operation that reduces the number of elements contained within the tensor.</p><p>【reduction 操作是能减少tensor元素数量的操作。】</p><p>Reshaping operations gave us the ability to position our elements along particular axes. Element-wise operations allow us to perform operations on elements between two tensors, and reduction operations allow us to perform operations on elements within a single tensor.</p><p>【Reshape操作让我们能沿着某一axis操纵tensor 中的元素位置；Element-wise操作让我们能对tensors之间对应元素进行操作；Reduction操作能让我们对单个tensor间的元素操作。】</p><p>(具体操作见colab笔记本：<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AElement-Wise.ipynb">Tensor Operation: Reduction and Access</a> )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t.sum()</span><br><span class="line">t.prod()</span><br><span class="line">t.mean()</span><br><span class="line">t.std()</span><br></pre></td></tr></table></figure><h3 id="Reducing-Tensors-By-Axes"><a href="#Reducing-Tensors-By-Axes" class="headerlink" title="Reducing Tensors By Axes"></a>Reducing Tensors By Axes</h3><p>只需要对这些方法传一个维度对参数。</p><p>(具体操作见colab笔记本：<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReduction%20and%20Access.ipynb">Tensor Operation: Reduction and Access</a>   )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.sum(dim=<span class="number">0</span>)</span><br><span class="line">t.sum(dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="Argmax"><a href="#Argmax" class="headerlink" title="Argmax"></a>Argmax</h3><p><em>Argmax</em> returns the index location of the maximum value inside a tensor.</p><p>【Argmax返回最大value的index】</p><p>(具体操作见colab笔记本：<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReduction%20and%20Access.ipynb">Tensor Operation: Reduction and Access</a>  )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.argmax(dim=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Aceessing-Elements-Inside-Tensors"><a href="#Aceessing-Elements-Inside-Tensors" class="headerlink" title="Aceessing Elements Inside Tensors"></a>Aceessing Elements Inside Tensors</h2><p>The last type of common operation that we need for tensors is the ability to access data from within the tensor.</p><p>【Access操作能获得tensor中的数据，即将tensor中的数据拿出来放在Python内置的数据结构中】</p><p>(具体操作见colab笔记本：<a href="https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReduction%20and%20Access.ipynb">Tensor Operation: Reduction and Access</a> ) </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.mean().item()</span><br><span class="line">t.mean(dim=<span class="number">0</span>).tolist()</span><br><span class="line">t.mean(dim=<span class="number">0</span>).numpy()</span><br></pre></td></tr></table></figure><h3 id="Advanced-Indexing-And-Slicing"><a href="#Advanced-Indexing-And-Slicing" class="headerlink" title="Advanced Indexing And Slicing"></a>Advanced Indexing And Slicing</h3><p>PyTorch Tensor支持大多数NumPy的index和slicing操作。</p><p>坑：<a href="https://numpy.org/doc/stable/reference/arrays.indexing.html">https://numpy.org/doc/stable/reference/arrays.indexing.html</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>挖坑：advanced indexing and slicing: <a href="https://numpy.org/doc/stable/reference/arrays.indexing.html">https://numpy.org/doc/stable/reference/arrays.indexing.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PyTorch框架学习。&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍PyTorch中的Tensor及其基本操作，主要分为四个方面：Reshape, Element-wise, Reduction和Access。&lt;/p&gt;
&lt;p&gt;Tensor的具体操作介绍，建议配合Colab笔记使用：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/PyTorch%20Tensors%20Explained.ipynb&quot;&gt;PyTorch Tensors Explained&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReshape.ipynb&quot;&gt;Tensor Operations: Reshape&lt;/a&gt; &lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AElement-Wise.ipynb&quot;&gt;Tensor Operations: Element-wise&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://colab.research.google.com/github/f1ed/PyTorch-Notebook/blob/master/Tensor%20Operations%EF%BC%9AReduction%20and%20Access.ipynb&quot;&gt;Tensor Operation: Reduction and Access&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;英文的表达解释都是比较清晰且精确的，所以以英语的形式作为主要记录，文中会夹带一些中文总结语句，方便阅读。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://f7ed.com/categories/PyTorch/"/>
    
    
      <category term="open-classes" scheme="https://f7ed.com/tags/open-classes/"/>
    
      <category term="DEEPLIZARD" scheme="https://f7ed.com/tags/DEEPLIZARD/"/>
    
      <category term="PyTorch" scheme="https://f7ed.com/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>「PyTorch」：1-PyTorch Explained</title>
    <link href="https://f7ed.com/2020/10/20/pytorch-introduction/"/>
    <id>https://f7ed.com/2020/10/20/pytorch-introduction/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2021-02-28T14:13:13.952Z</updated>
    
    <content type="html"><![CDATA[<p>PyTorch框架学习。</p><p>本篇文章主要介绍PyTorch的相关背景知识。</p><a id="more"></a><h1 id="PyTorch-Explained-Python-DNN-API"><a href="#PyTorch-Explained-Python-DNN-API" class="headerlink" title="PyTorch Explained: Python DNN API"></a>PyTorch Explained: Python DNN API</h1><p>【PyTorch，是使用Python来深度学习的一个API。】</p><p>PyTorch <code>torch.Tensor</code> objects that are created from NumPy <code>ndarray</code> objects, share memory. This makes the transition between PyTorch and NumPy very cheap from a performance perspective.</p><p>With PyTorch tensors, GPU support is built-in. It’s very easy with PyTorch to move tensors to and from a GPU if we have one installed on our system.</p><p>【PyTorch原生支持GPU】</p><h2 id="A-Brief-History"><a href="#A-Brief-History" class="headerlink" title="A Brief History"></a>A Brief History</h2><p>The initial release of PyTorch was in October of 2016, and before PyTorch was created, there was and still is, another framework called <em>Torch</em>. <a href="https://en.wikipedia.org/wiki/Torch_(machine_learning)">Torch</a> is a machine learning framework that’s been around for quite a while and is based on the <a href="https://en.wikipedia.org/wiki/Lua_(programming_language)">Lua programming language</a>.</p><p>The connection between PyTorch and this Lua version, called Torch, exists because many of the developers who maintain the Lua version are the individuals who created PyTorch.</p><p>PyTorch is that it was created and is maintained by Facebook. This is because Soumith Chintala worked at <a href="https://research.fb.com/category/facebook-ai-research/">Facebook AI Research</a> when PyTorch was created (still does at the time of this writing). However, there are many other companies with a vested interest in PyTorch.</p><h2 id="Deep-Learning-With-PyTorch"><a href="#Deep-Learning-With-PyTorch" class="headerlink" title="Deep Learning With PyTorch"></a>Deep Learning With PyTorch</h2><p>PyTorch的包和主要组成：</p><table><thead><tr><th>Package</th><th>Description</th></tr></thead><tbody><tr><td>torch</td><td>PyTorch的顶层包和tensor库</td></tr><tr><td>torch.nn</td><td>包含构建NN的模型和扩展类</td></tr><tr><td>torch.autograd</td><td>PyTorch中支持的Tensor操作</td></tr><tr><td>torch.nn.functional</td><td>包含构建NN的函数接口，像loss function, activation fucntion, convolution operation</td></tr><tr><td>torch.optim</td><td>包含标准的优化，像SGD, Adam</td></tr><tr><td>torch.utils</td><td>包含实用类，像数据集，数据装载器，方便数据预处理</td></tr><tr><td>torchvision</td><td>提供著名的数据集，模型架构和计算机视觉图像转换</td></tr></tbody></table><p><strong>Why use PyTorch for Deep Learning ?</strong></p><ul><li>PyTorch is thin and stays out of the way!</li><li>PyTorch is as close as it gets to the real thing!</li></ul><p><strong>Investing In PyTorch As A Deep Learning Framework</strong></p><p> To optimize neural networks, we need to calculate derivatives, and to do this computationally, deep learning frameworks use what are called <a href="http://colah.github.io/posts/2015-08-Backprop/">computational graphs</a>.</p><p>计算图。</p><p><em>Computational graphs</em> are used to graph the function operations that occur on tensors inside neural networks.</p><p>计算图用来绘制NN中内部张量发生的函数运算。</p><p>These graphs are then used to compute the derivatives needed to optimize the neural network. PyTorch uses a computational graph that is called a dynamic computational graph. This means that the graph is generated on the fly as the operations are created.</p><p>计算图用来计算偏微分优化NN。PyTorch使用的是动态计算图，图是即时创建的。</p><h1 id="CUDA-Explained-Why-Deep-Learning-Uses-GPUs"><a href="#CUDA-Explained-Why-Deep-Learning-Uses-GPUs" class="headerlink" title="CUDA Explained - Why Deep Learning Uses GPUs"></a>CUDA Explained - Why Deep Learning Uses GPUs</h1><p> In this post, we are going to introduce CUDA at a high-level.</p><p>The goal of this post is to help beginners understand what CUDA is and how it fits in with PyTorch, and more importantly, why we even use GPUs in neural network programming anyway.</p><p><strong>Graphics Processing Unit(GPU)</strong></p><p>To understand CUDA, we need to have a working knowledge of <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit">graphics processing units</a> (GPUs). A GPU is a processor that is good at handling <em>specialized</em> computations.</p><p>【GPU擅长处理某种特定的计算】</p><p>This is in contrast to a <a href="https://en.wikipedia.org/wiki/Central_processing_unit">central processing unit</a> (CPU), which is a processor that is good at handling <em>general</em> computations. </p><p>【CPU擅长处理general computations.】</p><p><strong>Parallel Computing</strong></p><p><a href="https://en.wikipedia.org/wiki/Parallel_computing">Parallel computing</a> is a type of computation where by a particular computation is broken into independent smaller computations that can be carried out simultaneously. The resulting computations are then recombined, or synchronized, to form the result of the original larger computation.</p><h2 id="Neural-Networks-Are-Embarrassingly-Parallel"><a href="#Neural-Networks-Are-Embarrassingly-Parallel" class="headerlink" title="Neural Networks Are Embarrassingly Parallel"></a>Neural Networks Are Embarrassingly Parallel</h2><p>In parallel computing, an <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel">embarrassingly parallel</a> task is one where little or no effort is needed to separate the overall task into a set of smaller tasks to be computed in parallel.</p><p>Tasks that embarrassingly parallel are ones where it’s easy to see that the set of smaller tasks are independent with respect to each other.</p><h2 id="Nvidia-Hardware-GPU-And-Software-CUDA"><a href="#Nvidia-Hardware-GPU-And-Software-CUDA" class="headerlink" title="Nvidia Hardware(GPU) And Software(CUDA)"></a>Nvidia Hardware(GPU) And Software(CUDA)</h2><p> <a href="https://en.wikipedia.org/wiki/Nvidia">Nvidia</a> is a technology company that designs GPUs, and they have created CUDA as a software platform that pairs with their GPU hardware making it easier for developers to build software that accelerates computations using the parallel processing power of Nvidia GPUs.</p><p>An Nvidia GPU is the hardware that enables parallel computations, while CUDA is a software layer that provides an API for developers.</p><p>GPU是能平行运算的硬件，而CUDA是为开发者提供的上层API。</p><h2 id="PyTorch-Comes-With-CUDA"><a href="#PyTorch-Comes-With-CUDA" class="headerlink" title="PyTorch Comes With CUDA"></a>PyTorch Comes With CUDA</h2><p>One of the benefits of using PyTorch, or any other neural network API is that parallelism comes baked into the API. This means that as neural network programmers, we can focus more on building neural networks and less on performance issues.</p><p>关注怎么构建NN，而不是一下performance issues.</p><p>Now, if we wanted to work on the PyTorch core development team or write PyTorch extensions, it would probably be useful to know how to use CUDA directly.</p><p>After all, PyTorch is written in all of these:</p><ul><li>Python</li><li>C++</li><li>CUDA</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PyTorch框架学习。&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍PyTorch的相关背景知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://f7ed.com/categories/PyTorch/"/>
    
    
      <category term="open-classes" scheme="https://f7ed.com/tags/open-classes/"/>
    
      <category term="DEEPLIZARD" scheme="https://f7ed.com/tags/DEEPLIZARD/"/>
    
      <category term="PyTorch" scheme="https://f7ed.com/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>「机器学习-李宏毅」:Unsupervised Learning：Word Embedding</title>
    <link href="https://f7ed.com/2020/10/11/unsupervised-learning-word-embedding/"/>
    <id>https://f7ed.com/2020/10/11/unsupervised-learning-word-embedding/</id>
    <published>2020-10-10T16:00:00.000Z</published>
    <updated>2020-10-11T15:33:36.817Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是介绍一种无监督学习——Word Embedding（词嵌入）。</p><p>文章开篇介绍了word编码的1-of-N encoding方式和word class方式，但这两种方式得到的单词向量表示都不能很好表达单词的语义和单词之间的语义联系。</p><p>Word Embedding可以很好的解决这个问题。</p><p>Word Embedding有count based和prediction based两种方法。文章主要介绍了prediction based的方法，包括如何predict the word vector? 为什么这样的模型works？介绍了prediction based的变体；详细阐述了该模型中sharing parameters的做法和其必要性。</p><p>文章最后简单列举了word embedding的相关应用，包括multi-lingual embedding, multi-domain embedding, document embedding 等。</p><a id="more"></a><h1 id="Word-to-Vector"><a href="#Word-to-Vector" class="headerlink" title="Word to Vector"></a>Word to Vector</h1><p>如何把word转换为vector?</p><h2 id="1-of-N-Encoding"><a href="#1-of-N-Encoding" class="headerlink" title="1-of-N Encoding"></a>1-of-N Encoding</h2><p>第一种方法是1-of-N Encoding：</p><p>Vector的维度是单词总数，每一维度都代表一个单词。</p><img src="https://s1.ax1x.com/2020/10/11/0gLLGT.png" alt="0gLLGT.png" style="zoom:25%;" /> <p>1-of-N Encoding的方法简单，但这种向量的表示方式not imformative，即向量表示不能体现单词之间的语义关系。</p><h2 id="Word-Class"><a href="#Word-Class" class="headerlink" title="Word Class"></a>Word Class</h2><p>对1-of-N Encoding方式改进，Word Class采用聚类cluster的方式，根据类别训练一个分类器。</p><img src="https://s1.ax1x.com/2020/10/11/0gLqiV.png" alt="0gLdqiV.png" style="zoom:33%;" /> <p>但这种人为分类的方式，信息是会部分丢失的，即光做clustering是不够的，会丢失单词的部分信息。</p><h2 id="Word-Embedding"><a href="#Word-Embedding" class="headerlink" title="Word Embedding"></a>Word Embedding</h2><p>第三种方式是Word Embedding。（词嵌入）</p><p>Word Embedding: Machine learns the meaning of words from reading a lot of documents without supervision.</p><p>Word Embedding，机器通过阅读大量文章学习单词的含义，用vector的形式表示单词的语义。训练时只需要给机器大量文章，不需要label，因此是无监督学习。</p><h1 id="Word-Embedding-1"><a href="#Word-Embedding-1" class="headerlink" title="Word Embedding"></a>Word Embedding</h1><p>如何做Word Embedding呢？</p><h2 id="auto-encoder？"><a href="#auto-encoder？" class="headerlink" title="auto-encoder？"></a>auto-encoder？</h2><p>能否用auto-encoder的方式来做词嵌入呢？</p><p>即用1-of-N encoding的方式对单词编码，作为训练的输入和输出。</p><p>word2vec时，把model中的某一hidden layer的输出作为该单词的向量表示。</p><p>这种方式是不可以的，不可以用auto-encoder。因为auto-encoder不能学到informative的信息，即用auto-encoder表示的向量不能表达word的语义。</p><h2 id="Exploit-the-Context"><a href="#Exploit-the-Context" class="headerlink" title="Exploit the Context"></a>Exploit the Context</h2><p>A word can be understood by its context.</p><p>所以Word Embedding可以利用上下文来学习word的语义。</p><p>如何利用单词的上下文来学习呢？</p><ul><li><p>Count based</p><p>如果两个单词 $w_i$ 和 $w_j$ 在文章中经常同时出现，那么 $V(w_i)$ ( $w_i$ 的向量表示)和 $V(w_j)$ 的向量表示会很close.</p><p>E.g. Glove Vector: <a href="https://nlp.stanford.edu/projects/glove/">https://nlp.stanford.edu/projects/glove/</a></p><p>GloVe的表示法有两个亮点：</p><ol><li><p>Nearest neighbors：vectors之间的欧几里得距离（或者余弦相似度）能较好表示words之间的语义相似度。</p></li><li><p>Linear substructures：用GloVe方法表示的vectors有有趣的线性子结构。</p><img src="https://s1.ax1x.com/2020/10/11/0gLfxg.png" alt="0gLfxg.png" style="zoom:%;" />  </li></ol></li><li><p>Prediction based</p><p>使用预测的方式来表示。</p></li></ul><h2 id="Prediction-based"><a href="#Prediction-based" class="headerlink" title="Prediction based"></a>Prediction based</h2><h3 id="How-to-predict？"><a href="#How-to-predict？" class="headerlink" title="How to predict？"></a>How to predict？</h3><p>prediction based的方法是用前一个单词来预测当前单词。</p><img src="https://s1.ax1x.com/2020/10/11/0gLHI0.png" alt="0gLHI0.png" style="zoom:25%;" /> <img src="https://s1.ax1x.com/2020/10/11/0gLORU.png" alt="0gLORU.png" style="zoom:33%;" /> <p>训练时： $w_{i-1}$ 的1-of-N encoding编码作为输入，$w_i$ 的1-of-N encoding的编码作为输出。</p><p>NN如上图，$w_{i-1}$ 的1-of-N encoding编码作为输入，输出的vector表示下一个单词是 $w_i$ 的概率。</p><p>word2vec : $w_{i-1}$ 的1-of-N encoding编码作为NN的输入，$w_i$ 的向量表示为第一个hidden layer的neurons的输入 $z$ 。</p><h3 id="Why-it-works"><a href="#Why-it-works" class="headerlink" title="Why it works?"></a>Why it works?</h3><p>直觉的解释他为什么能work。</p><img src="https://s1.ax1x.com/2020/10/11/0gL7aq.png" alt="0gdL7aq.png" style="zoom:33%;" /> <p>如上图，蔡英文 宣誓就职 和 马英九 宣誓就职，虽然 $w_{i-1}$ 不同，但NN的输出中，“宣誓就职”的概率应该最大。</p><p>即hidden layers必须把不同的 $w_{i-1}$ project到相同的space，要求hidden layer的input是相近的，NN的输出才是相近的。</p><h3 id="Prediction-based-：Various-Architecture"><a href="#Prediction-based-：Various-Architecture" class="headerlink" title="Prediction-based ：Various Architecture"></a>Prediction-based ：Various Architecture</h3><p>因为一个单词的下一个单词范围非常大，所以使用前一个单词预测当前单词的方法，performance是较差的。</p><p>因此常常会使用多个单词来预测下一个单词，NN的输入是多个单词连接在一起组成的向量，一般NN的输入至少为10个单词，word embedding的performance较好。</p><p>除了使用多个单词的方法，prediction-based的方法还用两种变体结构。</p><ul><li><p>Continuous bag of word (CBOW) model: predicting the word given its context.</p><p>使用单词的前后文（前一个单词和后一个单词）来预测当前单词。</p><img src="https://s1.ax1x.com/2020/10/11/0gL5rj.png" alt="0gL5drj.png" style="zoom:25%;" /> </li><li><p>Skip-gram: predicting the context given a word.</p><p>使用中间单词来预测单词的前一个单词和后一个单词。</p><img src="https://s1.ax1x.com/2020/10/11/0gLIqs.png" alt="0gLdIqs.png" style="zoom:25%;" />  </li></ul><h3 id="Sharing-Parameters"><a href="#Sharing-Parameters" class="headerlink" title="Sharing Parameters"></a>Sharing Parameters</h3><p>使用多个单词作为NN的输入，提高了word embedding的performance，但也大幅增加了模型训练的参数数量。</p><p>使用sharing parameters（共享参数）能大量减少模型的参数数量。</p><img src="https://s1.ax1x.com/2020/10/11/0gOfFx.png" alt="0gOfFix.png" style="zoom:33%;" /> <p>如上图，输入单词连接到neurons的权重应该是相同的。</p><p>除了能减少参数，sharing parameters也是必要的。否则，如果NN的输入的单词顺序交换，那么得到的单词向量是不同的。</p><p><strong>How to train sharing parameters?</strong> </p><p>假设两个单词相同维度连接到neuron的weight是 $w_i,w_j$ ，在训练中，如何让 $w_i=w_j$ ?</p><ol><li><p>Given the same initialization.(相同的初始化)</p></li><li><p>原来的参数更新：<br>$$<br>w_i \longleftarrow w_i - \frac{\partial C}{\partial w_i} \<br>w_j \longleftarrow w_j - \frac{\partial C}{\partial w_j}<br>$$<br>虽然有相同的初始化，但在Backpropagation求偏微分时，$\frac{\partial C}{\partial w_i}$ 和 $\frac{\partial C}{\partial w_j}$ 不一样，那么参数 $w_i$ 和 $w_j$ 更新一次后就不同了。</p><p>在训练sharing parameters的参数更新：<br>$$<br>w_i \longleftarrow w_i - \frac{\partial C}{\partial w_i} -\frac{\partial C}{\partial w_j}\<br>w_j \longleftarrow w_j - \frac{\partial C}{\partial w_j}-\frac{\partial C}{\partial w_i}<br>$$<br>这样更新后，$w_i$ 和 $w_j$ 仍保持一致。如果有多个单词，亦然。</p></li></ol><hr><p><strong>Word2Vec</strong> </p><p>在word2vec时，根据sharing parameters的性质，计算单词的向量表示时，可以简化运算。</p><img src="https://s1.ax1x.com/2020/10/11/0gLWRS.png" alt="0gLWRS.png" style="zoom:33%;" /> <p>如上图，用前文单词 $x_{i-1},x_{i-2}$  表示单词 $x_i$ 的向量表示 $z=W_1x_{i-2}+W_2x_{i-1}=W(x_{i-2}+x_{i-1})$ .</p><p>其中  $x_{i-1},x_{i-2}$ 的维度是|V|，$x_i$ 的向量表示 $z$ 的维度是 |Z|，$W_1=W_2=W$ 的维度为|Z|*|V|。</p><h1 id="Advantages-of-Word-Embedding"><a href="#Advantages-of-Word-Embedding" class="headerlink" title="Advantages of Word Embedding"></a>Advantages of Word Embedding</h1><p>Word Embedding能得到一些有趣的特性。</p><ul><li><p>向量之间有趣的线性子结构</p><img src="https://s1.ax1x.com/2020/10/11/0gL2Pf.png" alt="0gL2Pf.png" style="zoom:40%;" /> </li><li><p>相近的向量有相近的语义</p><img src="https://s1.ax1x.com/2020/10/11/0gLTZn.png" alt="0gLTZn.png" style="zoom:40%;" /> </li><li><p>向量之间表示的语义特性</p><img src="https://s1.ax1x.com/2020/10/11/0gLRG8.png" alt="0gLRG8.png" style="zoom:35%;" />  </li></ul><h2 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h2><h3 id="Multi-lingual-Embedding：实现翻译"><a href="#Multi-lingual-Embedding：实现翻译" class="headerlink" title="Multi-lingual Embedding：实现翻译"></a>Multi-lingual Embedding：实现翻译</h3><img src="https://s1.ax1x.com/2020/10/11/0gORT1.png" alt="0gORdT1.png" style="zoom:40%;" />  <p>不同语言之间分开训练，训练出的不同语言所对应词汇的向量表示肯定不同，再将对应词汇的向量project到同一点，即实现了翻译。</p><h3 id="Multi-domain-Embedding"><a href="#Multi-domain-Embedding" class="headerlink" title="Multi-domain Embedding"></a>Multi-domain Embedding</h3><p>还可以做影像嵌入。</p><img src="https://s1.ax1x.com/2020/10/11/0gLcIP.png" alt="0gLcIP.png" style="zoom:25%;" /> <h3 id="Document-Embedding：将文件表示为一个向量"><a href="#Document-Embedding：将文件表示为一个向量" class="headerlink" title="Document Embedding：将文件表示为一个向量"></a>Document Embedding：将文件表示为一个向量</h3><ul><li><p>Bag of Word:</p><p>用Bag-of-word的方式编码文件，再实现semantic embedding。得到的文件表示向量可以表示文件的语义主题。</p><img src="https://s1.ax1x.com/2020/10/11/0gLyVI.png" alt="0gLyVI.png" style="zoom:33%;" /> </li><li><p>Beyond Bag of Word:</p><p>句子中单词的顺序也很大程度影响句子的语义。</p><p>因此，下图的两句话有相同的bag-of-word，但表达的含义完全相反。</p><img src="https://s1.ax1x.com/2020/10/11/0gLrqA.png" alt="0gLrqA.png" style="zoom:25%;" /> <p>关于beyond bag of word的相关工作参考reference 2.</p></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><p><a href="https://nlp.stanford.edu/projects/glove/">GloVe: Global Vectors for Word Representation</a> </p></li><li><p>beyond bag of word:</p><img src="https://s1.ax1x.com/2020/10/11/0gL4MQ.png" alt="0gL4MQ.png" style="zoom:33%;"  />    </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是介绍一种无监督学习——Word Embedding（词嵌入）。&lt;/p&gt;
&lt;p&gt;文章开篇介绍了word编码的1-of-N encoding方式和word class方式，但这两种方式得到的单词向量表示都不能很好表达单词的语义和单词之间的语义联系。&lt;/p&gt;
&lt;p&gt;Word Embedding可以很好的解决这个问题。&lt;/p&gt;
&lt;p&gt;Word Embedding有count based和prediction based两种方法。文章主要介绍了prediction based的方法，包括如何predict the word vector? 为什么这样的模型works？介绍了prediction based的变体；详细阐述了该模型中sharing parameters的做法和其必要性。&lt;/p&gt;
&lt;p&gt;文章最后简单列举了word embedding的相关应用，包括multi-lingual embedding, multi-domain embedding, document embedding 等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习-李宏毅" scheme="https://f7ed.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9D%8E%E5%AE%8F%E6%AF%85/"/>
    
    
      <category term="Machine-Learning" scheme="https://f7ed.com/tags/Machine-Learning/"/>
    
      <category term="open-classes" scheme="https://f7ed.com/tags/open-classes/"/>
    
      <category term="Unsupervised-learning" scheme="https://f7ed.com/tags/Unsupervised-learning/"/>
    
      <category term="Word Embedding" scheme="https://f7ed.com/tags/Word-Embedding/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode」：Math</title>
    <link href="https://f7ed.com/2020/10/10/Leetcode-math/"/>
    <id>https://f7ed.com/2020/10/10/Leetcode-math/</id>
    <published>2020-10-09T16:00:00.000Z</published>
    <updated>2020-10-10T10:12:05.425Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode Math 专题记录。</p><p>10月初。</p><p>Albert Einstein:</p><p> “I believe that not everything that can be counted counts, and not everything that counts can be counted”</p><p>「并非所有重要的东西都是可以被计算的，也并不是所有能被计算的东西都那么重要。」</p><a id="more"></a><h2 id="7-Reverse-Integer-E"><a href="#7-Reverse-Integer-E" class="headerlink" title="7. Reverse Integer[E]"></a>7. Reverse Integer[E]</h2><p><a href="https://leetcode.com/problems/reverse-integer/">7. Reverse Integer[E]</a> </p><p>Problem:</p><p>反转32bits的有符号数字，如果反转后会溢出则返回0.</p><p>Solution：</p><p>直观的解决它，先算出反转后的数字，用比较大小来看是否溢出。（最开始还想着转换为bit串来看，就复杂了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        n_min = -(<span class="number">2</span> ** <span class="number">31</span>)</span><br><span class="line">        n_max = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            x = -x</span><br><span class="line">        <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">            r = x % <span class="number">10</span></span><br><span class="line">            s = s * <span class="number">10</span> + r</span><br><span class="line">            x //=<span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            s = -s</span><br><span class="line">        <span class="keyword">if</span> s &lt; n_min <span class="keyword">or</span> s &gt; n_max:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><hr><ul><li><p>十进制转换为二进制、八进制、十六进制：</p><ul><li>二进制：<code>bin(a)</code>  ,也可以直接赋二进制的值<code>0b10101</code> </li><li>八进制：<code>oct(a)</code> ，赋值八进制的值<code>0o263361</code> </li><li>十六进制：<code>hex(a)</code> ,赋值十六进制<code>0x1839ac29</code> </li></ul></li></ul><h2 id="165-Compare-Version-Numbers-M"><a href="#165-Compare-Version-Numbers-M" class="headerlink" title="165. Compare Version Numbers[M]"></a>165. Compare Version Numbers[M]</h2><p><a href="https://leetcode.com/problems/compare-version-numbers/">165. Compare Version Numbers[M]</a> </p><p>Problem：</p><p>比较版本号。</p><p>Solution：</p><p>直观～Easy～</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compareVersion</span><span class="params">(self, version1: str, version2: str)</span> -&gt; int:</span></span><br><span class="line">        li1 = version1.split(<span class="string">'.'</span>)</span><br><span class="line">        li2 = version2.split(<span class="string">'.'</span>)</span><br><span class="line">        n_1 = len(li1)</span><br><span class="line">        n_2 = len(li2)</span><br><span class="line">        n = max(n_1, n_2)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            a = int(li1[i]) <span class="keyword">if</span> i &lt; n_1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            b = int(li2[i]) <span class="keyword">if</span> i &lt; n_2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> a &gt; b:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> a &lt; b:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><ul><li>Python中的强制转换：<ol><li>字符串转换为int : <code>int_value = int(str_value)</code> </li><li>int转换为字符串：<code>str.value = str(int_value)</code> </li><li>int转换为unicode： <code>unicode(int_value)</code> </li><li>unicode转换为int：<code>int(unicode_value)</code> </li><li>字符串转换为unicode：<code>unicode(str_value)</code> </li><li>unicode转换为字符串：<code>str(unicode_value)</code> </li></ol></li><li>Java中的强制转换：<ol><li>字符串String转化为int：<code>int_value = String.parseInt(string_value)</code> 或者 <code>(int)string_value)</code> </li><li>int转化为字符串String：<code>string_value = (String)int_value</code> </li></ol></li></ul><h2 id="66-Plus-One-E"><a href="#66-Plus-One-E" class="headerlink" title="66. Plus One[E]"></a>66. Plus One[E]</h2><p><a href="https://leetcode.com/problems/plus-one/">66. Plus One[E]</a> </p><p>Problem:</p><p>用列表表示一个正数，返回正数+1的列表结果。</p><p>Solution：</p><p>记录一个最高位的进位情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        c_bit = <span class="number">0</span></span><br><span class="line">        n = len(digits)</span><br><span class="line">        i = n - <span class="number">1</span></span><br><span class="line">        digits[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> digits[i] &lt; <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            digits[i] %= <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                c_bit = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[i<span class="number">-1</span>] += <span class="number">1</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c_bit == <span class="number">1</span>:</span><br><span class="line">            digits.insert(<span class="number">0</span>, c_bit)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure><hr><ul><li><p>Python中list添加元素的集中方法：（append(); extend(); insert(); +加号）</p><ol><li><p>append() ：在List尾部追加单个元素，只接受一个参数，参数可以是任意数据类型。</p></li><li><p>extend() ：在list尾部追加一个列表，将该参数列表中的每个元素连接到原列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = [1,2,3]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = [3,4,5]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a.extend(b)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a</span></span><br><span class="line">[1, 2, 3, 3, 4, 5]</span><br></pre></td></tr></table></figure></li><li><p>insert(index, object)：将一个元素插入到列表中，第一个参数是插入的索引点，第二个是插入的元素。</p></li><li><p>+加号：将两个list相加，返回一个新的list对象。</p></li></ol><p>区别：前三种方法(append, extend, insert)可以对列表增加元素，没有返回值，是直接修改原数据对象，而+加号是需要创建新的list对象，需要消耗额外的内存。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode Math 专题记录。&lt;/p&gt;
&lt;p&gt;10月初。&lt;/p&gt;
&lt;p&gt;Albert Einstein:&lt;/p&gt;
&lt;p&gt; “I believe that not everything that can be counted counts, and not everything that counts can be counted”&lt;/p&gt;
&lt;p&gt;「并非所有重要的东西都是可以被计算的，也并不是所有能被计算的东西都那么重要。」&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://f7ed.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://f7ed.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="https://f7ed.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode」：String</title>
    <link href="https://f7ed.com/2020/09/29/LeetCode_String/"/>
    <id>https://f7ed.com/2020/09/29/LeetCode_String/</id>
    <published>2020-09-28T16:00:00.000Z</published>
    <updated>2020-09-29T06:56:50.890Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode String 专题记录。</p><p>9月毕。</p><p>「我祝福你有时有坏运气，你会意识到概率和运气在人生中扮演的角色，并理解你的成功并不完全是你应得的，其他人的失败也并不完全是他们应得的。」</p><p>「不想要刚好错过的悔恨，那就要有完全碾压的实力。」</p><a id="more"></a><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28-Implement strStr()"></a>28-Implement strStr()</h2><p><a href="https://leetcode.com/problems/implement-strstr/solution/">28-Implement strStr()</a> </p><p>Problem:</p><p>返回第一个字串出现的下标</p><p>Solution：</p><p>Python就暴力匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        n1 = len(haystack)</span><br><span class="line">        n2 = len(needle)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n1-n2+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i+n2] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14-Longest Common Prefix"></a>14-Longest Common Prefix</h2><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14-Longest Common Prefix</a></p><p>Problem:</p><p>返回串的公共最长前缀。</p><p>Solution：</p><p>暴力匹配长度就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        LCP = <span class="number">0</span></span><br><span class="line">        n = len(strs)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">                <span class="keyword">if</span> LCP &lt; len(strs[i]) <span class="keyword">and</span> strs[i][LCP] == strs[<span class="number">0</span>][LCP]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>][<span class="number">0</span>: LCP]</span><br><span class="line">            LCP += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58-Length of Last Word"></a>58-Length of Last Word</h2><p><a href="https://leetcode.com/problems/length-of-last-word/">58-Length of Last Word</a> </p><p>Problem:</p><p>单词串由字母和空格组成，返回最后一个单词的长度。</p><p>Solution：</p><p>注意串最后的空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        end = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> end<span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> s[end] == <span class="string">' '</span>:</span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(end, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">' '</span>:</span><br><span class="line">                <span class="keyword">return</span> length</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure><h2 id="58-First-Unique-Character-in-a-String"><a href="#58-First-Unique-Character-in-a-String" class="headerlink" title="58-First Unique Character in a String"></a>58-First Unique Character in a String</h2><p>Problem:</p><p>找第一个没有重复出现的字符下标。</p><p>Solution：</p><p>暴力。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        a_ascii = ord(<span class="string">'a'</span>)</span><br><span class="line">        cnt = [<span class="number">0</span>]*(<span class="number">26</span>+<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            cnt[ord(i)-a_ascii] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> cnt[ord(i)-a_ascii] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> s.index(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><hr><p>寻找子串开始索引：</p><ol><li><strong>str.find(substr, beg=0, end=len(string))</strong> <ul><li>substr: 字串</li><li>beg: 开始索引</li><li>end: 结束索引，默认字符串长度。</li><li>如果字符串不包含子串，则返回<code>-1</code> </li></ul></li><li><strong>str.index(str, beg=0, end=len(string))</strong> <ul><li>和find差不多，如果不包含子串会抛出异常。</li></ul></li></ol><h2 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383-Ransom Note"></a>383-Ransom Note</h2><p><a href="https://leetcode.com/problems/ransom-note/">383-Ransom Note</a> </p><p>Problem:</p><p>给两个字符串，判断串1的字符能否由串2的字符组成。</p><p>Solution：</p><p>字典计数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canConstruct</span><span class="params">(self, ransomNote: str, magazine: str)</span> -&gt; bool:</span></span><br><span class="line">        ransomDir = &#123;&#125;</span><br><span class="line">        magazineDir = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> ransomNote:</span><br><span class="line">            ransomDir.setdefault(ch, <span class="number">0</span>)</span><br><span class="line">            ransomDir[ch] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> magazine:</span><br><span class="line">            magazineDir.setdefault(ch, <span class="number">0</span>)</span><br><span class="line">            magazineDir[ch] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (k, v) <span class="keyword">in</span> ransomDir.items():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> magazineDir:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> ransomDir[k] &gt; magazineDir[k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><ol><li>初始化字典的值：<code>dic.setdefault(ch, 0)</code> </li></ol><h2 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344-Reverse String"></a>344-Reverse String</h2><p><a href="https://leetcode.com/problems/reverse-string/">344-Reverse String</a> </p><p>Problem: </p><p>in-place 反转字符串 with O(1) 的额外空间。</p><p>Solution：</p><p>前后两个指针交换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            s[l], s[r] = s[r], s[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151-Reverse Words in a String"></a>151-Reverse Words in a String</h2><p><a href="https://leetcode.com/problems/reverse-words-in-a-string/">151-Reverse Words in a String</a> </p><p>Problem:</p><p>反转字符串word by word.(结果中单词间只能有一个空格)</p><p>Solution：</p><p>把单词存入列表，再输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        li = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> s[i] == <span class="string">' '</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            l = i</span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> s[i] != <span class="string">' '</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            r = i</span><br><span class="line">            <span class="keyword">if</span> r != l:</span><br><span class="line">                li.append(s[l:r])</span><br><span class="line"></span><br><span class="line">        ans = <span class="string">' '</span>.join(li[<span class="number">-1</span>::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><p><a href="https://segmentfault.com/a/1190000015475309">Python连接字符串总结</a> </p><ol><li>加号连接：<code>&#39;a&#39; + &#39;b&#39;</code> </li><li>逗号连接，只能用于print打印: <code>print(a, b)</code> </li><li>直接连接: <code>print(&#39;a&#39; &#39;b&#39;)</code> </li><li>使用 <code>%</code> 格式化字符串：<code>&#39;%s %s&#39; % (&#39;hello&#39;, &#39;world&#39;)</code> </li><li><code>format</code> 格式化字符串：<code>&#39;{}{}&#39;.format(&#39;hello&#39;, &#39;world&#39;)</code> </li><li><code>join</code> 内置方法：用字符来连接一个序列，数组或列表等：<code>&#39;-&#39;.join([&#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;])</code> </li><li><code>f-string</code> 方法：<code>aa, bb = &#39;hello&#39;, &#39;world&#39;</code> , <code>f&#39;{aa} {bb}&#39;</code> </li><li><code>*</code> 操作符：字符串乘法。</li></ol><p>反转列表：<code>[-1: : -1]</code> </p><h2 id="186-Reverse-Words-in-a-String-II"><a href="#186-Reverse-Words-in-a-String-II" class="headerlink" title="186-Reverse Words in a String II"></a>186-Reverse Words in a String II</h2><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-ii/">186-Reverse Words in a String II</a> </p><p>Problem:</p><p>反转单词in-places.</p><p>Solution:</p><p>两次反转，第一次整体反转，第二次再单词反转。</p><p>（不额外开个数组来逐个赋值AC不了，不知道为啥q w q)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: List[str])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        temp = s[<span class="number">-1</span>::<span class="number">-1</span>]</span><br><span class="line">        n = len(temp)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            l = i</span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> temp[i] != <span class="string">' '</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            r = i</span><br><span class="line">            temp[l:r] = list(reversed(temp[l:r]))</span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(n):</span><br><span class="line">            s[index] = temp[index]</span><br></pre></td></tr></table></figure><hr><ul><li><p>Python 反转列表的方法：</p><ol><li><code>list(reversed(a))</code> , reversed(a)返回的是迭代器，转换成list。</li><li><code>a[::-1]</code> </li></ol></li><li><p>Python 字符串(str)和列表(list)互相转换：</p><ol><li><p>str 转换为 list</p><ul><li><code>list()</code> 转换为单个字符列表</li><li><code>str.split()</code> 或者<code>str.split(&#39; &#39;)</code> 空格分割转换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">"123"</span></span><br><span class="line">list1 = list(str1)</span><br><span class="line"><span class="keyword">print</span> list1</span><br><span class="line"><span class="comment"># ['1', '2', '3']</span></span><br><span class="line"></span><br><span class="line">str2 = <span class="string">"123 sjhid dhi"</span></span><br><span class="line">list2 = str2.split() <span class="comment">#or list2 = str2.split(" ")</span></span><br><span class="line"><span class="keyword">print</span> list2</span><br><span class="line"><span class="comment"># ['123', 'sjhid', 'dhi']</span></span><br><span class="line"></span><br><span class="line">str3 = <span class="string">"www.google.com"</span></span><br><span class="line">list3 = str3.split(<span class="string">"."</span>)</span><br><span class="line"><span class="keyword">print</span> list3</span><br><span class="line"><span class="comment"># ['www', 'google', 'com']</span></span><br></pre></td></tr></table></figure></li><li><p>list转换为str:</p><ul><li><code>&quot;&quot;.join(list)</code> 无空格连接</li><li><code>&quot;.&quot;.join(list)</code>  </li></ul></li></ol></li></ul><h2 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345-Reverse Vowels of a String"></a>345-Reverse Vowels of a String</h2><p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/">345-Reverse Vowels of a String</a> </p><p>Problem:</p><p>反转字符串中的元音字母。</p><p>Solution：</p><p>元音字母，包括大写元音字母和小写元音字母。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        s = list(s)</span><br><span class="line">        dic = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'i'</span>: <span class="number">1</span>, <span class="string">'o'</span>: <span class="number">1</span>, <span class="string">'u'</span>: <span class="number">1</span>&#125;</span><br><span class="line">        rev = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> s[index] <span class="keyword">in</span> dic <span class="keyword">or</span> s[index].lower() <span class="keyword">in</span> dic:</span><br><span class="line">                rev[index] = <span class="number">1</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> rev[l] == <span class="number">0</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> rev[r] == <span class="number">0</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            s[l], s[r] = s[r], s[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></table></figure><hr><ul><li><p>Python大小写转换：</p><ul><li>所有字符转换为大写：<code>str.upper()</code> </li><li>所有字符转换为小写：<code>str.lower()</code> </li><li>第一个字母转换为大写字母，其余小写：<code>str.capitalize()</code> </li><li>把每个单词的第一个字母转换为大写，其余小写。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"www.runoob.com"</span></span><br><span class="line">print(str.upper())          <span class="comment"># 把所有字符中的小写字母转换成大写字母</span></span><br><span class="line">print(str.lower())          <span class="comment"># 把所有字符中的大写字母转换成小写字母</span></span><br><span class="line">print(str.capitalize())     <span class="comment"># 把第一个字母转化为大写字母，其余小写</span></span><br><span class="line">print(str.title())          <span class="comment"># 把每个单词的第一个字母转化为大写，其余小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WWW.RUNOOB.COM</span></span><br><span class="line"><span class="comment"># www.runoob.com</span></span><br><span class="line"><span class="comment"># Www.runoob.com</span></span><br><span class="line"><span class="comment"># Www.Runoob.Com</span></span><br></pre></td></tr></table></figure></li><li><p>Python中string是不可变对象，不能通过下标的方式（如<code>str[0]=&#39;a&#39;</code> )改变字符串。</p></li></ul><h2 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="205-Isomorphic Strings"></a>205-Isomorphic Strings</h2><p><a href="https://leetcode.com/problems/isomorphic-strings/">205-Isomorphic Strings</a> </p><p>Problem:</p><p>判断是否同构字符串。</p><p>Solution：</p><p>字符到字符的映射，必须是单射。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        vSet = set()  <span class="comment"># satisfy single map</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(n):</span><br><span class="line">            ch = s[idx]</span><br><span class="line">            <span class="comment"># single map</span></span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> dic <span class="keyword">and</span> t[idx] <span class="keyword">not</span> <span class="keyword">in</span> vSet:</span><br><span class="line">                dic[ch] = t[idx]</span><br><span class="line">                vSet.add(t[idx])</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> dic <span class="keyword">and</span> dic[ch] == t[idx]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><ul><li><p>Python 集合的操作：</p><ol><li><p>创建空集合：<code>set()</code> </p></li><li><p>创建有初值的集合：<code>SET = {v0, v1, v2}</code> 或者<code>SET = set(v0)</code> </p></li><li><p>判断元素是否在集合中：<code>x in SET</code> </p></li><li><p>集合运算：</p><p><code>a-b</code> :属于a集合不属于b集合</p><p><code>a|b</code> :属于a集合或属于b集合</p><p><code>a&amp;b</code> :集合a和集合b都包含的元素</p><p><code>a^b</code> : 不同时包含于集合a和集合b的元素</p></li><li><p>集合中添加元素：<code>s.add(x)</code> </p></li><li><p>集合中添加元素，且参数可以是列表、元组、字典(是每个元素都添加进去）等：<code>s.update(x)</code> </p></li><li><p>移除元素：<code>s.remove(x)</code> ，如果元素不存在，则会发生错误。</p></li><li><p>移除元素：<code>s.discard(x)</code> ，如果元素不存在，不会发生错误。</p></li><li><p>随机删除集合中的一个元素：<code>s.pop()</code> （原理：对集合无序排序，然后删除无序排列集合的第一个）</p></li><li><p>计算集合元素的个数：<code>len(s)</code> </p></li><li><p>清空集合<code>s.clear()</code> </p></li></ol></li><li><p>List Comprehension &amp;&amp; Set Comprehension &amp;&amp; Dictionary Comprehension</p><p>这个相当于数学中的 $S={2\cdot x\mid x\in \left[0,9\right)}$ 的表达。</p><ol><li><p>List Comprehension</p><p>如果用数学中的这个表达来看下面的式子，就很显而易见了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><p>再看看加了其他限制的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># filter the elements</span></span><br><span class="line">arr1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x % <span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># add more conditions</span></span><br><span class="line">arr2 = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt;= <span class="number">3</span> <span class="keyword">and</span> x % <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># use nested for loops</span></span><br><span class="line">arr3 = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br></pre></td></tr></table></figure><p>使用List Comprehension不仅优美，而且效率也会很高。</p></li><li><p>Set Comprehension</p><p>同样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>) <span class="keyword">if</span> x%<span class="number">2</span> != <span class="number">0</span> <span class="keyword">and</span> x%<span class="number">3</span> != <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>Dictionary Comprehension</p><p>Syntax：<code>{expression(variable): expression(variable) for variable, variable in input_set [predicate][, …]}</code>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [(set_k), (set_v)]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)]&#125;</span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;n: n <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>)&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;chr(n): n <span class="keyword">for</span> n <span class="keyword">in</span> (<span class="number">65</span>, <span class="number">66</span>, <span class="number">66</span>)&#125;</span><br><span class="line">&#123;<span class="string">'A'</span>: <span class="number">65</span>, <span class="string">'B'</span>: <span class="number">66</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ((k1, v1), (k2, v2))</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> ((<span class="string">'I'</span>, <span class="number">1</span>), (<span class="string">'II'</span>, <span class="number">2</span>))&#125;</span><br><span class="line">&#123;<span class="string">'I'</span>: <span class="number">1</span>, <span class="string">'II'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> ((<span class="string">'a'</span>, <span class="number">0</span>), (<span class="string">'b'</span>, <span class="number">1</span>)) <span class="keyword">if</span> v == <span class="number">1</span>&#125;</span><br><span class="line">&#123;<span class="string">'b'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="68-Text-Justification"><a href="#68-Text-Justification" class="headerlink" title="68-Text Justification"></a>68-Text Justification</h2><p><a href="https://leetcode.com/problems/text-justification/">68-Text Justification</a> </p><p>Problem:</p><p>文本对齐，总结下来有以下几点要求。</p><ul><li>如果不是最后一行，且该行不止一个单词，则要求左右对齐。<ul><li>左右对齐：尽可能让单词间的空格均匀分布，如果不能均匀分布，则单词左边的空格应该比右边的空格多。</li><li>贪心的思想：应该尽可能的多放单词。</li></ul></li><li>如果是最后一行，或者该行只有一个单词，则要求左对齐。</li></ul><p>Solution：</p><p>分两种情况处理，判断是左对齐，还是右对齐。</p><ol><li><p>左对齐：该行有x个单词</p><p>前x-1个单词的后面都应该只有一个空格。</p><p>最后一个单词后面就应该补齐所有空格。</p></li><li><p>左右对齐：该行有x个单词，有x-1个空格间隙。</p><p>计算得到该行的空格数w，则如果能均匀分配，则每个间隙应该有aver = w // (x-1) 个空格。</p><p>但也许不会均匀分配，因此，可能会多出m个空格（m &lt; x-1 )</p><p>即前m个单词，单词的后面应该有（aver+1)个空格，后面的(x-1) - m个单词应该有aver个空格。</p><p>最后一个单词的后面没有空格。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.words = <span class="literal">None</span></span><br><span class="line">        self.maxWidth = <span class="literal">None</span></span><br><span class="line">        self.sum = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leftJustify</span><span class="params">(self, l: int, r: int)</span> -&gt; str:</span></span><br><span class="line">        wordsNum = r - l + <span class="number">1</span></span><br><span class="line">        lengthNum = self.sum[r] <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">else</span> self.sum[r] - self.sum[l - <span class="number">1</span>]</span><br><span class="line">        spaceNum = self.maxWidth - lengthNum</span><br><span class="line">        temp = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):</span><br><span class="line">            temp += self.words[i] + <span class="string">" "</span></span><br><span class="line">        temp += self.words[r] + <span class="string">" "</span>*(spaceNum - (wordsNum - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leftRightJustify</span><span class="params">(self, l: int, r: int)</span> -&gt; str:</span></span><br><span class="line">        wordsNum = r - l + <span class="number">1</span></span><br><span class="line">        lengthNum = self.sum[r] <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">else</span> self.sum[r] - self.sum[l - <span class="number">1</span>]</span><br><span class="line">        spaceNum = self.maxWidth - lengthNum</span><br><span class="line">        temp = <span class="string">""</span></span><br><span class="line">        averSpace = spaceNum // (wordsNum - <span class="number">1</span>)</span><br><span class="line">        moreSpace = spaceNum - averSpace*(wordsNum - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(moreSpace):</span><br><span class="line">            temp += self.words[l+i] + <span class="string">" "</span> * (averSpace + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l+moreSpace, r):</span><br><span class="line">            temp += self.words[i] + <span class="string">" "</span> * averSpace</span><br><span class="line">        temp += self.words[r]</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words: List[str], maxWidth: int)</span> -&gt; List[str]:</span></span><br><span class="line">        self.words = words</span><br><span class="line">        self.maxWidth = maxWidth</span><br><span class="line">        n = len(words)</span><br><span class="line">        sum = [<span class="number">0</span>]*n</span><br><span class="line">        sum[<span class="number">0</span>] = len(words[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># sum prefix length of words</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + len(words[i])</span><br><span class="line">        self.sum = sum</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> l &lt; n:</span><br><span class="line">            r = l</span><br><span class="line">            lengthNum = len(self.words[l])</span><br><span class="line">            <span class="keyword">while</span> r+<span class="number">1</span> &lt; n <span class="keyword">and</span> lengthNum + len(self.words[r+<span class="number">1</span>]) + <span class="number">1</span> &lt;= maxWidth:</span><br><span class="line">                lengthNum += len(self.words[r+<span class="number">1</span>]) + <span class="number">1</span>  <span class="comment"># space</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="comment"># only one word or the last line</span></span><br><span class="line">            <span class="keyword">if</span> r - l + <span class="number">1</span> == <span class="number">1</span> <span class="keyword">or</span> r == n - <span class="number">1</span>:</span><br><span class="line">                ans.append(self.leftJustify(l, r))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(self.leftRightJustify(l, r))</span><br><span class="line">            l = r + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><ul><li><p>Python的三元运算符：</p><p>#如果条件为真，返回真 否则返回假<br>condition_is_true if condition else condition_is_false</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_fat = <span class="literal">True</span></span><br><span class="line">state = <span class="string">"fat"</span> <span class="keyword">if</span> is_fat <span class="keyword">else</span> <span class="string">"not fat"</span></span><br></pre></td></tr></table></figure></li><li><p>Python的整除是：<code>\\</code> ，实数除是：<code>\</code> </p></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>Python中字符串的连接方法总结： <a href="https://segmentfault.com/a/1190000015475309">https://segmentfault.com/a/1190000015475309</a></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode String 专题记录。&lt;/p&gt;
&lt;p&gt;9月毕。&lt;/p&gt;
&lt;p&gt;「我祝福你有时有坏运气，你会意识到概率和运气在人生中扮演的角色，并理解你的成功并不完全是你应得的，其他人的失败也并不完全是他们应得的。」&lt;/p&gt;
&lt;p&gt;「不想要刚好错过的悔恨，那就要有完全碾压的实力。」&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://f7ed.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://f7ed.com/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="https://f7ed.com/tags/Algorithms/"/>
    
      <category term="String" scheme="https://f7ed.com/tags/String/"/>
    
      <category term="Data-Structure" scheme="https://f7ed.com/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode」：Array</title>
    <link href="https://f7ed.com/2020/09/15/LeetCode_array/"/>
    <id>https://f7ed.com/2020/09/15/LeetCode_array/</id>
    <published>2020-09-14T16:00:00.000Z</published>
    <updated>2020-10-09T13:24:32.989Z</updated>
    
    <content type="html"><![CDATA[<p>8月某司实训+准备开学期末考，我可太咕了q w q…dbq，（希望）高产博主我.我..又回来了。</p><p>LeetCode Array专题，持久更新。（<a href="https://github.com/f1ed/LeetCode">GitHub</a>)</p><a id="more"></a><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><h2 id="27-Remove-Elements"><a href="#27-Remove-Elements" class="headerlink" title="27-Remove Elements"></a>27-Remove Elements</h2><p><a href="https://leetcode.com/problems/remove-element/">27-Remove Elements</a> </p><p>Solution</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        tot = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> element == val:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[tot] = element</span><br><span class="line">                tot = tot + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure><ol><li><p>Python的参数传递和函数返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums:List[int], val:int)</span> -&gt; int:</span></span><br></pre></td></tr></table></figure></li><li><p>题目要求：</p><p>“remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> and return the new length.”</p><p>“Do not allocate extra space for another array, you must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.”</p><p>“Confused why the returned value is an integer but your answer is an array?</p><p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.”</p><p>题目要求是在原数组上删除数值，不能额外开新的空间存储数组。</p><p>意思就是说，虽然函数返回的是一个数值，但实际返回答案是一个数组。</p><p>因为数组的传递是指针传递，返回的是数组长度，则相当于返回了这个in-place的新数组。</p></li></ol><h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26-Remove Duplicates from Sorted Array"></a>26-Remove Duplicates from Sorted Array</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26-Remove Duplicates from Sorted Array</a> </p><p>Solution：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        tot = <span class="number">0</span></span><br><span class="line">        before = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[index] != before:</span><br><span class="line">                nums[tot] = nums[index]</span><br><span class="line">                before = nums[index]</span><br><span class="line">                tot = tot + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure><hr><ol><li><p>第一次提交的时候<code>before = nums[0] - 1</code> 报错了，原因是传入数组长度为0，下标越界。</p><p>注意空数组的下标越界问题。</p></li></ol><h2 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80-Remove Duplicates from Sorted Array II"></a>80-Remove Duplicates from Sorted Array II</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">80-Remove Duplicates from Sorted Array II</a> </p><p>Solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        before = <span class="literal">None</span></span><br><span class="line">        before_cnt = <span class="number">0</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[index] != before:</span><br><span class="line">                nums[length] = nums[index]</span><br><span class="line">                before = nums[index]</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">                before_cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                before_cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> before_cnt &lt;= <span class="number">2</span>:</span><br><span class="line">                    nums[length] = nums[index]</span><br><span class="line">                    length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure><h2 id="189-Rotate-Array（S123）"><a href="#189-Rotate-Array（S123）" class="headerlink" title="189-Rotate Array（S123）"></a>189-Rotate Array（S123）</h2><p><a href="https://leetcode.com/problems/rotate-array/">189-Rotate Array</a> </p><p>Problem:</p><p>简述题目大意，给一个列表nums，一个 $k$ 值，要求原址让列表循环右移 $k$ 位。</p><p>Solution:</p><p>其实以下三种做法时间空间复杂度差别不大，主要看个思路吧。</p><table><thead><tr><th>S</th><th>Runtime</th><th>Memory</th><th align="center">Language</th></tr></thead><tbody><tr><td>S1</td><td>64ms</td><td>15.2MB</td><td align="center">pyhon3</td></tr><tr><td>S2</td><td>64ms</td><td>15.1MB</td><td align="center">python3</td></tr><tr><td>S3</td><td>116ms</td><td>15.1MB</td><td align="center">python3</td></tr></tbody></table><h3 id="S1-简单做法：空间换时间"><a href="#S1-简单做法：空间换时间" class="headerlink" title="S1-简单做法：空间换时间"></a>S1-简单做法：空间换时间</h3><p>时间复杂度：$\mathcal{O}(n)$ </p><p>空间复杂度：$\mathcal{O}(n)$ ，循环右移时多开了一个数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        a = [<span class="number">0</span>] * length</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(length):</span><br><span class="line">            a[(index + k)%length] = nums[index]</span><br><span class="line">        nums[:] = a</span><br></pre></td></tr></table></figure><h3 id="S2-利用数学同余关系"><a href="#S2-利用数学同余关系" class="headerlink" title="S2-利用数学同余关系"></a>S2-利用数学同余关系</h3><p>时间复杂度：$\mathcal{O}(n)$ </p><p>空间复杂度：$\mathcal{O}(n)$ ，循环右移时只多开了一个变量。</p><p>原理：</p><blockquote><p>定理[1]：</p><p>设 $m$ 是正整数，整数 $a$ 满足 $(a,m)=1$ ，$b$ 是任意整数。若 $x$ 遍历模 $m$ 的一个完全剩余系，则 $ax+b$ 也遍历模 $m$ 的一个完全剩余系。</p></blockquote><p>由以上定理可以得知，设 $n$ 为列表长度， $x$ 是列表的下标，遍历 $n$ 的一个完全剩余系。</p><ul><li><p>如果 $(k,n)=1$ ， $kx$ 也遍历 $n$ 的一个完全剩余系。这种情况，列表下标通过 $k$ 的倍数的顺序连成一个环。</p><p>：只需要额外一个变量 $temp$ 存储移动占用的值。</p></li><li><p>如果 $(k,n)\neq 1$ ，那么 $kx$ 不会遍历一个 $n$ 的完全剩余系，会出现下图的情况（如绿色的线的元素的 $idx = kx+0$ ，红色线的元素都是 $idx=kx+1$ ），会在 $k$ 的某个剩余类一直循环。</p><p>：遍历每个 $k$ 的剩余类。 在每次循环移位时，需要记录该次循环的起始位，防止重复。</p><img src="https://s1.ax1x.com/2020/09/14/wrcSVs.png" alt="wrcSVs.png" style="zoom:50%;" /></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        k %= length</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cnt &lt; length:</span><br><span class="line">            current, prev = start, nums[start]</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                current = (current + k) % length</span><br><span class="line">                prev, nums[current] = nums[current], prev</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> current == start:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            start += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="S3-利用反转列表的思路"><a href="#S3-利用反转列表的思路" class="headerlink" title="S3-利用反转列表的思路"></a>S3-利用反转列表的思路</h3><p>时间复杂度：$\mathcal{O}(n)$ </p><p>空间复杂度：$\mathcal{O}(n)$ </p><p>原理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Original List                   : 1 2 3 4 5 6 7</span><br><span class="line">After reversing all numbers     : 7 6 5 4 3 2 1</span><br><span class="line">After reversing first k numbers : 5 6 7 4 3 2 1</span><br><span class="line">After revering last n-k numbers : 5 6 7 1 2 3 4 --&gt; Result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Solution 3: Reverse</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums: list, begin: int, end: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> begin &lt; end:</span><br><span class="line">            nums[begin], nums[end] = nums[end], nums[begin]</span><br><span class="line">            begin += <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k %= n</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, k<span class="number">-1</span>)</span><br><span class="line">        self.reverse(nums, k, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><hr><ol><li><p>Python用引用管理对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = <span class="number">1</span>, *p = &amp;a1;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">2</span>, &amp;b = a2;</span><br></pre></td></tr></table></figure><ul><li>指针：指针变量是一个新变量，这个变量存储的是（变量a1的）地址，该地址指向一个存储单元。（该存储单元存放的是a1的值）。</li><li>引用：引用的实质是变量的别名，所以a2和b实际是一个东西，在内存中占有同一个存储单元。</li></ul><p>所以python中交换对象可以直接<code>a,b = b,a</code> </p></li><li><p>Python 列表的操作：切片。</p></li></ol><h2 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41-First Missing Positive"></a>41-First Missing Positive</h2><p><a href="https://leetcode.com/problems/first-missing-positive/">41-First Missing Positive</a>  </p><p>Solution:</p><p>排一下序，维护一个expect变量就行了。</p><p>时间复杂度：$\mathcal{O}(n\log{n})$ ，题目没有卡常。</p><p>Runtime: 36 ms, faster than 70.96% of Python3 online submissions for First Missing Positive.</p><p>空间复杂度：$\mathcal{O}(n)$</p><p>Memory Usage: 13.8 MB, less than 69.19% of Python3 online submissions for First Missing Positive. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        expect = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> element == expect:</span><br><span class="line">                expect += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> element &gt; expect:</span><br><span class="line">                <span class="keyword">return</span> expect</span><br><span class="line">        <span class="keyword">return</span> expect</span><br></pre></td></tr></table></figure><h2 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="299-Bulls and Cows"></a>299-Bulls and Cows</h2><p><a href="https://leetcode.com/problems/bulls-and-cows/">299-Bulls and Cows</a> </p><p>Problem:</p><p>题目大意是：给定两个相同长度的字符串，计算这两个字符串有多少个对应位数字相同，和多少个位置不对应但数字相同的个数。</p><p>Solution:</p><p>应用字符0-9本身数字的性质。</p><p>时间复杂度：$\mathcal{O}(n)$ </p><p>空间复杂度：$\mathcal{O}(n)$ </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHint</span><span class="params">(self, secret: str, guess: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 0-9 cnt for guess (expect the same digit)</span></span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line">        bulls = cows = <span class="number">0</span></span><br><span class="line">        g = <span class="keyword">lambda</span> a: ord(a) - ord(<span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">for</span> si, gi <span class="keyword">in</span> zip(secret, guess):</span><br><span class="line">            <span class="keyword">if</span> si == gi:</span><br><span class="line">                bulls += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt[g(gi)] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> si, gi <span class="keyword">in</span> zip(secret, guess):</span><br><span class="line">            <span class="keyword">if</span> si == gi:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> cnt[g(si)] &gt; <span class="number">0</span>:</span><br><span class="line">                cows += <span class="number">1</span></span><br><span class="line">                cnt[g(si)] -= <span class="number">1</span></span><br><span class="line">        output = <span class="string">"&#123;&#125;A&#123;&#125;B"</span>.format(bulls, cows)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><hr><ol><li><p>ord()函数和chr()函数</p><p>ord()返回字符的ASCII码，chr函数返回ASCII码对应的字符。</p></li><li><p>浅析lambda表达式，匿名函数，类似于C语言的宏。</p><p>格式：<code>lambda [arg1[, arg2,...]] : expression</code> </p></li><li><p>双变量同时遍历使用zip()函数</p></li></ol><h2 id="134-Gas-Station（S12）"><a href="#134-Gas-Station（S12）" class="headerlink" title="134-Gas Station（S12）"></a>134-Gas Station（S12）</h2><p><a href="https://leetcode.com/problems/gas-station/">134-Gas Station</a> </p><p>Problem：</p><p>题目大意是：有N个环形加油站，每个加油站能加油gas[i]，一个汽车起始油量为0，且从i个站开到第i+1个站需要花费cost[i]的油量。找出这个车能顺时针跑完一圈的起始点（如果有，则唯一），如果不能返回-1。</p><p>Solution：</p><table><thead><tr><th>Solution</th><th>Runtime</th><th>Memory</th><th>Language</th></tr></thead><tbody><tr><td>S1-简单做法</td><td>3244ms</td><td>14.9MB</td><td>python3</td></tr><tr><td>S2-原理优化</td><td>104ms</td><td>14.8MB</td><td>python3</td></tr></tbody></table><h3 id="S1-简单解法"><a href="#S1-简单解法" class="headerlink" title="S1-简单解法"></a>S1-简单解法</h3><p>时间复杂度：$\mathcal{O}(n^2)$ ，实际远达不到 $n^2$ ，算有一点贪心叭。</p><p>空间复杂度：$\mathcal{O}(n)$ </p><p>该汽车从起点i能跑完的必要条件：</p><ul><li><p>起始点 <code>gas[i] - cost[i] &gt;= 0</code> 。并且维护一个数组存放 <code>gas[i] - cost[i]</code> ，即这个站自给自足的油量余量。</p></li><li><p>如果从满足条件1的起点开始跑一圈， 要求路程中的油量必须大于等于0。维护一个汽车当前总油量 $S$ （用前缀和维护），每跑过一段路程，都要求 $S&gt;=0$ 。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(gas)</span><br><span class="line">        remain = []</span><br><span class="line">        <span class="keyword">for</span> g, c <span class="keyword">in</span> zip(gas, cost):</span><br><span class="line">            remain.append(g - c)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> remain[i] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                S = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    S += remain[(i + j) % n]</span><br><span class="line">                    <span class="keyword">if</span> S &lt; <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> S &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="S2-对问题分析进行再简化"><a href="#S2-对问题分析进行再简化" class="headerlink" title="S2-对问题分析进行再简化"></a>S2-对问题分析进行再简化</h3><p>时间复杂度：$\mathcal{O}(n)$ </p><p>空间复杂度：$\mathcal{O}(n)$ </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  i: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">g[i]: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">c[i]: <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">g-c :<span class="number">-2</span><span class="number">-2</span><span class="number">-2</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">sum :<span class="number">-2</span><span class="number">-4</span><span class="number">-6</span><span class="number">-3</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><p>如果 $S=\sum_{i=0}^{n-1} g[i]-c[i],S&lt;0$  那么一定无解， $S$ 称为总积累油量。</p></li><li><p>如果 $S&gt;=0$，如果有找出最优解的方法，则一定有解。</p><ol><li><p>起点满足 $g[i]-c[i]&gt;=0$ ，把这些点称为正余量点。</p></li><li><p>用 $\mathcal{O}(1)$ 算出从第 $i$ 个点出发到第 $n$ （n就是第0个点） 个点所积累的油量： $res[i] =S-sum[i-1]$ .即用总积累油量减去前 $i-1$ 段路程能积累的油量（一般积累为负）。(sum数组就是 g-c的前缀和)</p></li><li><p>对于满足起点要求 $g[i]-c[i]&gt;=0$ 的所有点，计算从第 $i$ 个点出发到第 $n$ 个点到油量积累。那么有最大油量积累的点即为最优起始点。（题目规定如果存在，则点唯一）</p></li><li><p>因此，因为 $S$ 固定，只需要找到 $sum$ 数组中的最小值的下标，下标+1即是结果。</p></li></ol><ul><li>证明其正确性：<ol><li>如果满足 $g[i]-c[i]&gt;=0$ 的上述点 $i,j（i&lt;j)$  ，如果 $res[i]&gt;=res[j]$ ，说明从 $i$ 到 $j$ 是正油量积累，贪心的思想，那肯定积累的油量越多越好， $i$ 比 $j$ 优。</li><li>如果 $res[i]&lt;=res[j]$ ，说明从 $i$ 到 $j$ 是负油量积累，如果从 $i$ 点出发，到 $j$ 点就负油量了；如果从 $j$ 点出发，该车最后再跑 $i$ 到$j$  段，因为保证了总积累油量是正，所以最后一定有足够的油量能跑完 $i$ 到 $j$ 段。</li><li>再证只要 $S&gt;=0$ 则一定有解。是动态尝试起始点，( $i,j$ 都满足 $g[i]-c[i]&gt;=0$ ）从点 $i$ 开始，跑到点 $j$ 时，如果该途中途有出现油量不够，那就把 $i$ 到 $j$ 的这段路程放到路途的后面来跑，等油量积累够了再跑这段。</li></ol></li></ul></li></ul><p>Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas: List[int], cost: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(gas)</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        remain = []</span><br><span class="line">        <span class="keyword">for</span> g, c <span class="keyword">in</span> zip(gas, cost):</span><br><span class="line">            remain.append(g - c)</span><br><span class="line">            sum += g - c</span><br><span class="line">        <span class="keyword">if</span> sum &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            remain[i] += remain[i - <span class="number">1</span>]</span><br><span class="line">        min_idx = remain.index(min(remain))</span><br><span class="line">        <span class="keyword">return</span> (min_idx + <span class="number">1</span>) % n</span><br></pre></td></tr></table></figure><hr><ol><li>前缀和</li><li><code>list.index(value)</code> 找出list中值为<code>value</code> 的第一个下标。</li><li><code>min(list)</code> 返回list中的最小值。</li></ol><h2 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118-Pascal’s Triangle"></a>118-Pascal’s Triangle</h2><p><a href="https://leetcode.com/problems/pascals-triangle/submissions/">118-Pascal’s Triangle</a> </p><p>Problem:</p><p>给定一个数字，输出如下规则的值。</p><img src="https://s1.ax1x.com/2020/09/15/wyWI9s.gif" alt="wyWI9s.gif" style="zoom:50%;" />   <p>Solution：</p><p>注意边界吧。（不太喜欢这种题qwq</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, numRows):</span><br><span class="line">            temp = [<span class="number">1</span>] * (i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">                temp[j] = ans[i<span class="number">-1</span>][j<span class="number">-1</span>] + ans[i<span class="number">-1</span>][j]</span><br><span class="line">            ans.append(temp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><ol><li><p>Python 中的append会出现值被覆盖的情况：变量在循环外定义，但在循环中对该变量做出一定改变，然后append到列表，最后发现列表中的值都是一样的。</p><p>因为Python中很多时候都是以对象的形式管理对象，因此append给列表的是一个地址。</p></li></ol><h2 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119-Pascal’s Triangle II"></a>119-Pascal’s Triangle II</h2><p><a href="https://leetcode.com/problems/pascals-triangle-ii/">119-Pascal’s Triangle II</a> </p><p>Problem：</p><p>给定一个数字，输出某一行。</p><p>Solution：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex: int)</span> -&gt; List[int]:</span></span><br><span class="line">        temp = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, rowIndex):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                temp[j] += temp[j<span class="number">-1</span>]</span><br><span class="line">            temp.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure><h2 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169-Majority Element"></a>169-Majority Element</h2><p><a href="https://leetcode.com/problems/majority-element/">169-Majority Element</a> </p><p>Problem:</p><p>给一串数字，找到出现次数大于 <code>n/2</code> 的数字。</p><p>Solution：</p><p>用字典计数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        cnt = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> ele <span class="keyword">in</span> cnt:</span><br><span class="line">                cnt[ele] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt[ele] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(cnt, key=cnt.get)</span><br></pre></td></tr></table></figure><hr><ol><li>返回值最大/最小的键/索引。<ul><li>列表：<ul><li>最大值的索引：list.index(max(list))</li><li>最小值的索引：list.index(min(list))</li></ul></li><li>字典：<ul><li>最大值的键：max(dict, key=dict.get)</li><li>最小值的键：min(dict, key=dict.get)</li></ul></li></ul></li></ol><h2 id="229-Majority-Element-II"><a href="#229-Majority-Element-II" class="headerlink" title="229-Majority Element II"></a>229-Majority Element II</h2><p><a href="https://leetcode.com/problems/majority-element-ii/">229-Majority Element II</a> </p><p>Problem: </p><p>给一串数字，返回出现次数大于 <code>n/3</code> 的数字。</p><p>Solution：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        cnt = &#123;&#125;</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> ele <span class="keyword">in</span> cnt:</span><br><span class="line">                cnt[ele] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt[ele] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> (k, v) <span class="keyword">in</span> cnt.items():</span><br><span class="line">            <span class="keyword">if</span> v &gt; n/<span class="number">3</span>:</span><br><span class="line">                ans.append(k)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><ol><li><p>字典的实用方法：</p><table><thead><tr><th>操作</th><th>实现方法</th></tr></thead><tbody><tr><td>删除字典元素</td><td><code>del dict[&#39;Name&#39;]</code></td></tr><tr><td>清空字典所有条目</td><td><code>dict.clear()</code></td></tr><tr><td>删除字典</td><td><code>del dict</code></td></tr><tr><td>返回指定键的值，如果值不存在返回default的值</td><td><code>dict.get(key, default)</code></td></tr><tr><td>如果键不存在字典中，添加键并将值设为default,于get类似</td><td><code>dict.setdefault(key, default=None)</code></td></tr><tr><td>判读键是否存在</td><td>1. <code>if k in dict</code> 2. <code>dict.has_key(key)</code> 存在返回true</td></tr><tr><td>以列表返回可遍历的（键，值）元祖数组</td><td><code>dict.items()</code></td></tr><tr><td>以列表返回一个字典的所有键</td><td><code>dict.keys()</code></td></tr><tr><td>以列表返回字典中的所有值</td><td><code>dict.values()</code></td></tr><tr><td>返回最大值的键值</td><td><code>max(dict, key=dict.get)</code></td></tr><tr><td>返回最小值的键值</td><td><code>min(dict, key=dict.get)</code></td></tr></tbody></table></li><li><p>遍历字典的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">dict=&#123;<span class="string">"a"</span>:<span class="string">"Alice"</span>,<span class="string">"b"</span>:<span class="string">"Bruce"</span>,<span class="string">"J"</span>:<span class="string">"Jack"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例一：键循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dict:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"dict[%s]="</span> % i,dict[i]</span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line"><span class="comment"># dict[a]= Alice</span></span><br><span class="line"><span class="comment"># dict[J]= Jack</span></span><br><span class="line"><span class="comment"># dict[b]= Bruce</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例二：键值元组循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  dict.items():</span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line"><span class="comment"># ('a', 'Alice')</span></span><br><span class="line"><span class="comment"># ('J', 'Jack')</span></span><br><span class="line"><span class="comment"># ('b', 'Bruce')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例三：键值元组循环</span></span><br><span class="line"><span class="keyword">for</span> (k,v) <span class="keyword">in</span>  dict.items():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"dict[%s]="</span> % k,v</span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line"><span class="comment"># dict[a]= Alice</span></span><br><span class="line"><span class="comment"># dict[J]= Jack</span></span><br><span class="line"><span class="comment"># dict[b]= Bruce</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="274-H-Index"><a href="#274-H-Index" class="headerlink" title="274-H-Index"></a>274-H-Index</h2><p><a href="https://leetcode.com/problems/h-index/">274-H-Index</a> </p><p>Problem:</p><p>给出研究人员论文的论文引用次数，计算它的H指数（有h篇论文的引用次数至少为h，剩下N-h篇论文的引用次数不超过h）。</p><p>Solution：</p><p>时间复杂度：$\mathcal{O}(n\log{n})$ </p><p>空间复杂度：$\mathcal{O}(n)$ </p><p>排序后，再二分。（感觉自己的二分写的有点丑qwq</p><p>还有一种思路是，排序完，从最大的h开始递减遍历，满足条件就返回。反正排序也要$\mathcal{O}(n\log{n})$ 的复杂度…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(citations)</span><br><span class="line">        citations.sort()</span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        end = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> begin &lt;= end:</span><br><span class="line">            mid = (begin + end) &gt;&gt; <span class="number">1</span></span><br><span class="line">            h = n - mid</span><br><span class="line">            <span class="keyword">if</span> citations[mid] &gt;= h:</span><br><span class="line">                end = mid</span><br><span class="line">                <span class="keyword">if</span> begin == end:</span><br><span class="line">                    <span class="keyword">return</span> h</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                begin += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n-begin</span><br></pre></td></tr></table></figure><hr><ol><li>非递归写二分：<code>while begin &lt;= end</code> </li></ol><h2 id="275-H-Index-II"><a href="#275-H-Index-II" class="headerlink" title="275-H-Index II"></a>275-H-Index II</h2><p><a href="https://leetcode.com/problems/h-index-ii/">275-H-Index II</a> </p><p>Problem:</p><p>和274一样，给了递增的论文引用数，希望能用指数时间返回H指数。</p><p>Solution：</p><p>啊，就二分鸭。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(citations)</span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        end = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> begin &lt;= end:</span><br><span class="line">            mid = (begin + end) &gt;&gt; <span class="number">1</span></span><br><span class="line">            h = n - mid</span><br><span class="line">            <span class="keyword">if</span> citations[mid] &gt;= h:</span><br><span class="line">                end = mid</span><br><span class="line">                <span class="keyword">if</span> begin == end:</span><br><span class="line">                    <span class="keyword">return</span> h</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                begin += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n - begin</span><br></pre></td></tr></table></figure><h2 id="243-Shortest-Word-Distance"><a href="#243-Shortest-Word-Distance" class="headerlink" title="243-Shortest Word Distance"></a>243-Shortest Word Distance</h2><p>qwq 这道题还收费来着，于是于是就开了个中国区的会员（中国区的会员便宜好多啊！！）</p><p><a href="https://leetcode-cn.com/problems/shortest-word-distance/">243-Shortest Word Distance</a> </p><p>Problem：</p><p>给定一串单词，单词1和单词2，计算单词1单词2在单词列表中的距离。</p><p>Solution：</p><table><thead><tr><th>Solution</th><th>Runtime</th><th>Memory</th><th>Language</th></tr></thead><tbody><tr><td>S1-二分查找</td><td>44ms</td><td>15.7MB</td><td>python3</td></tr><tr><td>S2-线性维护</td><td>40ms</td><td>15.6MB</td><td>python3</td></tr></tbody></table><h3 id="S1-二分查找"><a href="#S1-二分查找" class="headerlink" title="S1-二分查找"></a>S1-二分查找</h3><p>时间复杂度：$\mathcal{O}(n\log{n})$ </p><p>空间复杂度：$\mathcal{O}(n)$ </p><p>（最开始还很疑惑啥是单词距离…单词1和单词2可能在单词列表中重复出现）</p><p>计算出单词1和单词2在单词列表中出现的索引值列表，是递增有序的。</p><p>对于单词1索引列表中的每个值，在单词2索引列表中查找该值的lower_bound，计算距离。</p><p>同理，对于单词2索引列表中的每个值，也同样计算距离。</p><p>找出最小距离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_bound</span><span class="params">(a: list, x: int)</span> -&gt; int:</span></span><br><span class="line">    n = len(a)</span><br><span class="line">    begin = <span class="number">0</span></span><br><span class="line">    end = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> begin &lt;= end:</span><br><span class="line">        mid = (begin + end) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a[mid] &gt;= x:</span><br><span class="line">            end = mid</span><br><span class="line">            <span class="keyword">if</span> begin == end:</span><br><span class="line">                <span class="keyword">return</span> begin</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            begin += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    ans = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findShortest</span><span class="params">(self, li1: list, li2: list)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> li1:</span><br><span class="line">            min_dis_idx = lower_bound(li2, idx)</span><br><span class="line">            <span class="keyword">if</span> min_dis_idx == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.ans = min(self.ans, li2[min_dis_idx] - idx)</span><br><span class="line">                <span class="keyword">if</span> self.ans == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(self, words: List[str], word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(words)</span><br><span class="line">        li1 = []</span><br><span class="line">        li2 = []</span><br><span class="line">        self.ans = n</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># li1 and li2 are ordered</span></span><br><span class="line">            <span class="keyword">if</span> words[idx] == word1:</span><br><span class="line">                li1.append(idx)</span><br><span class="line">            <span class="keyword">if</span> words[idx] == word2:</span><br><span class="line">                li2.append(idx)</span><br><span class="line">        self.findShortest(li1, li2)</span><br><span class="line">        <span class="keyword">if</span> self.ans &gt; <span class="number">1</span>:</span><br><span class="line">            self.findShortest(li2, li1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><h3 id="S2-线性维护："><a href="#S2-线性维护：" class="headerlink" title="S2-线性维护："></a>S2-线性维护：</h3><p>时间复杂度：$\mathcal{O}(n)$  </p><p>空间复杂度：$\mathcal{O}(n)$ </p><p>问题还能再简化，线性扫描单词列表，维护两个变量，单词1出现的最近索引，单词2出现的最近索引。扫描时计算距离，每当单词1或单词2出现时，就用另一个单词的最近索引计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(self, words: List[str], word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(words)</span><br><span class="line">        lst1 = <span class="literal">None</span></span><br><span class="line">        lst2 = <span class="literal">None</span></span><br><span class="line">        ans = n</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> words[idx] == word1:</span><br><span class="line">                lst1 = idx</span><br><span class="line">                <span class="keyword">if</span> lst2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    ans = min(ans, lst1-lst2)</span><br><span class="line">            <span class="keyword">if</span> words[idx] == word2:</span><br><span class="line">                lst2 = idx</span><br><span class="line">                <span class="keyword">if</span> lst1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    ans = min(ans, lst2-lst1)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><ol><li><p>C++中：</p><p>lower_bound(begin, end, num)：返回num的下界，即大于等于num的第一个索引位置。</p><p>upper_bound(begin, end, num)：返回num的上界，即大于num的第一个索引位置。</p><p>Python中用二分实现这两个函数。 </p></li></ol><h2 id="244-Shortest-Word-Distance-II"><a href="#244-Shortest-Word-Distance-II" class="headerlink" title="244-Shortest Word Distance II"></a>244-Shortest Word Distance II</h2><p><a href="https://leetcode-cn.com/problems/shortest-word-distance-ii/">244-Shortest Word Distance II</a></p><p>Problem:</p><p>和上题题干类似，计算单词距离，但是此问是每一个单词列表，可能有多个询问。</p><p>Solution：</p><p>对每一个单词列表，都可能有多个询问。</p><p>因此，之前243的解法每次询问都会遍历一遍单词列表。如果对每个单词列表询问数为 $M$ ，那么时间复杂度为 $\mathcal{O}(NM)$ ，会超时，所以希望能将单词列表的有关信息存下来，再用常数时间处理每一个询问。</p><p>这里的解法是用一个字典把每个单词出现的index列表存下来，键是单词，值是index列表。这个列表相对于单词列表的数目应该是远远小于的，因此用二重循环应该也能过吧（没有尝试二重循环解法）</p><p>这里有两种思路，一种是自己想的归并思路，还有一种是官方解答的思路，官方思路比归并的思路更优雅一些，问题抽象的更好。（代码差距不大，时间差距也不太大）</p><table><thead><tr><th>Solution</th><th>Runtime</th><th>Memory</th><th>Language</th></tr></thead><tbody><tr><td>S1-归并思路查询</td><td>96ms</td><td>20.8MB</td><td>python3</td></tr><tr><td>S2-交叉跳跃查询</td><td>80ms</td><td>20.4MB</td><td>python3</td></tr></tbody></table><p>双指针：$i$ 指向列表1，$j$指向列表2.</p><h3 id="S1-归并思路"><a href="#S1-归并思路" class="headerlink" title="S1-归并思路"></a>S1-归并思路</h3><p>归并思路：列表的值都是有序的，再把两个列表的值按归并的思想再排序，可以想成把点一个一个有序放在数轴上。</p><p>$i$指针前进的情况：（排序时，取列表1的下一个数字）</p><ol><li>$i+1&lt;len1$  and $li1[i+1] &lt; li[j]$</li><li>$i+1&lt;len1$  and $li1[i+1] &lt; li[j+1]$ </li><li>$i+1 &lt; len1$ and $j+1 == len2$  ($j$ 已无法移动)</li></ol><p>其余情况：$j$ 移动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words: List[str])</span>:</span></span><br><span class="line">        self.words = words</span><br><span class="line">        self.len = len(words)</span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(self.len):</span><br><span class="line">            word = words[index]</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> self.dict:</span><br><span class="line">                temp = self.dict[word]</span><br><span class="line">                temp.append(index)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = [index]</span><br><span class="line">                self.dict[word] = temp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortest</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        ans = self.len</span><br><span class="line">        li1 = self.dict[word1]</span><br><span class="line">        li2 = self.dict[word2]</span><br><span class="line">        len1 = len(li1)</span><br><span class="line">        len2 = len(li2)</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len1 <span class="keyword">and</span> j &lt; len2:</span><br><span class="line">            ans = min(ans, abs(li1[i] - li2[j]))</span><br><span class="line">            <span class="keyword">if</span> ans == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            <span class="comment"># i goes ahead</span></span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; len1 <span class="keyword">and</span> ((li1[i + <span class="number">1</span>] &lt; li2[j]) <span class="keyword">or</span> (j+<span class="number">1</span> == len2) <span class="keyword">or</span> (j + <span class="number">1</span> &lt; len2 <span class="keyword">and</span> li1[i + <span class="number">1</span>] &lt; li2[j + <span class="number">1</span>])):</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="S2-交叉比较"><a href="#S2-交叉比较" class="headerlink" title="S2-交叉比较"></a>S2-交叉比较</h3><p>对于当前指向列表1和列表2的两个元素 $li1[i]$ 和 $li2[j]$ ，对 $li1[i]$来说，只需要和旁边的属于列表2的元素比较，对 $li2[j]$ 同理。</p><p>因此，当  $li1[i]&gt;li2[j]$ 时，下一次的比较应该让 $j$ 指针前移一位，继续计算指针 $i$ 所指元素和其旁边的列表2的元素。同理，当 $li1[i]&lt;li2[j]$ 时，下一次的比较应该让 $i$ 指针前移一位，继续计算指针 $j$ 和其旁边的列表1的元素。</p><p>具体移动如下图。</p><img src="https://s1.ax1x.com/2020/09/19/wIuW4K.jpg" alt="wIuW4K.jpg" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words: List[str])</span>:</span></span><br><span class="line">        self.words = words</span><br><span class="line">        self.len = len(words)</span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(self.len):</span><br><span class="line">            word = words[index]</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> self.dict:</span><br><span class="line">                temp = self.dict[word]</span><br><span class="line">                temp.append(index)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = [index]</span><br><span class="line">                self.dict[word] = temp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortest</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        ans = self.len</span><br><span class="line">        li1 = self.dict[word1]</span><br><span class="line">        li2 = self.dict[word2]</span><br><span class="line">        len1 = len(li1)</span><br><span class="line">        len2 = len(li2)</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len1 <span class="keyword">and</span> j &lt; len2:</span><br><span class="line">            ans = min(ans, abs(li1[i] - li2[j]))</span><br><span class="line">            <span class="keyword">if</span> ans == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            <span class="comment"># i goes ahead</span></span><br><span class="line">            <span class="keyword">if</span> li1[i] &lt; li2[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="277-Find-the-Celebrity"><a href="#277-Find-the-Celebrity" class="headerlink" title="277-Find the Celebrity"></a>277-Find the Celebrity</h2><p><a href="https://leetcode-cn.com/problems/find-the-celebrity/">277-Find the Celebrity</a> </p><p>Problem: </p><p>已有know(i, j) API，判断i是否知道j，i是名人的充要条件是其他所有人知道i，而i不知道其他所有人。</p><p>Solution：</p><p>两种思路，第一种较为直观，使用二重循环，但剪枝多，远达不到 $\mathcal{O}(n^2)$ ，第二种稍做优化。因此两种解法差距不太大。</p><table><thead><tr><th align="left">提交时间</th><th align="left">运行时间</th><th align="left">内存消耗</th><th>语言</th></tr></thead><tbody><tr><td align="left">S几秒前</td><td align="left">1896ms</td><td align="left">13.6MB</td><td>python3</td></tr><tr><td align="left">5 分钟前</td><td align="left">1772ms</td><td align="left">13.6MB</td><td>python3</td></tr></tbody></table><h3 id="S1-直观思路"><a href="#S1-直观思路" class="headerlink" title="S1-直观思路"></a>S1-直观思路</h3><p>时间复杂度：远不到 $\mathcal{O}(n^2)$ </p><p>用了二重循环，但剪枝很多，所以远达不到 $\mathcal{O}(n^2)$ </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            fg = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># i knows j ?</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> knows(i, j):</span><br><span class="line">                    fg = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fg:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># j knows i ?</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> knows(j, i):</span><br><span class="line">                    fg = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fg:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="S2-排除法"><a href="#S2-排除法" class="headerlink" title="S2-排除法"></a>S2-排除法</h3><p>时间复杂度：$\mathcal{O}(n)$ </p><p>排除i：根据<code>know(i, j)=True</code> 可以认为i不是名人，j可能是名人。</p><p>对于n-1个关系，最后从n个人中选出一个可能的人，再根据名人的充要条件去判断他是否是名人。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        celebrity = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> knows(celebrity, i):</span><br><span class="line">                celebrity = i</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> celebrity == i:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> knows(celebrity, i)) <span class="keyword">and</span> knows(i, celebrity):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> celebrity</span><br></pre></td></tr></table></figure><h2 id="245-Shortest-Word-Distance-III"><a href="#245-Shortest-Word-Distance-III" class="headerlink" title="245-Shortest Word Distance III"></a>245-Shortest Word Distance III</h2><p><a href="https://leetcode-cn.com/problems/shortest-word-distance-iii/">245-Shortest Word Distance III</a> </p><p>Problem:</p><p>题意增加了两个单词可能相同，分两种情况就好了。</p><p>Solution：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestWordDistance</span><span class="params">(self, words: List[str], word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(words)</span><br><span class="line">        ptr1 = <span class="literal">None</span></span><br><span class="line">        ptr2 = <span class="literal">None</span></span><br><span class="line">        ans = n</span><br><span class="line">        <span class="keyword">if</span> word1 == word2:</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> words[idx] == word1:</span><br><span class="line">                    ptr1, ptr2 = idx, ptr1</span><br><span class="line">                <span class="keyword">if</span> (ptr1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (ptr2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">                    ans = min(ans, ptr1-ptr2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> words[idx] == word1:</span><br><span class="line">                    ptr1 = idx</span><br><span class="line">                <span class="keyword">if</span> words[idx] == word2:</span><br><span class="line">                    ptr2 = idx</span><br><span class="line">                <span class="keyword">if</span> (ptr1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (ptr2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>):</span><br><span class="line">                    ans = min(ans, abs(ptr1-ptr2))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="217-Contains-Duplicate-E"><a href="#217-Contains-Duplicate-E" class="headerlink" title="217-Contains Duplicate[E]"></a>217-Contains Duplicate[E]</h2><p><a href="https://leetcode.com/problems/contains-duplicate/">217-Contains Duplicate</a> </p><p>Problem:</p><p>判断数组中有无重复元素出现。</p><p>Solution：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        S = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> S:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            S.add(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="219-Contains-Duplicate-II-E"><a href="#219-Contains-Duplicate-II-E" class="headerlink" title="219-Contains Duplicate II[E]"></a>219-Contains Duplicate II[E]</h2><p><a href="https://leetcode.com/problems/contains-duplicate-ii/">219-Contains Duplicate II</a> </p><p>Problem:</p><p>判断数组中是否有两个相同的值，他们的索引之差小于等于k。</p><p>Solution：</p><p>存放出现该值的最近的索引，扫一遍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict.setdefault(nums[i], i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i - dict[nums[i]] &lt;= k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                dict[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="4-Median-of-Two-Sorted-Arrays-H-（2S）"><a href="#4-Median-of-Two-Sorted-Arrays-H-（2S）" class="headerlink" title="4-Median of Two Sorted Arrays[H] （2S）"></a>4-Median of Two Sorted Arrays[H] （2S）</h2><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">4-Median of Two Sorted Arrays[H]</a> </p><p>Problem:</p><p>给两个排好序的数组，返回一个中位数</p><p>Solution：</p><table><thead><tr><th>S</th><th>运行时间</th><th>内存消耗</th></tr></thead><tbody><tr><td>S1</td><td>$\mathcal{O}(m+n)$ ：92ms</td><td>14.3MB</td></tr><tr><td>S2</td><td>$\mathcal{O}(\log(m+n))$ ：52ms</td><td>13.3MB</td></tr></tbody></table><h3 id="S1"><a href="#S1" class="headerlink" title="S1:"></a>S1:</h3><p>归并排序的做法。</p><p>时间复杂度：$\mathcal{O}(m+n)$ </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        n1 = len(nums1)</span><br><span class="line">        n2 = len(nums2)</span><br><span class="line">        median1 = median2 = <span class="literal">None</span></span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        tot = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n1 <span class="keyword">or</span> j &lt; n2:</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n1 <span class="keyword">and</span> j &lt; n2 <span class="keyword">and</span> nums1[i] &lt;= nums2[j]) <span class="keyword">or</span> (i &lt; n1 <span class="keyword">and</span> j &gt;= n2):</span><br><span class="line">                tot += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> tot == (n1 + n2)//<span class="number">2</span>:</span><br><span class="line">                    median1 = nums1[i]</span><br><span class="line">                <span class="keyword">if</span> tot == (n1 + n2)//<span class="number">2</span> + <span class="number">1</span>:</span><br><span class="line">                    median2 = nums1[i]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tot += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> tot == (n1 + n2) // <span class="number">2</span>:</span><br><span class="line">                    median1 = nums2[j]</span><br><span class="line">                <span class="keyword">if</span> tot == (n1 + n2) // <span class="number">2</span> + <span class="number">1</span>:</span><br><span class="line">                    median2 = nums2[j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (n1 + n2) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> median2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (median1 + median2)/<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="S2"><a href="#S2" class="headerlink" title="S2:"></a>S2:</h3><p>二分的思路</p><p>时间复杂度：$\mathcal{O}(\log(m+n))$ </p><p><strong>一、</strong>首先讨论一个数组的中位数，数组有n个元素，如果n为奇数，则第(n+1)/2个是中位数；如果n为偶数，则第(n+1)/2和第(n+2)/2的平均值为中位数。</p><p>回到本题，因为是两个数组，如果根据奇偶性分类讨论就过于麻烦了，所以将两种情况统一以简化解题思路。</p><p>即无论n是奇数还是偶数，数组的中位数都是第(n+1)/2和第(n+2)/2的平均数。</p><p>回到本题，设数组1有n个元素，数组2有m个元素，则中位数为两个数组的有序序列的第(n+m+1)/2个和第(n+m+2)/2个的平均数。</p><p><strong>二、</strong>因此，题目需要求解的问题改为求这两个有序数组的有序序列的第k个数。</p><p>二分思想：两个数组分别找第k/2个数，（假设都存在），比较，<strong>如果第一个数组的这个数小于第二个数组，说明第k个数肯定不在第一个数组的前k/2个数中，因此就可以直接去掉数组1的前k/2个元素</strong>，查找有序序列的第k-k/2个数；同理，如果大于，则说明第k个数肯定不在第二个数组的前k/2个数中，去掉数组2的前k/2个元素。</p><p>使用一个数组起始指针l1和l2来实现数组的“去掉”前k/2个元素。</p><p>设数组1的元素个数为n，数组2的元素个数为m。</p><p><strong>递归函数Find(l1, l2, k)：查找起始指针为l1, l2的两个有序数组的第k个数。</strong></p><ul><li><p>讨论边界情况，有数组为空的情况。即 <code>l1 == n</code>  或者 <code>l2 == m</code> .</p><p>如果第一个数组已为空，则直接返回第二个数组的第k个数；</p><p>同理，如果第二个数组为空，则直接返回第一个数组的第k个数。</p></li><li><p>两个数组都不为空的情况。即 <code>l1 &lt; n</code>  或者 <code>l2 &lt; m</code> .</p><ul><li><p>递归边界： <code>k == 1</code>  ,即返回 <code>nums1[l1]</code> 和 <code>nums2[l2]</code> 中较小的那一个。</p></li><li><p>数组长度边界：即有数组的剩余元素个数小于 <code>k/2</code> ，那么拿出来比较的就应该是数组的最后一个元素。</p><p>维护两个值 <code>k1</code> 和 <code>k2</code> 来分别表示用两个数组的第 k1和k2个来比较。</p><p>(k1 k2都小于等于k/2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># to avoid the rest length of nums1/nums2 is shorter than k//2</span></span><br><span class="line">k1 = k//<span class="number">2</span> <span class="keyword">if</span> l1+k//<span class="number">2</span> &lt;= n <span class="keyword">else</span> n-l1</span><br><span class="line">k2 = k//<span class="number">2</span> <span class="keyword">if</span> l2+k//<span class="number">2</span> &lt;= m <span class="keyword">else</span> m-l2</span><br></pre></td></tr></table></figure></li><li><p>比较<code>nums1[l1+k1-1]</code> 和 <code>nums2[l2+k2-1]</code> 的大小，递归：</p><ol><li><p>相等：</p><p>如果 <code>k-k1-k2 == 0</code> 说明nums1的前k1个和nums2的前k2个就是有序序列的前k个，返回 <code>nums1[l1+k1-1]</code> 。</p><p>否则，（即某一个数组的剩余长度小于k/2），分别去掉两个数组的前k1和k2个数，递归调用 <strong>Find(l1+k1, l2+k2, k-k1-k2)</strong> 。</p></li><li><p><code>nums1[l1+k1-1] &gt; nums2[l2+k2-1]</code>  </p><p>说明可以去掉数组2的前k2个数，递归调用 <strong>Find(l1, l2+k2, k-k2)</strong> </p></li><li><p><code>nums1[l1+k1-1] &gt; nums2[l2+k2-1]</code>  </p><p>说明可以去掉数组1的前k1个数，递归调用 <strong>Find(l1+k1, l2, k-k1)</strong> </p></li></ol></li></ul></li></ul><p>Code：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.nums1 = <span class="literal">None</span></span><br><span class="line">        self.nums2 = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthOfTwo</span><span class="params">(self, l1: int, l2: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        nums1 = self.nums1</span><br><span class="line">        nums2 = self.nums2</span><br><span class="line">        n = len(nums1)</span><br><span class="line">        m = len(nums2)</span><br><span class="line">        <span class="comment"># nums1 is empty</span></span><br><span class="line">        <span class="keyword">if</span> l1 == n:</span><br><span class="line">            <span class="keyword">return</span> nums2[l2+k<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># nums2 is empty</span></span><br><span class="line">        <span class="keyword">if</span> l2 == m:</span><br><span class="line">            <span class="keyword">return</span> nums1[l1+k<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># both not empty</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[l1] <span class="keyword">if</span> nums1[l1] &lt;= nums2[l2] <span class="keyword">else</span> nums2[l2]</span><br><span class="line">        <span class="comment"># to avoid the rest length of nums1/nums2 is shorter than k//2</span></span><br><span class="line">        k1 = k//<span class="number">2</span> <span class="keyword">if</span> l1+k//<span class="number">2</span> &lt;= n <span class="keyword">else</span> n-l1</span><br><span class="line">        k2 = k//<span class="number">2</span> <span class="keyword">if</span> l2+k//<span class="number">2</span> &lt;= m <span class="keyword">else</span> m-l2</span><br><span class="line">        <span class="keyword">if</span> nums1[l1+k1<span class="number">-1</span>] == nums2[l2+k2<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> nums1[l1+k1<span class="number">-1</span>] <span class="keyword">if</span> k-k1-k2 == <span class="number">0</span> <span class="keyword">else</span> self.findKthOfTwo(l1+k1, l2+k2, k-k1-k2)</span><br><span class="line">        <span class="keyword">elif</span> nums1[l1+k1<span class="number">-1</span>] &gt; nums2[l2+k2<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findKthOfTwo(l1, l2+k2, k-k2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findKthOfTwo(l1+k1, l2, k-k1)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        n = len(nums1)</span><br><span class="line">        m = len(nums2)</span><br><span class="line">        self.nums1 = nums1</span><br><span class="line">        self.nums2 = nums2</span><br><span class="line">        <span class="comment"># median: the average of (n+m+1)//2 th  and  (n+m+2)//2 th</span></span><br><span class="line">        <span class="keyword">return</span> (self.findKthOfTwo(<span class="number">0</span>, <span class="number">0</span>, (n+m+<span class="number">1</span>)//<span class="number">2</span>) + self.findKthOfTwo(<span class="number">0</span>, <span class="number">0</span>, (n+m+<span class="number">2</span>)//<span class="number">2</span>)) / <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol><li>《信息安全数学基础》 2.2同余类和剩余系。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;8月某司实训+准备开学期末考，我可太咕了q w q…dbq，（希望）高产博主我.我..又回来了。&lt;/p&gt;
&lt;p&gt;LeetCode Array专题，持久更新。（&lt;a href=&quot;https://github.com/f1ed/LeetCode&quot;&gt;GitHub&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://f7ed.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="https://f7ed.com/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="https://f7ed.com/tags/Algorithms/"/>
    
      <category term="Data-Structure" scheme="https://f7ed.com/tags/Data-Structure/"/>
    
      <category term="Array" scheme="https://f7ed.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>「Web」:HTML and CSS</title>
    <link href="https://f7ed.com/2020/07/22/html-css/"/>
    <id>https://f7ed.com/2020/07/22/html-css/</id>
    <published>2020-07-21T16:00:00.000Z</published>
    <updated>2020-07-25T03:44:57.007Z</updated>
    
    <content type="html"><![CDATA[<p>温故知新：对Web基础知识——HTML和CSS的持续更新。</p><a id="more"></a><h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><h3 id="B-S-软件结构"><a href="#B-S-软件结构" class="headerlink" title="B/S 软件结构"></a>B/S 软件结构</h3><p>C/S： Client Server（JavaSE）</p><p>B/S：Browser Server（JavaEE）</p><h3 id="前端开发流程"><a href="#前端开发流程" class="headerlink" title="前端开发流程"></a>前端开发流程</h3><ol><li>美术实现：网页设计</li><li>前端工程师：设计为静态网页</li><li>Java程序员：后端工程师修改为动态页面</li></ol><h3 id="网页端组成部分"><a href="#网页端组成部分" class="headerlink" title="网页端组成部分"></a>网页端组成部分</h3><p>内容：页面中可以看到的数据。一般使用html技术。</p><p>表现：内容在页面上的展示形式。一般使用CSS。</p><p>行为：页面中的元素与输入设备交互。一般使用javascript技术。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="创建HTML文件"><a href="#创建HTML文件" class="headerlink" title="创建HTML文件"></a>创建HTML文件</h2><ol><li>创建一个Web静态工程</li><li>在工程下创建html页面</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="comment">&lt;!--声明--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh_CN"</span>&gt;</span><span class="comment">&lt;!--html中包含两部分：head和body--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="comment">&lt;!--head中包含：title标签、CSS样式、js代码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h2><ul><li>标签名大小写不敏感</li><li>标签有自己的属性<ul><li>基本属性：修改简单样式</li><li>事件属性：设置事件响应后的代码</li></ul></li><li>标签分为单标签&lt;标签/&gt;和双标签&lt;标签&gt;&lt;/标签&gt;</li><li>标签的属性必须要有值，属性值加双引号。</li><li>显示特殊标签：&lt; &gt; 空格等等，建议查阅文档。</li></ul><h3 id="字体标签"><a href="#字体标签" class="headerlink" title="字体标签"></a>字体标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span> <span class="attr">size</span>=<span class="string">"7"</span>&gt;</span></span><br><span class="line">        哒哒哒。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="标题标签：h1-到-h6"><a href="#标题标签：h1-到-h6" class="headerlink" title="标题标签：h1 到 h6"></a>标题标签：h1 到 h6</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="comment">&lt;!--align：显示位置,默认左--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://baidu.com"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="comment">&lt;!--_self属性：当前窗口跳转--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://baidu.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="comment">&lt;!--_blank属性：打开新窗口跳转--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"none"</span>&gt;</span><span class="comment">&lt;!--无序列表--&gt;</span><span class="comment">&lt;!--type属性可以更改列表前的符号--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span><span class="comment">&lt;!--有序表格--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h3><ul><li><p>属性src:图片等路径位置</p></li><li><p>JavaSE中路径</p><ul><li>相对路径：从工程名字开始算</li><li>绝对路径：硬盘中的路径</li></ul></li><li><p>Web中的路径</p><ul><li><p>相对路径：</p><p><code>.</code>    ：表示当前文件所在的目录</p><p><code>..</code>   ：表示当前文件所在的上级目录</p><p><code>文件名</code>：表示当前文件所在目录的文件，相当于<code>./文件名</code></p></li><li><p>绝对路径：<code>http://ip:port/工程名/资源路径</code></p></li></ul></li><li><p>属性：weight; height; </p><ul><li>border：设置图片边框大小。</li><li>alt：当指定路径找不到图片时，用来代替显示的文本内容。</li></ul></li></ul><h3 id="表格标签：实现跨行跨列"><a href="#表格标签：实现跨行跨列" class="headerlink" title="表格标签：实现跨行跨列"></a>表格标签：实现跨行跨列</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"300"</span>&gt;</span><span class="comment">&lt;!--表格标签--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--border：设置边框、width：设置宽度、height：设置高度--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--align：设置表格对齐方式--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--cellspacing:单元格间距--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--行标签--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>h1<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="comment">&lt;!--表头标签--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>h3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!--单元格标签--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--align：设置单元格文本对齐方式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!--colspan:列的宽度,实现单元格跨列--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!--rowspan:行的宽度，实现单元格跨行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="iframe框架标签"><a href="#iframe框架标签" class="headerlink" title="iframe框架标签"></a>iframe框架标签</h3><p>可以在html页面上开辟一个小区域加载单独的页面，实现内嵌窗口。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"hello.html"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"600"</span> <span class="attr">name</span>=<span class="string">"abc"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name：表示该区域的名字--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"welcome.html"</span> <span class="attr">target</span>=<span class="string">"abc"</span>&gt;</span>欢迎<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--target：打开窗口显示的位置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--a标签的target属性设置为iframe的name属性，就在开辟的区域打开链接窗口--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><p>表单：html中用来收集用户信息的元素集合，将这些信息发送给服务器处理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span><span class="comment">&lt;!--表单标签--&gt;</span></span><br><span class="line">    用户名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"User"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="comment">&lt;!--input输入框标签--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--type：输入类型 value：默认值--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--text：文本类型--&gt;</span></span><br><span class="line">    用户密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--password：密码类型--&gt;</span></span><br><span class="line">    确认密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span>男</span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>/&gt;</span>女<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--radio：单选框; name属性：可对其分组; checked：默认选项--&gt;</span></span><br><span class="line">    兴趣爱好：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span>Java</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span>JavaScript<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--checkbox：复选框; checked:默认选项--&gt;</span></span><br><span class="line">    国籍：</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span>&gt;</span><span class="comment">&lt;!--下拉列表框标签--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择国籍--<span class="tag">&lt;/<span class="name">option</span>&gt;</span><span class="comment">&lt;!--选项标签--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--selected：默认选择--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>美国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>日本<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    自我评价：<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"30"</span>&gt;</span>默认值<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--textarea标签：多行文本输入框；属性 rows:行数; 属性 cols：列数--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--textarea起始标签和结束标签中的内容是默认值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重新输入"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--reset：重置按钮; value属性：更改按钮文本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--submit：提交按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--button:按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--file:文件上传--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--hidden:隐藏域，需要发送一些不需要用户参与的信息至服务器，可使用隐藏域--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单格式化"><a href="#表单格式化" class="headerlink" title="表单格式化"></a>表单格式化</h3><p>把表单放入表格，使表单排列整齐。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名称：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"User"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户密码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>确认密码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span>男</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>/&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单提交的细节"><a href="#表单提交的细节" class="headerlink" title="表单提交的细节"></a>表单提交的细节</h3><p>以下格式化的表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://localhost:8080"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--form标签属性--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--action：设置提交的服务器地址--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--method：设置提交的方式，默认GET（也可以是POST）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"action"</span> <span class="attr">value</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名称：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"User"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户密码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> /&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>确认密码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span>男</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>/&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>兴趣爱好：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span>Java</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>/&gt;</span>JavaScript</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>国籍：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择国籍--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>美国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>日本<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>自我评价:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"30"</span>&gt;</span>默认值<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重新输入"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>格式化后的表单显示为：</p><img src="https://s1.ax1x.com/2020/07/25/UznJiT.png" alt="UznJiT.pndg" style="zoom:50%;" /> <p>表单提交后，url显示为：<code>https://localhost:8080/?action=login&amp;sex=on</code> </p><p>该url体现了三部分</p><ul><li>提交表单的服务器地址/action属性的值：localhost:8080/</li><li>分隔符：<code>?</code></li><li>请求参数/表单信息：action=login; sex=on</li></ul><hr><p><strong>表单提交的时候，数据没有发送给服务器的三种情况：</strong></p><ol><li>表单项input标签没有name属性值。</li><li>单选、复选输入标签以及下拉列表的option标签，还需要加value属性值，以便发送给服务器具体值，而不是on。</li><li>表单项不在提交的form标签中。</li></ol><p>修改后的表单代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://localhost:8080"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--action：设置提交的服务器地址--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--method：设置提交的方式，默认GET--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"action"</span> <span class="attr">value</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名称：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"User"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户密码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>确认密码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> <span class="attr">value</span>=<span class="string">"boy"</span>/&gt;</span>男</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"girl"</span>/&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>兴趣爱好：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> <span class="attr">value</span>=<span class="string">"Java"</span>/&gt;</span>Java</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> <span class="attr">value</span>=<span class="string">"js"</span>/&gt;</span>JavaScript</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>国籍：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"country"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"none"</span>&gt;</span>--请选择国籍--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span> <span class="attr">value</span>=<span class="string">"中国"</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"美国"</span>&gt;</span>美国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"日本"</span>&gt;</span>日本<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>自我评价:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"10"</span> <span class="attr">cols</span>=<span class="string">"30"</span>&gt;</span>默认值<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重新输入"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表单提交后的url: <code>https://localhost:8080/?action=login&amp;user=fred&amp;password=123&amp;password=123&amp;sex=girl&amp;hobby=Java&amp;hobby=js&amp;country=中国</code> </p><hr><p><strong>表单标签method属性参数的区别</strong></p><ul><li><p>GET：</p><ol><li><p>浏览器的地址栏为：action属性值 + ? + 请求参数</p><p>请求参数格式为：<code>name=value&amp;name=value</code></p></li><li><p>不安全</p></li><li><p>有数据长度限制</p></li></ol></li><li><p>POST请求的特点：</p><ol><li>浏览器上的地址栏为：action属性值（没有请求参数）</li><li>相当于GET请求更安全</li><li>理论上没有数据长度限制</li></ol></li></ul><h3 id="div和span"><a href="#div和span" class="headerlink" title="div和span"></a>div和span</h3><ul><li>div 标签：默认独占一行</li><li>span 标签：长度是封装数据长度</li><li>p 标签：默认在段落的上方或下方各空出一行（如果已有空行则不空）</li></ul><h3 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h3><p>label标签为input元素定义标注。</p><p>该标签不会为用户呈现特殊的效果，但为鼠标用户改进了可用性，即在label元素内点击文本，就会触发该控件。即当用户选择该标签时，浏览器会自动将焦点转到和label标签绑定的表单项上。</p><p>常见的应用情况是：单选框/复选框，点击文本即可勾选，而不需要去点那个框。</p><ul><li>for : 表示该label是为表单中哪个控件服务，for属性点值设置为该元素的id属性值</li></ul><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h2><p>CSS：层叠样式表单，用于增强/控制网页样式，且允许将样式信息和网页内容分离的一种标记性语言。</p><p>语法规则：</p><img src="https://s1.ax1x.com/2020/07/25/UznYJU.png" alt="UznYJU.png" style="zoom:50%;" /> <ul><li><p>选择器：浏览器根据选择器决定受CSS样式影响到HTML元素/标签。</p></li><li><p>属性：<code>属性:值;</code> 形成一个完成的declaration。</p></li></ul><p>CSS中的注释：/**/</p><h2 id="CSS与HTML结合方式"><a href="#CSS与HTML结合方式" class="headerlink" title="CSS与HTML结合方式"></a>CSS与HTML结合方式</h2><h3 id="标签中的style"><a href="#标签中的style" class="headerlink" title="标签中的style"></a>标签中的style</h3><p>在标签的style属性设置<code>style=&quot;key: value1 value2;&quot;</code> </p><p>这种方式可读性差，且没有复用性。</p><h2 id="head标签中使用style标签"><a href="#head标签中使用style标签" class="headerlink" title="head标签中使用style标签"></a>head标签中使用style标签</h2><p>在head标签中，用style标签定义需要的css样式。</p><p>style标签中的语句是CSS语法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        div&#123;</span><br><span class="line">            border: 1px solid red;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以在同一页面复用代码，不能在多个页面复用CSS代码，且维护不方便，需要修改每个页面。</p><h3 id="CSS文件"><a href="#CSS文件" class="headerlink" title="CSS文件"></a>CSS文件</h3><p>把CSS样式写成CSS文件，在html文件的head标签中通过link标签引用。</p><p>style.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> red solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> red solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>div.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--link标签专门在head中用来引入CSS样式代码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rel:文档间的关系--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--type:目标URL的类型--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--href:URL--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以在多个页面中复用CSS样式，且维护方便。</p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="标签名选择器"><a href="#标签名选择器" class="headerlink" title="标签名选择器"></a>标签名选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标签名&#123;</span><br><span class="line">    属性:值;</span><br><span class="line">    属性:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签名选择器决定哪些标签被动的使用这个样式。</p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>选择器&#123;</span><br><span class="line">    属性:值;</span><br><span class="line">    属性:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>id选择器通过id属性选择性的使用这个样式。</p><p>html文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"id001"</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--标签的id属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"id002"</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">        <span class="selector-id">#id001</span>&#123;</span><br><span class="line">            <span class="attribute">border</span>: yellow <span class="number">1px</span> solid;</span><br><span class="line">            <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">            <span class="attribute">color</span>: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-id">#id001</span>&#123;</span><br><span class="line">            <span class="attribute">border</span>: <span class="number">5px</span> blue dotted;</span><br><span class="line">            <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">            <span class="attribute">color</span>: red;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="class-选择器"><a href="#class-选择器" class="headerlink" title="class 选择器"></a>class 选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span>属性值&#123;</span><br><span class="line">    属性:值;</span><br><span class="line">    属性:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class属性多用来分组定义CSS样式。</p><p>class选择器通过class属性值选择性使用这个样式。</p><p>html文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"class0"</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--标签的class属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"class0"</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.div</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> yellow solid;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class0</span>, <span class="selector-id">#id001</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> yellow solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合选择器可以让多个选择器共用同样的CSS样式。</p><h2 id="常用样式"><a href="#常用样式" class="headerlink" title="常用样式"></a>常用样式</h2><p>具体可查阅</p><ul><li><p>字体颜色</p><p><code>color : red;</code> </p><p><code>color : rgb(33,33,13);</code>  </p><p> <code>color : #00F666;</code>  </p></li><li><p>宽度</p><p><code>width : 19px;</code>  </p><p><code>width : 20%;</code> </p></li><li><p>高度</p><p><code>height : 19px;</code>  </p><p><code>height : 20%;</code> </p></li><li><p>背景颜色</p><p><code>background-color : #0F2222;</code> </p></li><li><p>字体大小</p><p><code>font-size : 20px;</code> </p></li><li><p>边框</p><p><code>border : 1px solid red;</code> </p></li><li><p>DIV居中（相当于页面的居中）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">margin-left</span> : <span class="selector-tag">auto</span>;</span><br><span class="line"><span class="selector-tag">margin</span> <span class="selector-tag">-right</span> : <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure></li><li><p>文本居中</p><p><code>text-align : center;</code> </p></li><li><p>超链接去下划线</p><p><code>text-decoration : none;</code></p></li><li><p>表格细线</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>&#123;</span><br><span class="line">    <span class="attribute">border </span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">border-collapse </span>: collapse;<span class="comment">/*合并表格边框*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">td</span>,<span class="selector-tag">th</span>&#123;</span><br><span class="line">    <span class="attribute">border </span>: <span class="number">1px</span>, solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>列表去修饰符</p><p><code>list-style : none</code> </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;温故知新：对Web基础知识——HTML和CSS的持续更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://f7ed.com/categories/Tools/"/>
    
    
      <category term="Web" scheme="https://f7ed.com/tags/Web/"/>
    
      <category term="HTML" scheme="https://f7ed.com/tags/HTML/"/>
    
      <category term="CSS" scheme="https://f7ed.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>「Tools」：Docker</title>
    <link href="https://f7ed.com/2020/07/21/Docker/"/>
    <id>https://f7ed.com/2020/07/21/Docker/</id>
    <published>2020-07-20T16:00:00.000Z</published>
    <updated>2020-07-25T03:34:59.360Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要分四个部分，首先介绍了Docker是什么：为什么会有Docker技术的出现；虚拟化技术和容器虚拟化技术的区别；Docker的基本组成；Docker的运行为什么会比虚拟机快。</p><p>第二个部分主要介绍了Docker的常用命令，包括镜像命令和容器命令，文中还从底层的角度分析Docker镜像。</p><p>第三个部分介绍了Docker中的容器数据卷，和如何挂载数据卷。</p><p>最后一个部分，简单介绍了Dockerfile文件。</p><a id="more"></a><h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h2><p>开发和运维之间的环境和配置问题：在我的机器上可以正常工作。</p><p>把代码/配置/系统/数据等全部打包成镜像，运维工程师带环境安装软件。</p><p>Docker基于Go语言实现的云开源项目，Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，做到一次封装，处处运行。</p><p>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p><p>Docker解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体分布的容器虚拟化技术。</p><h2 id="能干嘛？"><a href="#能干嘛？" class="headerlink" title="能干嘛？"></a>能干嘛？</h2><h3 id="之前的虚拟化技术"><a href="#之前的虚拟化技术" class="headerlink" title="之前的虚拟化技术"></a>之前的虚拟化技术</h3><p>虚拟机是带环境安装的解决方案，可以在一种操作系统中运行另一种操作系统。</p><p>虚拟机用软件实现了硬件、内核、操作系统及应用程序，对底层来说，虚拟机就是一个普通文件。</p><p>虚拟机的缺点缺点：</p><ol><li>资源占用多</li><li>冗余步骤</li><li>启动慢</li></ol><h3 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h3><p>Linux容器（Linux Containers,LXC)，对进程隔离，将软件运行所需的资源打包到一个隔离的痛其中。</p><img src="https://s1.ax1x.com/2020/07/25/UzVUbV.png" alt="UzVUbV.png" style="zoom:50%;" /><p>Linux容器不是模拟一个完整的操作系统，而是将软件工作所需的库资源和设置等资源打包到一个隔离的容器中，因此Linux容器变得高效且轻量，并且能保证部署在任何环境中的软件都能始终如一地运行。在</p><p>宿主机上，Linux容器就是一个运行的进程，所以Linux容器是对进程进行隔离。</p><p>再看Docker的图标，上面的集装箱就是一个一个容器，鲸鱼就是宿主机的硬件、内核。</p><p>比较：</p><ol><li>传统虚拟机技术虚拟一套硬件，在其上运行一个完整的操作系统，再运行所需的应用进程。</li><li>容器内的应用直接运行于宿主的内核，容器内没有硬件虚拟，容器更轻便。</li><li>容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响。</li></ol><p>所以，可以认为容器是一个轻量的Linux。</p><h3 id="开发-运维（DevOps"><a href="#开发-运维（DevOps" class="headerlink" title="开发/运维（DevOps)"></a>开发/运维（DevOps)</h3><p>DevOps, Develop and Operations, 可以利用Docker实现开发自运维。</p><ol><li>更快速的应用交付和部署。</li><li>更便捷的升级和扩缩容器。</li><li>更简单的系统运维。</li><li>更高效的计算资源利用。</li></ol><h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><p><strong>Docker的三要素：</strong></p><ol><li>镜像(image)：只读的模版，类比Java中的类。镜像可以用来创造Docker容器。</li><li>容器(container)：镜像的实例，独立运行的一个或一组实例。可以把容器看作一个简易版的Linux环境。</li><li>仓库(repository)：保存镜像的场所。</li></ol><p>Docker本身是一个容器运行载体或管理引擎。</p><p>把应用程序和配置打包成为一个可交付的运行环境，打包好的运行环境就是一个image镜像文件，只有通过这个镜像文件才能生成Docker容器。image文件可以看作是容器的模版。Docker根据image文件生成容器的实例。</p><h2 id="Docker运行原理"><a href="#Docker运行原理" class="headerlink" title="Docker运行原理"></a>Docker运行原理</h2><p>Docker是一个C/S结构的系统。</p><p>Docker守护进程运行在宿主机上，客户通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p><h3 id="为什么比虚拟机快"><a href="#为什么比虚拟机快" class="headerlink" title="为什么比虚拟机快"></a>为什么比虚拟机快</h3><ol><li>Docker有比虚拟机更少的抽象层，不需要实现硬件资源虚拟化，运行在docker容器中的程序直接使用的都是实际物理机的硬件资源。</li><li>Docker使用宿主机上的内核，新建容器时，不需要和虚拟机一样重新加载一个操作系统内核。因此新建一个dock er容器只需要几秒钟。</li></ol><h2 id="Docker镜像加速"><a href="#Docker镜像加速" class="headerlink" title="Docker镜像加速"></a>Docker镜像加速</h2><p>可以登陆阿里云获得专属镜像加速器链接，配置本机Docker拉取镜像仓库的链接，将拉取镜像的链接从DockerHub换成阿里云的仓库，下载更快捷。</p><p>具体按照系统自行Google。</p><h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><p>docker version</p><p>docker info</p><p>docker –help 帮助命令</p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul><li><p>列出本地images</p><p><code>docker images</code></p><p>repo</p><ul><li>参数<ul><li>-a :包括中间映像层</li><li>-q : 只显示镜像id</li><li>–digests :显示摘要信息</li><li>–no-trunc :显示完整信息</li></ul></li></ul></li><li><p>从Docker Hub查询镜像名</p><p><code>docker search [OPTIONS] image_name</code> </p><ul><li>–no-trunc </li><li>-s n：收藏数不小于n的镜像</li><li>–automated</li></ul></li><li><p>下载/拉取镜像</p><p><code>docker pull 镜像名[:TAG]</code> </p><p>默认:latest</p></li><li><p>删除镜像</p><p><code>docker rmi 镜像唯一名字/镜像ID</code></p><p>-f :强制删除运行中的镜像文件</p><ul><li><p>删除单个：</p><p> <code>docker rmi -f 镜像ID</code></p></li><li><p>删除多个</p><p><code>docker rmi -f 镜像名1:TAG 镜像名2:TAG</code></p></li><li><p>删除全部：</p><p><code>docker rmi -f $(docker images -qa)</code> </p></li></ul></li></ul><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>容器是一个建议的Linux。</p><ul><li><p>启动容器：</p><p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p><ul><li><code>--name 容器名</code> :为容器指定一个名字</li><li><code>-d</code> ：后台运行容器，返回</li><li><code>-i</code> : 以<strong>交互模式</strong>运行容器，通常与<code>-t</code> 一同使用</li><li><code>-t</code> :为容器重新分配一个伪输入终端，通常与<code>-i</code> 一同使用。</li><li><code>-p</code>  :主机端口和容器端口<ul><li><code>-p ip:hostPort:containerPort</code> </li><li><code>-p ip::containerPort</code> </li><li><code>-p hostPort:containerPort</code> </li><li><code>-p containerPort</code> </li></ul></li><li><code>-P</code> :随机分配端口</li></ul></li><li><p>列出当前运行所有容器：</p><p><code>docker ps</code> </p><ul><li><code>-a</code> : 列出当前所有正在运行的容器和历史上运行过的容器</li><li><code>-l</code> :显示最近创建的容器</li><li><code>-n</code> :显示最近创建的num个容器<ul><li><code>docker ps -n 3</code> </li></ul></li><li><code>-q</code> :静默模式，只显示容器编号</li><li><code>--no-trunc</code> : 不截断输出</li></ul></li><li><p>退出/停止容器</p><ul><li><p>容器停止退出</p><p><code>exit</code> </p></li><li><p>容器不停止退出</p><p>Ctrl + P + Q</p></li></ul></li><li><p>启动容器</p><p><code>docker start 容器名/容器ID</code> </p></li><li><p>重启容器</p><p><code>docker restart 容器名/容器ID</code> </p><p>重启成功后返回容器名/容器ID</p></li><li><p>停止容器</p><p><code>docker stop 容器名/容器ID</code></p></li><li><p>强制停止容器</p><p><code>docker kill 容器名/容器ID</code> </p></li><li><p>删除已停止的容器</p><p><code>docker rm 镜像ID</code> </p><ul><li><p>一次删除多个容器</p><p><code>docker rm -f $(docker ps -a -q)</code> </p><p><code>docker ps -a -q | xargs docker rm</code>  （管道传递参数）</p></li></ul></li></ul><hr><ul><li><p>启动守护式容器</p><p><code>docker run -d 镜像名/镜像ID</code> </p><p><code>docker run -d -p 主机端口:容器内端口 容器ID</code> </p><ul><li><p>如果使用 <code>docker ps -a</code> 查看，会发现容器已经退出</p></li><li><p><strong>Docker容器后台运行，就必须要有一个前台进程与之交互</strong> </p><p>如果容器后台运行，如果不是一直挂起的命令，他就会自动退出。</p></li><li><p>所以最佳的解决方式是将运行的进程以前台进程运行。</p></li></ul></li><li><p>查看容器日志</p><p><code>docker logs -f -t --tail 容器ID</code> </p><ul><li><code>-t</code>：显示加入时间戳</li><li><code>-f</code> ：持续显示最新的日志</li><li><code>--tail</code> ：显示最后多少条</li></ul></li><li><p>显示容器内运行的进程</p><p><code>docker top 容器ID</code> </p></li><li><p>查看容器内部的细节</p><p><code>docker inspect 容器ID</code> </p></li><li><p>进入正在运行的容器并以命令行与之交互</p><ul><li><p>直接进入容器启动命令的终端</p><p><code>docker attach 容器ID</code> </p></li><li><p>在容器中打开新的终端，并且可以启动新的进程。</p><p><code>docker exec -it 容器ID bashShell</code></p><p><code>docker exec -it 容器ID /bin/bash</code>  和<code>docker attach 容器ID</code> 相同。</p></li></ul></li><li><p>把容器内文件拷贝文件到主机上</p><p><code>docker cp 容器ID:容器内的路径 目录主机路径</code> </p><p><code>docker cp 130b1f6708dd:/x.txt /Users</code> </p></li></ul><h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><p>image：</p><p>镜像是轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含运行某个软件所需的所有内容，包括代码、库、环境变量、配置文件等。</p><h2 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h2><p>UnionFS（联合文件系统）是一种分层、轻量高性能的文件系统，支持对文件系统的修改作为一次提交来一层层的叠加，同时将不同目录挂载到同一个虚拟文件系统下。</p><p>Union文件系统时Docker镜像的基础。</p><p>镜像通过分层来进行继承，基于基础镜像可以制作各种具体的应用镜像。</p><p>特点：一次加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，最终的文件系统包含所有底层的文件和目录。</p><h2 id="Docker镜像的加载"><a href="#Docker镜像的加载" class="headerlink" title="Docker镜像的加载"></a>Docker镜像的加载</h2><p>Docker镜像实际是由一层一层的文件系统组成。</p><p>bootfs(boot file system)包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。</p><p>Docker镜像的最底层就是bootfs，这一层和典型的Linux/Unix系统是一样的，包含bootloader和kernel。</p><p>当boot加载完成后，整个kernel就在内存中了，此时内存的使用权已由bootfs转交给kernel，此时系统也会卸载bootfs。</p><p>rootfs（root file system)，在bootfs之上，包含的就是典型Linux系统中的/dev, /proc, /bin, /etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Linux，Centos等。</p><p>平常安装等虚拟机的CentOS都是几个G，为什么docker版的centos只有几百兆？</p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库，因为底层直接使用宿主机的kernel，自己只需要提供rootfs就行了。</p><p>因此，对于不同的Linux发行版，bootfs基本一致，rootfs会有差别，因此不同的发行版可以共用bootfs。</p><h2 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h2><p>在docker image下载、删除时，可以发现是一层一层的。</p><p>分层的镜像的一个最大的好处是共享资源。</p><p>如果有多个镜像都是从相同的base镜像build而来，那宿主机中只需在磁盘上保存一份base镜像，同时内存中也只需要加载一份base镜像，就可以为所有的容器服务了。</p><h2 id="镜像commit操作"><a href="#镜像commit操作" class="headerlink" title="镜像commit操作"></a>镜像commit操作</h2><p>Docker镜像都是只读的，但当镜像实例化，启动容器时，一个新的可写层被加载到镜像的顶部，这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>docker commit提交容器层副本使之成为一个新的镜像。</p><p><code>docker commit -m &quot;message&quot;  -a &quot;author&quot; 容器ID 命名空间/新建镜像名[:TAGS]</code> </p><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><p>Docker理念：</p><p>将代码和运行的环境打包形成容器，运行伴随着容器，但希望运行中的数据是持久化的，希望容器之间是共享数据的。</p><p>如果不通过docker commit生成新的镜像，使得数据作为镜像的一部分保存下来，那么容器删除后，数据也没有了，为了保存数据，使用容器数据卷。</p><p>如果不使用commit 生成新的镜像，Docker容器产生的数据将随着容器的删除而一起删除，为了保存数据，我们使用卷。</p><h2 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h2><p>卷就是目录或者文件，存在于一个或多个容器中，由docker挂载到容器，但不属于UnionFS（联合文件系统），因此能绕过UnionFS，提供一些用于持续存储或共享数据的特性。</p><p>卷的设计目的就是为了数据持久化，完全独立于容器的生存周期，因此Docker不会在容器删除的时候删除其挂载的数据卷。</p><p>数据卷的特点：</p><ol><li>数据卷可以在容器之间共享或重用数据。</li><li>卷中的更改直接在所有共享该卷容器中生效。</li><li>数据卷中的更改不会包含在镜像的更新中。</li><li>数据卷的生命周期一直持续到没有容器使用它为止。</li></ol><h2 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h2><h3 id="直接命令添加"><a href="#直接命令添加" class="headerlink" title="直接命令添加"></a>直接命令添加</h3><ol><li><p>数据挂载(<code>-v</code> value)</p><p><code>docker run -it -v /宿主机目录:/容器内目录 镜像名</code> </p></li><li><p>查看挂载是否成功</p><p><code>docker inspect 镜像名</code> </p></li><li><p>宿主机和容器之间实现数据共享，在容器停止退出后，修改宿主机数据，数据完全同步。</p></li></ol><ul><li><p>带权限的数据挂载，加<code>:ro</code> (readonly) </p><p><code>docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</code></p><p>此时容器中对数据卷只读。</p></li></ul><hr><p>当挂载主机目录事，Docker访问出现<code>cannot open directory .: Permission denied</code> </p><p>解决办法：在挂砸目录后加参数 <code>--privileged=true</code> </p><h3 id="DockerFile添加"><a href="#DockerFile添加" class="headerlink" title="DockerFile添加"></a>DockerFile添加</h3><p>在DockerFile中可以使用<code>VOLUME</code> 指令给镜像添加一个或多个数据卷。</p><p>注意：</p><p>Docker出于可移植性和分享的考虑，指令中只有容器内的地址，因为宿主主机目录依赖于特定的主机。</p><ol><li><p>Dockerfile文件构建</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/dataVolumeContainer1"</span>, <span class="string">"/dataVolumeContainer2"</span>, <span class="string">"/dataVolumeContainer3"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"finished,-----success"</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure><p>以上docker文件类似于一下命令挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /host1:/dataVolumeContainer1 -v/host1:/dataVolumeContainer2 -v /host3:/dataVolumeContainer3 centos /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>build构建镜像（<code>-f</code> file)</p><p><code>docker build -f DockerFile文件路径 -t 命名空间/镜像名 镜像生成路径</code></p><p><code>docker build -f ./Dockerfile  -t fred/centos .</code></p></li></ol><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>数据容器卷：</p><p>命名的容器挂载数据卷，其他容器通过挂载这个父容器实现数据共享，挂载数据卷的容器称为数据卷容器。</p><p><strong>容器之间可以传递配置信息，数据卷的生命周期一直持续到没有容器使用它为止。</strong></p><ol><li><p>挂载数据卷到父容器（命名为<code>dc01</code> ）上：命令添加/Dockerfile添加</p></li><li><p>容器继承父容器的数据卷(<code>--volumes-from</code> )</p><p><code>docker run -it --name 子容器名 --volumes-from 父容器名 生成子容器的镜像名</code> </p><p>e.g: <code>docker run -it --name dc02 --volumes-from dc01 fred/centos</code> </p></li></ol><p>dc01已经挂载数据卷，此时dc02继承它，那么dc01挂载的数据卷，dc02也实现了共享。</p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p><p>构建容器卷的步骤：</p><ol><li>编写Dockerfile文件</li><li>docker build构建</li><li>docker run启动容器</li></ol><p>Centos的Dockerfile文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> centos-7.8.2003-x86_64-docker.tar.xz /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> \</span></span><br><span class="line"><span class="bash">    org.label-schema.schema-version=<span class="string">"1.0"</span> \</span></span><br><span class="line"><span class="bash">    org.label-schema.name=<span class="string">"CentOS Base Image"</span> \</span></span><br><span class="line"><span class="bash">    org.label-schema.vendor=<span class="string">"CentOS"</span> \</span></span><br><span class="line"><span class="bash">    org.label-schema.license=<span class="string">"GPLv2"</span> \</span></span><br><span class="line"><span class="bash">    org.label-schema.build-date=<span class="string">"20200504"</span> \</span></span><br><span class="line"><span class="bash">    org.opencontainers.image.title=<span class="string">"CentOS Base Image"</span> \</span></span><br><span class="line"><span class="bash">    org.opencontainers.image.vendor=<span class="string">"CentOS"</span> \</span></span><br><span class="line"><span class="bash">    org.opencontainers.image.licenses=<span class="string">"GPL-2.0-only"</span> \</span></span><br><span class="line"><span class="bash">    org.opencontainers.image.created=<span class="string">"2020-05-04 00:00:00+01:00"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/bash"</span>]</span></span><br></pre></td></tr></table></figure><h2 id="Dockerfile构建过程"><a href="#Dockerfile构建过程" class="headerlink" title="Dockerfile构建过程"></a>Dockerfile构建过程</h2><p><strong>基础规则：</strong></p><ol><li>保留字指令必须大写，且后面必须至少一个参数。</li><li>指令顺序执行。</li><li>注释符号：<code>#</code> </li><li>每条指令都会创建一个新的镜像层，并对该镜像进行提交。</li></ol><p><strong>执行流程：</strong></p><ol><li>从基础镜像运行一个容器</li><li>执行一条指令后并对容器进行修改</li><li>执行类似docker commit操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个容器</li><li>直到文件所有指令执行完成</li></ol><hr><p>辨析Dockerfile，Docker镜像，Docker容器：</p><p>Dockerfile、Docker镜像与Docker容器从软件应用的角度分别代表软件的三个不同阶段：</p><ol><li><p>Dockerfile是软件的原材料，是面向开发的。</p><p>Dockerfile定义了进程需要的一切东西。Dockerfile设计的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程等等。</p></li><li><p>Docker镜像是软件的交付品，是交付标准。</p><p>在用Dockerfile定义一个文件之后，docker build会产生一个Docker镜像，运行 Docker镜像时，才真正开始提供服务。</p></li><li><p>Docker容器则可以认为是软件的运行态，涉及部署和运维。</p><p>Docker容器是直接提供服务的。</p></li></ol><h2 id="Dockfile体系结构"><a href="#Dockfile体系结构" class="headerlink" title="Dockfile体系结构"></a>Dockfile体系结构</h2><img src="https://s1.ax1x.com/2020/07/25/UzVdET.png" alt="UzVdET.png" style="zoom:50%;" /> <ul><li><p>FROM</p><p>基础镜像</p></li><li><p>MAINTAINER</p><p>镜像维护者的姓名和邮箱地址</p></li><li><p>RUN</p><p>容器构建时需要运行的命令</p></li><li><p>EXPOSE</p><p>当前容器对外暴露的端口号</p></li><li><p>WORKDIR</p><p>指定在创建容器后，终端默认登陆进来的工作目录</p></li><li><p>ENV</p><p>构建容器中的设置环境变量</p></li><li><p>ADD</p><p>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</p></li><li><p>COPY</p><p>拷贝文件和目录到镜像中</p><p><code>COPY src dest</code></p><p><code>COPY [&quot;src&quot;, &quot;dest&quot;]</code> </p></li><li><p>VOLUME</p><p>容器数据卷 用于数据保存和持久化工作</p></li><li><p>CMD</p><p>指定一个容器启动时运行的命令</p><ul><li><p>shell 格式：CMD &lt;命令&gt;</p></li><li><p>exec格式：CMD[“可执行文件”, “arg1”, “arg2”,…]</p></li><li><p>参数列表格式：CMD [“arg1”, “arg2”,…] 在指定来ENTRYPOINT指令后，用⌘指定具体的参数。</p></li></ul><p>只有最后一个CMD生效，CMD会被docker run之后的参数替换</p></li><li><p>ENTRYPOINT</p><p>指定一个容器启动时运行的命令</p><p>会在docker run后面追加参数</p></li><li><p>ONBUILD</p><p>当构建一个被继承的Dockerfile时，父镜像在被子镜像继承后父镜像的ONBUILD被触发</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要分四个部分，首先介绍了Docker是什么：为什么会有Docker技术的出现；虚拟化技术和容器虚拟化技术的区别；Docker的基本组成；Docker的运行为什么会比虚拟机快。&lt;/p&gt;
&lt;p&gt;第二个部分主要介绍了Docker的常用命令，包括镜像命令和容器命令，文中还从底层的角度分析Docker镜像。&lt;/p&gt;
&lt;p&gt;第三个部分介绍了Docker中的容器数据卷，和如何挂载数据卷。&lt;/p&gt;
&lt;p&gt;最后一个部分，简单介绍了Dockerfile文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://f7ed.com/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://f7ed.com/tags/Tools/"/>
    
      <category term="Docker" scheme="https://f7ed.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>「Tools」:Git and GitHub</title>
    <link href="https://f7ed.com/2020/07/18/Git-and-GitHub/"/>
    <id>https://f7ed.com/2020/07/18/Git-and-GitHub/</id>
    <published>2020-07-17T16:00:00.000Z</published>
    <updated>2020-07-25T03:40:33.971Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章具体讲述了Git工具的基本本地库操作和与远程库交互的基本操作，包括使用GitHub进行团队外的协作开发。</p><a id="more"></a><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><h3 id="Git历史："><a href="#Git历史：" class="headerlink" title="Git历史："></a>Git历史：</h3><p>1991 Linus本人手动合并代码</p><p>2002 商业软件，授予Linux社区免费使用版本控制</p><p>2005 Linus自己用C语言开发了一个分布式版本控制系统：Git</p><p>Talk is cheap, show me the code.</p><p>2008 Github上线</p><hr><p>Git的优势：</p><ul><li><p>大部分操作在本地完成，不需要联网</p></li><li><p>完整性保证：每次提交进行哈希</p></li><li><p>尽可能添加数据而不是删除/修改数据，版本都在</p></li><li><p>分支操作快捷流畅，以快照的形式</p></li><li><p>与Linux命令全面兼容</p></li></ul><h3 id="Git的结构"><a href="#Git的结构" class="headerlink" title="Git的结构"></a>Git的结构</h3><img src="https://s1.ax1x.com/2020/07/18/UcvvkQ.png" alt="Git的结构" style="zoom:50%;" /><h3 id="Git和代码托管中心"><a href="#Git和代码托管中心" class="headerlink" title="Git和代码托管中心"></a>Git和代码托管中心</h3><p>代码托管中心的任务：维护远程库</p><p>局域网环境：搭建GitLab作为代码托管中心</p><p>外网环境：可以用GitHub和码云作为代码托管中心</p><h3 id="本地库和远程库的交互"><a href="#本地库和远程库的交互" class="headerlink" title="本地库和远程库的交互"></a>本地库和远程库的交互</h3><p>团队内：</p><img src="https://s1.ax1x.com/2020/07/18/UcvxYj.png" alt="团队内交互" style="zoom:50%;" /><p>团队外：</p><img src="https://s1.ax1x.com/2020/07/18/Ucvzfs.png" alt="团队外交互" style="zoom:50%;" /><p>fork：复制一份属于自己的远程库</p><p>开发新的内容后向库的拥有者 pull request拉取请求，原拥有者可以审核，审核通过后执行merge操作合并到自己的远程库的分支上。</p><h2 id="Git命令行基本操作"><a href="#Git命令行基本操作" class="headerlink" title="Git命令行基本操作"></a>Git命令行基本操作</h2><h3 id="本地库初始化"><a href="#本地库初始化" class="headerlink" title="本地库初始化"></a>本地库初始化</h3><ul><li><p>初始化本地库</p><p><code>git init</code> </p></li></ul><p>.git文件存放的是本地库相关的子目录和文件，不要删除和随意修改。</p><h3 id="本地库设置签名"><a href="#本地库设置签名" class="headerlink" title="本地库设置签名"></a>本地库设置签名</h3><ul><li><p>形式：</p><p>用户名：</p><p>Email：</p></li><li><p>作用：区分不同开发人员的身份</p></li></ul><p>注：这里设置的签名与远程代码托管中心没有关系。</p><ul><li><p>命令：</p><ul><li><p>项目级别：设置签名仅在本地库起效（如果既有项目级别和用户级别的签名，按照项目级别为准）</p><p>设置用户名命令：<code>git config user.name ***</code></p><p>设置用户邮箱： <code>git config user.email *****@outlook.com</code></p><p>该信息保存在.git/config文件中。</p></li><li><p>用户级别：设置签名在当前操作系统的用户范围</p><p>设置用户名命令：<code>git config --global user.name ***</code></p><p>设置用户邮箱命令：<code>git config --global user.email ****</code></p><p>该消息保存在系统文件~/.gitconfig文件</p></li></ul></li></ul><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><ul><li><p>查看工作区、暂存区状态。</p><p> <code>git status</code> </p></li></ul><h3 id="暂存区操作：添加-修改-提交-删除"><a href="#暂存区操作：添加-修改-提交-删除" class="headerlink" title="暂存区操作：添加/修改/提交/删除"></a>暂存区操作：添加/修改/提交/删除</h3><ul><li><p>添加/修改：将工作区的文件添加到暂存区（/或更新暂存区的文件）。</p><p> <code>git add [filename]</code> </p></li><li><p>删除：将文件从暂存区删除</p><p><code>git rm --cached [filename]</code>  </p></li><li><p>提交：将暂存区的文件提交到本地库。（输入提交信息）</p><p><code>git commit -m &quot;commit message&quot; [filename]</code></p></li><li><p>修改后的提交：提交修改后的文件至本地库（已在暂存区有旧版本），同时更新暂存区和本地库。</p><p><code>git commit -m &quot;message&quot; [filename]</code> </p></li></ul><h3 id="本地库版本信息查看"><a href="#本地库版本信息查看" class="headerlink" title="本地库版本信息查看"></a>本地库版本信息查看</h3><p>HEAD: 指针，表示当前版本的位置。</p><p>显示版本：</p><ul><li><p>完整的版本信息记录（包括完整版本哈希值、作者、提交时间）</p><p><code>git log</code> （空格向下翻页；b 向上翻页； q退出显示）</p></li><li><p>一行只显示一个版本，简洁版。</p><p><code>git log --pretty=oneline</code> </p></li><li><p>一行也只显示一个版本，终极简洁版，哈希值也只显示前面的一部分（当作该版本的局部索引）。</p><p><code>git log --oneline</code> </p></li><li><p>HEAD@{i}：i表示HEAD指针移动到该版本需要后退的步数。</p><p><code>git reflog</code> </p></li></ul><h3 id="版本前进-后退"><a href="#版本前进-后退" class="headerlink" title="版本前进/后退"></a>版本前进/后退</h3><p>本质是HEAD指针的移动。</p><ul><li><p>基于索引操作：版本可以后退和前进。(索引就是reflog形式下的局部哈希值)</p><p><code>git reset --hard [局部索引值]</code>  </p></li><li><p>使用<code>^</code> ： 版本只能往后退 。（基于reflog形式下的步数）</p><p><code>git reset --hard HEAD^^</code> (后退两步)</p></li><li><p>使用<code>~n</code> ：版本往后退n步。</p><p><code>git reset --hard HEAD~3</code> </p></li></ul><p><strong>版本前进/后退reset命令的参数对比：</strong></p><ul><li><p><code>--soft</code></p><ul><li><p>仅仅在本地库移动HEAD指针。</p><p>如下图，显得暂存区和工作区版本比本地库前进了一步。</p><img src="https://s1.ax1x.com/2020/07/18/UcvXTg.png" alt="--soft命令" style="zoom:50%;" /></li></ul></li><li><p><code>--mixed</code></p><ul><li><p>在本地库移动HEAD指针</p></li><li><p>并重置暂存区，暂存区和本地库一致。</p><p>如下图，显得工作区版本比本地库和暂存区版本前进了一步。</p><img src="https://s1.ax1x.com/2020/07/18/UcvO0S.png" alt="--mixed命令" style="zoom:50%;" /></li></ul></li><li><p><code>--hard</code></p><ul><li>在本地库移动HEAD指针</li><li>重置暂存区</li><li>重置工作区</li></ul></li></ul><h3 id="删除文件后找回"><a href="#删除文件后找回" class="headerlink" title="删除文件后找回"></a>删除文件后找回</h3><p>前提：删除前，文件存在的状态提交到了本地库。</p><p>操作：</p><ul><li><p>删除的操作已经提交到本地库</p><ul><li><p>删除操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm a.txt</span><br><span class="line">git add a.txt</span><br><span class="line">git commit -m "delete a.txt" a.txt</span><br></pre></td></tr></table></figure></li><li><p><code>git reset --hard [历史版本指针位置]</code> </p></li></ul></li><li><p>删除操作未提交到本地库</p><ul><li><p>删除操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//工作区删除</span><br><span class="line">rm a.txt</span><br><span class="line">//缓存区也删除</span><br><span class="line">rm a.txt</span><br><span class="line">git add a.txt</span><br></pre></td></tr></table></figure></li><li><p><code>git reset --hard HEAD</code> </p></li></ul></li></ul><h3 id="比较文件差异"><a href="#比较文件差异" class="headerlink" title="比较文件差异"></a>比较文件差异</h3><ul><li><p>工作区文件和暂存区文件比较</p><p><code>git diff [filename]</code> </p></li><li><p>工作区文件和本地库文件比较，指针可以使用<code>HEAD^</code> </p><p><code>git diff [指针] [filename]</code> </p></li><li><p>可以不加文件名，即比较全部文件。</p></li></ul><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支：版本控制过程中，使用多条线同时推进多个任务。 </p><img src="https://s1.ax1x.com/2020/07/18/Ucz94H.png" alt="Ucz94H.png" style="zoom:50%;" /><p>master: 主版本分支/部署到服务器运行的分支。</p><p>feature_ ：开发其他功能的分支。</p><p>hot_fix: 热修复，bug修复分支。</p><p>分支的好处：</p><ul><li>并行：同时并行推进多个功能开发。</li><li>独立：各个分支在开发过程中，如果有个分支开发失败，不会影响其他分支。</li></ul><h3 id="分支操作：创建-查看-切换-合并"><a href="#分支操作：创建-查看-切换-合并" class="headerlink" title="分支操作：创建/查看/切换/合并"></a>分支操作：创建/查看/切换/合并</h3><ul><li><p>创建分支</p><p><code>git branch [branch name]</code> </p></li><li><p>查看分支</p><p><code>git branch -v</code> </p></li><li><p>切换分支</p><p><code>git checkout [branch name]</code> </p></li><li><p>合并分支</p><ol><li><p>切换到接受修改的分支（如master）</p><p><code>git checkout [合并到的主分支]</code> </p></li><li><p>执行merge合并操作</p><p><code>git merge [有修改的分支]</code></p></li></ol></li></ul><h3 id="解决合并分支后产生的冲突"><a href="#解决合并分支后产生的冲突" class="headerlink" title="解决合并分支后产生的冲突"></a>解决合并分支后产生的冲突</h3><p>冲突的表现，显示到有冲突的文件：</p><img src="https://s1.ax1x.com/2020/07/18/UczPCd.png" alt="冲突文件内容" style="zoom:50%;" /><p>冲突解决：</p><ol><li><p>删除文件中的特殊符号</p></li><li><p>协商再编辑文件</p></li><li><p>添加新文件</p><p><code>git add [filename]</code></p></li><li><p>提交（注意：此时的提交不能带文件名）</p><p><code>git commit -m &quot;message&quot;</code> </p></li></ol><h2 id="Git-基本原理"><a href="#Git-基本原理" class="headerlink" title="Git 基本原理"></a>Git 基本原理</h2><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>特点：</p><ul><li>得到的加密密文长度相同。</li><li>算法确定，输入确定后，输出一定确定。</li><li>输入数据发生一点点变化，输出的变化会很大。</li><li>Git底层采用SHA-1算法。</li></ul><p>哈希算法保证了Git的数据完整性。</p><h3 id="Git保存版本的机制"><a href="#Git保存版本的机制" class="headerlink" title="Git保存版本的机制"></a>Git保存版本的机制</h3><p>集中式版本控制工具（如SVN）：保存的信息是每个基本文件和每个文件随时间逐步累积的差异。</p><p>Git是分布式的版本控制工具。</p><p>Git把数据看作是文件系统的快照（可以理解为当前内存版本的文件的索引），每次提交更新时Git对当前内存的全部文件制作一个快照并保存这个快照的索引。如果文件没有修改，Git不会重新存储该文件，只是保留一个连接指向之前存储的文件。</p><p>Git的提交对象：</p><img src="https://s1.ax1x.com/2020/07/18/UcvLm8.png" alt="UcvLm8.png" style="zoom:50%;" /><p>上图中，每个文件都有一个哈希值/索引，提交时新建一个树结点，其中包含指向每个文件的指针/索引，提交的对象包括该树结点的指针/哈希值。</p><p>Git版本对象链条：</p><img src="https://s1.ax1x.com/2020/07/18/UcvbOf.png" alt="Git版本对象链条" style="zoom:50%;" /><p>所以：</p><p>Git 分支的创建：等于新建一个指向版本的指针。</p><img src="https://s1.ax1x.com/2020/07/18/UcvH6P.png" alt="分支创建" style="zoom:50%;" /><p>Git分支的切换：改变HEAD指针所指的指针。</p><img src="https://s1.ax1x.com/2020/07/18/Ucv7lt.png" alt="分支切换" style="zoom:50%;" /><p>Git分支版本的移动：分支指针的移动。</p><img src="https://s1.ax1x.com/2020/07/18/UcvTSI.png" alt="分支版本移动" style="zoom:50%;" /><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><h2 id="基本交互"><a href="#基本交互" class="headerlink" title="基本交互"></a>基本交互</h2><h3 id="创建-查看远程库地址别名"><a href="#创建-查看远程库地址别名" class="headerlink" title="创建/查看远程库地址别名"></a>创建/查看远程库地址别名</h3><p>在GitHub创建远程库后</p><ul><li><p>在本地添加远程库地址别名</p><p><code>git remote add [别名] [https/ssh 地址]</code></p><p><code>git remote add orgin https://...</code>  </p></li><li><p>查看当前所有远程库地址别名</p><p><code>git remote -v</code> </p></li></ul><h3 id="本地库内容推送到远程库"><a href="#本地库内容推送到远程库" class="headerlink" title="本地库内容推送到远程库"></a>本地库内容推送到远程库</h3><p>前提：本地库已添加远程库地址别名。</p><ul><li><p>在本地将本地库推送到远程分支</p><p><code>git push [别名] [分支名]</code> </p><p><code>git push origin master</code> </p></li></ul><h3 id="将远程库克隆到本地库"><a href="#将远程库克隆到本地库" class="headerlink" title="将远程库克隆到本地库"></a>将远程库克隆到本地库</h3><ul><li><code>git clone https/ssh_address</code> </li><li>效果：完整把远程库下载到本地；添加origin作为远程库地址别名；初始化本地库（含有.git文件）</li></ul><h2 id="团队内协作"><a href="#团队内协作" class="headerlink" title="团队内协作"></a>团队内协作</h2><h3 id="团队成员邀请"><a href="#团队成员邀请" class="headerlink" title="团队成员邀请"></a>团队成员邀请</h3><p>项目创建者在项目”Setting”-“Callaborators”里邀请成员。</p><h3 id="拉取：同步本地库"><a href="#拉取：同步本地库" class="headerlink" title="拉取：同步本地库"></a>拉取：同步本地库</h3><ul><li><p>在本地pull操作同步本地库与远程库相同。</p></li><li><p>fetch：查看远程库分支，可以切换至远程库分支，查看远程库分支的文件具体内容，决定是否合并。</p><p><code>git fetch [远程库地址别名] [远程分支名]</code> </p><ul><li><p>切换至远程库分支</p><p><code>git checkout orgin/master</code></p></li></ul></li><li><p>merge：（切换至本地库master分支），合并远程库分支。</p><p><code>git merge [远程库地址别名]/[远程分支名]</code> </p></li><li><p>pull = fetch + merge</p><p><code>git pull [远程库地址别名] [远程分支名]</code> </p></li></ul><p>注：如果是简单的修改，可以直接pull拉取，如果不确定远程库修改内容，可以先fetch后再合并分支。</p><h3 id="本地拉取与远程库冲突"><a href="#本地拉取与远程库冲突" class="headerlink" title="本地拉取与远程库冲突"></a>本地拉取与远程库冲突</h3><ul><li>冲突发生原因：不是基于GitHub远程库的最新版进行修改，就不能push，在修改之前必须pull。</li><li>pull拉取下来后如果进入冲突状态，就按照“分支冲突解决办法”</li></ul><h2 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h2><ol><li><p>fork操作：复制一份远程库。</p><p>团队外的人，在项目节目点fork，即可fork一份远程库，该远程库的来源是创建该库的开发者，而fork出的远程库的所有者是执行fork操作的人。</p></li><li><p>clone操作：下载到本地库。</p></li><li><p>push操作：本地修改，推送至远程库。</p></li><li><p>pull request 请求：在远程库（代码托管中心GitHub）执行pull request请求，请求合并该修改到原远程库。</p></li><li><p>（原远程库所有者）审核操作：确认是否合并。</p></li></ol><h2 id="SSH登陆"><a href="#SSH登陆" class="headerlink" title="SSH登陆"></a>SSH登陆</h2><ol><li><p>在当前用户的根目录，生产.ssh密钥目录</p><p><code>ssh-keygen -t rsa -C email@address</code> </p></li><li><p>将<code>.ssh/id_rsa.pub</code> 文件的内容复制到GitHub新建ssh密钥的窗口下。</p></li><li><p>创建ssh远程地址别名</p><p><code>git remote add origin ssh_address</code> </p></li></ol><ul><li><p>Git仓库和SSH-key关联</p><p><code>ssh-add &quot;id_rsa address</code> </p></li></ul><h1 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h1><p>待补充[1]</p><h1 id="Gitlab服务器搭建"><a href="#Gitlab服务器搭建" class="headerlink" title="Gitlab服务器搭建"></a>Gitlab服务器搭建</h1><p>待补充[2]</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>Git工作流待补充</li><li>Gitlab服务器搭建</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章具体讲述了Git工具的基本本地库操作和与远程库交互的基本操作，包括使用GitHub进行团队外的协作开发。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://f7ed.com/categories/Tools/"/>
    
    
      <category term="Tools" scheme="https://f7ed.com/tags/Tools/"/>
    
      <category term="Git" scheme="https://f7ed.com/tags/Git/"/>
    
      <category term="GitHub" scheme="https://f7ed.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>「机器学习-李宏毅」:Semi-supervised Learning</title>
    <link href="https://f7ed.com/2020/07/03/semi-supervised/"/>
    <id>https://f7ed.com/2020/07/03/semi-supervised/</id>
    <published>2020-07-02T16:00:00.000Z</published>
    <updated>2021-01-30T02:59:21.563Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章开篇讲述了什么是Semi-supervised Learning（半监督学习）？</p><p>再次，文章具体阐述了四种Semi-supervised Learning，包括Generative Model，Low-density，Smoothness Assumption和Better Representation。</p><p>对于Generative Model，文章重点讲述了如何用EM算法来训练模型。</p><p>对于Low-density，文章重点讲述了如何让模型进行Self-training，并且在训练中引入Entropy-based Regularization term来尽可能low-density的假设。</p><p>对于Smoothness Assumption，文章重点讲述了Graph-based Approach（基于图的方法），并且在训练中引入Smoothness Regularization term来尽可能满足Smoothness Assumption的假设。</p><p>对于Better Representation，本篇文章只是简单阐述了其思想，具体介绍见这篇博客。</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>什么是Semi-supervised learning(半监督学习)？和Supervised learning（监督式学习）的区别在哪？</p><p><strong>Supervised learning（监督式学习）</strong>：</p><p>用来训练的数据集 $R$  中的数据labeled data，即 ${(x^r,\hat{y}^r)}_{r=1}^R$ .</p><p>比如在图像分类数据集中： $x^r$ 是image，对应的target output $y^r$ 是分类的label。</p><p>而<strong>Semi-supervised learning（半监督式学习）</strong>：</p><p>用来的训练的数据集由两部分组成 $\{(x^r,\hat{y}^r)\}_{r=1}^R$   ,    $\{x^u\}_{u=R}^{R+U}$   ，即labeled data和unlabeled data，而且通常情况下，unlabeled data的数量远远高于labeled data的数量，即 $U&gt;&gt;R$ .</p><p>对于一般的机器学习，有训练集（labeled）和测试集，测试集是不会出现在训练集中的，这种情况就是inductive learning（归纳推理，即通过已有的labeled的data去推断没有见过的其他的数据的label）。</p><p>而Semi-supervised learning 又分为两种，Transductive learning （转导/推论推导）和 Inductive learning（归纳推理）</p><ul><li>Transductive learing: unlabeled data is the testing data. 即这里用来训练的   $\{x^u\}_{u=R}^{R+U}$   就是来自测试数据集中的数据。（只使用他的feature，而不使用他的label！）</li><li>Inductive learning: unlabeled data is not the testing data.即用来训练的   $\{x^u\}_{u=R}^{R+U}$   不是来自测试数据集中的数据，是另外的unlabeled data。</li><li>这里的使用testing data是指使用testing data的feature，即unlabel而不是使用testing data的label。</li></ul><hr><p>为什么会有semi-supervised learning？</p><ul><li><p>Collecting data is easy, but collecting “labelled” data is expensive.</p><p>【收集数据很简单，但收集有label的数据很难】</p></li><li><p>We do semi-supervised learning in our lives</p><p>【在生活中，更多的也是半监督式学习，我们能明白少量看到的事物，但看到了更多我们不懂的，即unlabeled data】</p></li></ul><h2 id="Why-Semi-supervised-learning-helps"><a href="#Why-Semi-supervised-learning-helps" class="headerlink" title="Why Semi-supervised learning helps"></a>Why Semi-supervised learning helps</h2><p>为什么半监督学习能帮助解决一些问题？</p><p>如上图所示，如果只有labeled data，分类所画的boundary可能是一条竖线。</p><img src="https://s1.ax1x.com/2020/07/03/NXRNz6.md.png" alt="NXRNz6.md.png" style="zoom:75%;" /><p>但如果有一些unlabeled data（如灰色的点），分类所画的boundary可能是一条斜线。</p><p>The distribution of the unlabeled data tell us something.</p><p>半监督式学习之所以有用，是因为这些unlabeled data的分布能告诉我们一些东西。</p><p>通常这也伴随着一些假设，所以半监督式学习是否有用往往取决于这些假设是否合理。</p><h1 id="Semi-supervised-Learning-for-Generative-Model"><a href="#Semi-supervised-Learning-for-Generative-Model" class="headerlink" title="Semi-supervised Learning for Generative Model"></a>Semi-supervised Learning for Generative Model</h1><h2 id="Supervised-Generative-Model"><a href="#Supervised-Generative-Model" class="headerlink" title="Supervised Generative Model"></a>Supervised Generative Model</h2><p>在<a href="/2020/03/20/Classification1/" title="这篇">这篇</a>文章中，有详细讲述分类问题中的generative model。</p><p>给定一个labelled training data $x^r\in C_1,C_2$ 训练集。</p><p>prior probability（先验概率）有 $P(C_i)$ 和 $P(x|C_i)$ ，假设是Gaussian模型，则 $P(x|C_i)$ 由Gaussian模型中的 $\mu^i,\Sigma$ 参数决定。</p><p>根据已有的labeled data，计算出假设的Gaussian模型的参数（如下图），从而得出prior probability。</p><img src="https://s1.ax1x.com/2020/07/03/NXonAS.md.png" alt="NXonAS.md.png" style="zoom:75%;" /><p>即可算出posterior probability  $P\left(C_{1} \mid x\right)=\frac{P\left(x \mid C_{1}\right) P\left(C_{1}\right)}{P\left(x \mid C_{1}\right) P\left(C_{1}\right)+P\left(x \mid C_{2}\right) P\left(C_{2}\right)}$ </p><h2 id="Semi-supervised-Generative-Model"><a href="#Semi-supervised-Generative-Model" class="headerlink" title="Semi-supervised Generative Model"></a>Semi-supervised Generative Model</h2><p>在只有labeled data的图中，算出来的 $\mu,\Sigma$ 参数如下图所示：</p><img src="https://s1.ax1x.com/2020/07/03/NXonAS.md.png" alt="NXonAS.md.png" style="zoom:75%;" /><p>但如果有unlabeled data（绿色点），会发现分布的模型参数更可能是是下图：</p><img src="https://s1.ax1x.com/2020/07/03/NXRtRx.md.png" alt="NXRtRx.md.png" style="zoom:75%;" /><p>The unlabeled data $x^u$ help re-estimate $P(C_1),P(C_2),\mu^1,\mu^2,\Sigma$ .</p><p>因此，unlabeled data会影响分布，从而影响prior probability，posterior probability，最终影响 boundary。</p><h3 id="EM"><a href="#EM" class="headerlink" title="EM"></a>EM</h3><p>所以有unlabeled data, 这个Semi-supervised 的算法怎么做呢？</p><p>其实就是<strong>EM</strong>（Expected-maximization algorithm，期望最大化算法。）</p><ol><li><p>Initialization : $\theta={P(C_1),P(C_2),\mu^1,\mu^2,\Sigma}$ .</p><p>初始化Gaussian模型参数，可以随机初始，也可以通过labeled data得出。</p><p>虽然这个算法最终会收敛，但是初始化的参数影响收敛结果，就像gradient descent一样。</p></li><li><p>E：Step 1: compute the posterior probability of unlabeled data $P_\theta(C_1|x^u)$ (depending on model $\theta$ )</p><p>根据当前model的参数，计算出unlabeled data的posterior probability $P(C_1|x^u)$ .(以$P(C_1|x^u)$ 为例) </p></li><li><p>M：Step 2: update model. Back to step1 until the algorithm converges enventually.</p><p>用E步得到unlabeled data的posterior probability来最大化极大似然函数，更新得到新的模型参数，公式很直觉。(以 $C_1$ 为例)</p><p>（$N$ ：data 的总数，包括unlabeled data; $N_1$ :label= $C_1$ 的data数）</p><ul><li><p>$P(C_1)=\frac{N_1+\Sigma_{x^u}P(C_1|x^u)}{N}$  </p><p>对比没有unlabeled data之前的式子， $P(C_1)=\frac{N_1}{N}$ ，除了已有label= $C_1$ ，还多了一部分，即unlabeled data中属于 $C_1$ 的概率和。</p></li><li>$\mu^{1}=\frac{1}{N_{1}} \sum_{x^{r} \in C_{1}} x^{r}+\frac{1}{\sum_{x^{u}} P\left(C_{1} \mid x^{u}\right)} \sum_{x^{u}} P\left(C_{1} \mid x^{u}\right) x^{u}$  <p>对比没有unlabeled data的式子 ，$\mu^{1}=\frac{1}{N_{1}} \sum_{x^{r} \in C_{1}} x^{r}$ ，除了已有的label= $C_1$ ，还多了一部分，即unlabeled data的 $x^u$ 的加权平均（权重为 $P(C_1\mid x^u)$ ，即属于 $C_1$ 的概率）。</p></li><li><p>$\Sigma$ 公式也包括了unlabeled data.</p></li></ul></li></ol><p>所以这个算法的Step 1就是EM算法的Expected期望部分，根据已有的labeled data得出极大似然函数的估计值；</p><p>Step 2就是EM算法的Maximum部分，利用unlabeled data（通过已有模型的参数）最大化E步的极大似然函数，更新模型参数。</p><p>最后反复迭代Step 1和Step 2，直至收敛。</p><h3 id="Why-EM"><a href="#Why-EM" class="headerlink" title="Why EM"></a>Why EM</h3><p>[1]挖坑EM详解。</p><p>为什么可以用EM算法来解决Semi-supervised?</p><ul><li><p>只有labeled data</p><p>极大似然函数 $\log{L(\theta)}=\sum_{x^r}\log{P_\theta(x^r,\hat{y}^r)}$ , 其中 $P_\theta(x^r,\hat{y}^r)=P_\theta(x^r\mid \hat{y}^r)P(\hat{y}^r)$ .</p><p>对上式子求导是有closed-form solution的。</p></li><li><p>有labeled data和unlabeled data</p><p>极大似然函数增加了一部分  $\log L(\theta)=\sum_{x^{r}} \log P_{\theta}\left(x^{r}, \hat{y}^{r}\right)+\sum_{x^{u}} \log P_{\theta}\left(x^{u}\right)$ .</p><p>将后部分用全概率展开， $P_{\theta}\left(x^{u}\right)=P_{\theta}\left(x^{u} \mid C_{1}\right) P\left(C_{1}\right)+P_{\theta}\left(x^{u} \mid C_{2}\right) P\left(C_{2}\right)$  .</p><p>如果要求后部分，因为是unlabeled data, 所以模型 $\theta$ 需要得知unlabeled data的label，即 $P(C_1\mid x^u)$ ,而求这个式子，也需要得到 prior probability $P(x^u\mid C_1)$ ,但这个式子需要事先得知模型 $\theta$ ，因此陷入了死循环。</p><p>因此这个极大似然函数不是convex（凸），不能直接求解，因此用迭代的EM算法逐步maximum极大似然函数。</p></li></ul><h1 id="Low-density-Separation-Assumption"><a href="#Low-density-Separation-Assumption" class="headerlink" title="Low-density Separation Assumption"></a>Low-density Separation Assumption</h1><p>另一种假设是Low-density Separation的假设，即这个世界是非黑即白的”Black-or-white”。</p><p>两种类别之间是low-density，交界处有明显的鸿沟，因此要么是类别1，要么是类别2，没有第三种情况。</p><h2 id="Self-training"><a href="#Self-training" class="headerlink" title="Self-training"></a>Self-training</h2><p>对于Low-density Separation Assumption的假设，使用Self-training的方法。</p><p>Given：labeled data set  $=\{(x^r,\hat{y}^r\}_{r=1}^R$   ,unlabeled data set $ =\{x^u\}_{u=R}^{R+U}$   .</p><p><strong>Repeat：</strong> </p><ol><li><p>Train model  $f^*$  from labeled data set.  $f^*$   is independent to the model)</p><p>从labeled data set中训练出一个模型</p></li><li><p>Apply $f^*$ to the unlabeled data set. Obtain pseudo-label  $\{(x^u,y^u\}_{u=l}^{R+U}\}$  </p><p>用这个模型 $f^*$ 来预测unlabeled data set， 获得伪label</p></li><li><p>Remove a set of data from unlabeled data set, and add them into the labeled data set.</p><p>拿出一些unlabeled data(pseudo-label)，放到labeled data set中，回到步骤1，再训练。</p><ul><li><p>how to choose the data set remains open</p><p>如何选择unlabeled data 是自设计的</p></li><li><p>you can also provide a weight to each data.</p><p>训练中可以对unlabeled data(pseudo-label)和labeled data 赋予不同的权重.</p></li></ul></li></ol><p><strong>注意：</strong> Regression模型是不能self-training的，因为unlabeled data和其pseudo-label放在模型中的loss为0，无法再minimize。</p><h2 id="Hard-Label"><a href="#Hard-Label" class="headerlink" title="Hard Label"></a>Hard Label</h2><p><strong>V.S.  semi-supervised learning for generative model</strong> </p><p>Semi-supervised learning for generative model和Low-density Separation的区别其实是soft label 和hard label的区别。</p><p>Generative Model是利用来unlabeled data的 $P(C_1|x^u)$ posterior probability来计算新的prior probability，迭代更新模型。</p><p>而low-density是计算出unlabeled data的pseudo-label，选择性扩大labeled data set(即加入部分由pseudo-label的unlabeled data)来迭代训练模型。</p><p>因此，如果考虑Neural Network：</p><p>($\theta^*$ 是labeled data计算所得的network parameters)</p><p>如下图，unlabeled data $x^u$ 放入模型中预测，得到 $\begin{bmatrix} 0.7 \ 0.3\end{bmatrix}$ .</p><img src="https://s1.ax1x.com/2020/07/03/NXRYJ1.md.png" alt="NXRYJ1.md.png" style="zoom:75%;" /><p>如果是使用hard label，则 $x^u$ 的target是 $\begin{bmatrix} 1 \ 0\end{bmatrix}$ .</p><p>如果是使用soft label，则 $x^u$ 的target是 $\begin{bmatrix} 0.7 \ 0.3\end{bmatrix}$ .</p><p>如果是使用soft label，则self-training不会有效，因为新的data对原loss的改变为0，不会增大模型的loss，也就无法再对其minimize.</p><p><strong>所以基于Low-density Separation的假设，是非黑即白的，需要使用hard label来self-training。</strong> </p><h2 id="Entropy-based-Regularization"><a href="#Entropy-based-Regularization" class="headerlink" title="Entropy-based Regularization"></a>Entropy-based Regularization</h2><p>在训练模型中，我们需要尽量保证unlabeled data在模型中的分布是low-density separation。</p><p>即下图中，unlabeled data得到的pseudo-label的分布应该尽量集中，而不应该太分散。</p><img src="https://s1.ax1x.com/2020/07/03/NXRJiR.md.png" alt="NXRJiR.md.png" style="zoom:30%;" /> <p>所以，在训练中，<strong>如何评估 $y^u$ 的分布的集中度？</strong></p><p>根据信息学，使用 $y^u$ 的entropy，即  $E\left(y^{u}\right)=-\sum_{m=1}^{5} y_{m}^{u} \ln \left(y_{m}^{u}\right)$ </p><p>(注：这里的 $y^u_m$ 是变量  $y^u=m$ 的概率)</p><p>当 $E(y^u)$ 越小，说明 $y^u$ 分布越集中，如下图。</p><img src="https://s1.ax1x.com/2020/07/03/NXR3dJ.md.png" alt="NXR3dJ.md.png" style="zoom:40%;" /><hr><p>因此，在self-training中：</p><p>$L=\sum_{y^r} C(x^r,\hat{y}^r)+\lambda\sum_{x^u}E(y^u)$ </p><p>Loss function的前一项（cross entropy）minimize保证分类的正确性，后一项（entropy of  $y^u$ ) minimize保证 unlabeled data分布尽量集中，最大可能满足low-density separation的假设。</p><p>training：gradient decent.</p><p>因为这样的形式很像之前提到过的regularization(具体见<a href="/2020/04/21/tips-for-DL/" title="这篇文章的3.2">这篇文章的3.2</a>)，所以又叫entropy-based regularization.</p><h2 id="Outlook-Semi-supervised-SVM"><a href="#Outlook-Semi-supervised-SVM" class="headerlink" title="Outlook: Semi-supervised SVM"></a>Outlook: Semi-supervised SVM</h2><p>SVM也是解决semi-supervised learning的方法.</p><img src="https://s1.ax1x.com/2020/07/03/NXRaQK.md.png" alt="NXRaQK.md.png" style="zoom:50%;" /><p>上图中，在有unlabeled data的情况下，希望boundary 分的越开越好（largest margin）和有更小的error.</p><p>因此枚举unlabeled data所有可能的情况，但枚举在计算量上是巨大的，因此SVM（Support Vector Machines）可以实现枚举的目标，但不需要这么大的枚举量。</p><h1 id="Smoothness-Assumption"><a href="#Smoothness-Assumption" class="headerlink" title="Smoothness Assumption"></a>Smoothness Assumption</h1><p>Smoothness Assumption的思想可以用以下话归纳：</p><p>“You are known by the company you keep”</p><p>近朱者赤，近墨者黑。</p><p>蓬生麻中，不扶而直。白沙在涅，与之俱黑。</p><p>Assumption：“similar” $x$ has the same $\hat{y}$ .</p><p>【意思就是说：相近的 $x$ 有相同的label $\hat{y}$ .】</p><p><strong>More precise assumption：</strong></p><ul><li>x is not uniform</li><li>if $x^1$ and $x^2$ are close in a hign density region, $\hat{y}^1$ and $\hat{y}^2$ are the same.</li></ul><p>Smoothness Assumption假设更准确的表述是：</p><p> x不是均匀分布，如果 $x^1$ 和 $x^2$ 通过一个high density region的区域连在一起，且离得很近，则 $\hat{y}^1$ 和 $\hat{y}^2$ 相同。</p><p>如下图， $x^1$ 和 $x^2$ 通过high density region连接在一起，有相同的label，而 $x^2$ 和 $x^3$ 有不同的label.</p><img src="https://s1.ax1x.com/2020/07/03/NXR1Z4.md.png" alt="NXR1Z4.md.png" style="zoom:50%;" /><hr><p>Smoothness Assumption通过观察大量unlabeled data，可以得到一些信息。</p><p>比如下图中的两张人的左脸和右脸图片，都是unlabeled，但如果给大量的过渡形态（左脸转向右脸）unlabeled data，可以得出这两张图片是相似的结论.</p><p><a href="https://imgchr.com/i/NXoQpj"><img src="https://s1.ax1x.com/2020/07/03/NXoQpj.md.png" alt="NXoQpj.md.png"></a> </p><p>Smoothness Assumption还可以用在文章分类中，比如分类天文学和旅游学的文章。</p><p>如下图， 文章 d1和d3有overlap word（重叠单词），所以d1和d3是同一类，同理 d4和d2是一类。</p><img src="https://s1.ax1x.com/2020/07/03/NXoutg.md.png" alt="NXoutg.md.png" style="zoom:50%;" /><p>如果，下图中，d1和d3没有overlap word，就无法说明d1和d3是同一类。</p><img src="https://s1.ax1x.com/2020/07/03/NXoKhQ.md.png" alt="NXoKhQ.md.png" style="zoom:50%;" /><p>但是，如果我们收集到足够多但unlabeled data，如下图，通过high density region的连接和传递，也可以得出d1和d3一类，d2和d4一类。</p><img src="https://s1.ax1x.com/2020/07/03/NXol1s.md.png" alt="NXol1s.md.png" style="zoom:80%;" /><h2 id="Cluster-and-then-Label"><a href="#Cluster-and-then-Label" class="headerlink" title="Cluster and then Label"></a>Cluster and then Label</h2><p>在Smoothness Assumption假设下，直观的可以用cluster and then label，先用所有的data训练一个classifier。</p><p>直接聚类标记(比较难训练）。</p><h2 id="Graph-based-Approach"><a href="#Graph-based-Approach" class="headerlink" title="Graph-based Approach"></a>Graph-based Approach</h2><p>另一种方法是利用图的结构（Graph structure）来得知 $x^1$ and $x^2$ are close in a high density region (connected by a high density path).</p><p>Represent the data points as a graph.</p><p>【把这些数据点看作一个图】</p><img src="https://s1.ax1x.com/2020/07/03/NXRKMT.md.png" alt="NXRKMT.md.png" style="zoom:50%;" /><p>建图有些时候是很直观的，比如网页中的超链接，论文中的引用。</p><p>但有的时候也需要自己建图。</p><p>注意：</p><p>如果是影像类，base on pixel，performance就不太好，一般会base on autoencoder，将feature抽象出来，效果更好。</p><h3 id="Graph-Construction"><a href="#Graph-Construction" class="headerlink" title="Graph Construction"></a>Graph Construction</h3><p>建图过程如下：</p><ol><li><p>Define the similarity $s(x^i, x^j)$ between $x^i$ and $x^j$ .</p><p>【定义data $x^i$ 和 $x^j$ 的相似度】</p></li><li><p>Add edge【定义数据点中加边（连通）的条件】</p><ul><li><p>K Nearest Neighbor【和该点最近的k个点相连接】</p><img src="https://s1.ax1x.com/2020/07/03/NXReGq.png" alt="NXReGq.png" style="zoom:50%;" /></li><li><p>e-Neighborhood【与离该点距离小于等于e的点相连接】</p><img src="https://s1.ax1x.com/2020/07/03/NXRZin.png" alt="NXRZin.png" style="zoom:50%;" /></li></ul></li><li><p>Edge weight is proportional to $s(x^i, x^j)$ 【边点权重就是步骤1定义的连接两点的相似度】</p><p>Gaussian Radial Basis Function： $s\left(x^{i}, x^{j}\right)=\exp \left(-\gamma\left\|x^{i}-x^{j}\right\|^{2}\right)$ </p><p>一般采用如上公式（经验上取得较好的performance）。</p><p>因为利用指数化后（指数内是两点的Euclidean distance），函数下降的很快，只有当两点离的很近时，该相似度 $s(x^i,x^j)$  才大，其他时候都趋近于0.</p></li></ol><h3 id="Graph-based-Approach-1"><a href="#Graph-based-Approach-1" class="headerlink" title="Graph-based Approach"></a>Graph-based Approach</h3><p>图建好后：</p><p>The labeled data influence their neighbors.</p><p>Propagate through the graph.</p><p>【label data 不仅会影响他们的邻居，还会一直传播下去】</p><img src="https://s1.ax1x.com/2020/07/03/NXRmR0.md.png" alt="NXRmR0.md.png" style="zoom:40%;" /><p>如果data points够多，图建的好，就会像下图这样：</p><img src="https://s1.ax1x.com/2020/07/03/NXREIs.png" alt="NXREIs.png" style="zoom:50%;" /><p>但是，如果data较少，就可能出现下图这种label传不到unlabeled data的情况：</p><img src="https://s1.ax1x.com/2020/07/03/NXRPsS.png" alt="NXRPsS.png" style="zoom:50%;" /><h3 id="Smoothness-Definition"><a href="#Smoothness-Definition" class="headerlink" title="Smoothness Definition"></a>Smoothness Definition</h3><p>因为是基于Smoothness Assumption，所以最后训练出的模型应让得到的图尽可能满足smoothness的假设。</p><p><strong>注意：</strong> 这里的因果关系是，unlabeled data作为NN的输入，得到label $y$ ，该label $y$ 和labeled data的 label $\hat{y}$  一起得到的图是尽最大可能满足Smoothness Assumption的。</p><p>（<strong>而不是</strong>建好图，然后unlabeled data的label $y$ 是labeled data原有的 $\hat{y}$ 直接传播过来的，不然训练NN干嘛）</p><p>把unlabeled data作为NN的输入，得到label ，对labeled data和”unlabeled data” 建图。</p><p>为了在训练中使得最后的图尽可能满足假设，定义<strong>smoothness of the labels on the graph</strong>.</p>$S=\frac{1}{2} \sum_{i,j} w_{i, j}\left(y^{i}-y^{j}\right)^{2}$  <p>（对于所有的labeled data 和 “unlabeled data”（作为NN输入后，有label））</p><p>按照上式计算，得到的Smoothness如下图所示：</p><p><a href="https://imgchr.com/i/NXRiqg"><img src="https://s1.ax1x.com/2020/07/03/NXRiqg.md.png" alt="NXRiqg.md.png"></a> </p><p><strong>Smaller means smoother.</strong> </p><p>【Smoothness $S$ 越小，表示图越满足这个假设】</p><hr><p>计算smoothness $S$ 有一种简便的方法：</p>$S=\frac{1}{2} \sum_{i, j} w_{i, j}\left(y^{i}-y^{j}\right)^{2}=y^{T} L y$  (这里的1/2只是为了计算方便)<ul><li><p>$y$ : (R+U)-dim vector，是所有label data和”unlabeled data” 的label，所以是R+U维。</p><p>$y=\begin{bmatrix}…y^i…y^j…\end{bmatrix}^T$ </p></li><li><p>$L$ :(R+U) $\times$ (R+U) matrix，也叫Graph Laplacian（调和矩阵，拉普拉斯矩阵）</p><p>$L$ 的计算方法：$L=D-W$ </p><p>其中 $W$ 矩阵算是图的邻接矩阵（区别是无直接可达边的值是0）</p><p>$D$ 矩阵是一个对角矩阵，对角元素的值等于 $W$ 矩阵对应行的元素和</p><p>矩阵表示如下图所示：</p><img src="https://s1.ax1x.com/2020/07/03/NXRkZQ.md.png" alt="NXRkZQ.md.png" style="zoom:50%;" /></li></ul><p>（证明据说很枯燥，暂时略[2])</p><h3 id="Smoothness-Regularization"><a href="#Smoothness-Regularization" class="headerlink" title="Smoothness Regularization"></a>Smoothness Regularization</h3>$S=\frac{1}{2} \sum_{i, j} w_{i, j}\left(y^{i}-y^{j}\right)^{2}=y^{T} L y$  <p> $S$ 中的 $y$ 其实是和network parameters有关的（unlabeled data的label），所以把 $S$ 也放进损失函数中minimize，以求尽可能满足smoothness assumption.</p><p>以满足smoothness assumption的损失函数： $L=\sum_{x^r} C\left(y^{r}, \hat{y}^{r}\right)+\lambda S$ </p><p>损失函数的前部分使labeled data的输出更贴近其label，后部分 $\lambda S$ 作为regularization term，使得labeled data和unlabeled data尽可能满足smoothness assumption.</p><p>除了让NN的output满足smoothness的假设，还可以让NN的任何一层的输出满足smoothness assumption，或者让某层外接一层embedding layer，使其满足smoothness assumption，如下图：</p><img src="https://s1.ax1x.com/2020/07/03/NXRAaj.png" alt="NXRAaj.png" style="zoom:50%;" /><h1 id="Better-Representation"><a href="#Better-Representation" class="headerlink" title="Better Representation"></a>Better Representation</h1><p>Better Presentation的思想就是：去芜存菁，化繁为简。</p><ul><li>Find the latent(潜在的) factors behind the observation.</li><li>The latent factors (usually simpler) are better representation.</li></ul><p>【找到所观察事物的潜在特征，即该事物的better representation】</p><p>该部分后续见这篇博客。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><p>挖坑：EM算法详解</p></li><li><p>挖坑：Graph Laplacian in smoothness.</p></li><li><p>Olivier Chapelle：Semi-Supervised Learning </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章开篇讲述了什么是Semi-supervised Learning（半监督学习）？&lt;/p&gt;
&lt;p&gt;再次，文章具体阐述了四种Semi-supervised Learning，包括Generative Model，Low-density，Smoothness Assumption和Better Representation。&lt;/p&gt;
&lt;p&gt;对于Generative Model，文章重点讲述了如何用EM算法来训练模型。&lt;/p&gt;
&lt;p&gt;对于Low-density，文章重点讲述了如何让模型进行Self-training，并且在训练中引入Entropy-based Regularization term来尽可能low-density的假设。&lt;/p&gt;
&lt;p&gt;对于Smoothness Assumption，文章重点讲述了Graph-based Approach（基于图的方法），并且在训练中引入Smoothness Regularization term来尽可能满足Smoothness Assumption的假设。&lt;/p&gt;
&lt;p&gt;对于Better Representation，本篇文章只是简单阐述了其思想，具体介绍见这篇博客。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习-李宏毅" scheme="https://f7ed.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9D%8E%E5%AE%8F%E6%AF%85/"/>
    
    
      <category term="Machine-Learning" scheme="https://f7ed.com/tags/Machine-Learning/"/>
    
      <category term="open-classes" scheme="https://f7ed.com/tags/open-classes/"/>
    
      <category term="Semi-supervised" scheme="https://f7ed.com/tags/Semi-supervised/"/>
    
  </entry>
  
  <entry>
    <title>「算法导论」:排序-总结</title>
    <link href="https://f7ed.com/2020/06/29/sort-preview/"/>
    <id>https://f7ed.com/2020/06/29/sort-preview/</id>
    <published>2020-06-28T16:00:00.000Z</published>
    <updated>2020-07-03T08:50:09.474Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章review了算法中的排序算法，包括冒泡排序、插入排序、归并排序、堆排序（以及用堆实现优先队列）、快速排序和计数排序。</p><p>分别从算法思路、算法伪代码实现、算法流程、算法时间复杂度四个方面阐述每个算法。</p><a id="more"></a><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><strong>排序问题：</strong></p><p>输入：一个 $n$个数的序列 $&lt;a_1,a_1,…,a_n&gt;$ </p><p>输出：输入序列的一个重拍 $&lt;a_1’,a_2’,…,a_n’&gt;$ ，使得 $a_1’\leq a_2’ \leq…\leq a_n’$ .</p><p>在实际中，待排序的数很少是单独的数值，它们通常是一组数据，称为记录(record)。每个记录中包含一个关键字(key)，这就是需要排序的值。记录剩下的数据部分称为卫星数据(satellite data)，通常和关键字一同存取。</p><p><strong>原址排序：</strong>输入数组中仅有常数个元素需要在排序过程中存储在数组之外。</p><p>典型的原址排序有：插入排序、堆排序、快速排序。</p><hr><p><strong>符号说明：</strong> </p><ul><li><p>$\Theta$ 记号：</p><p>$\Theta$ 记号渐进给出一个函数的上界和下界。</p>  $\Theta(g(n))=\left\{f(n): \text { there exist positive constants } c_{1}, c_{2}, \text { and } n_{0}\text { such that } \right.  \left.0 \leq c_{1} g(n) \leq f(n) \leq c_{2} g(n) \text { for all } n \geq n_{0}\right\}$<p>$g(n)$ 称为 $f(n)$ 的一个渐进紧确界(asymptotically tight bound)</p></li><li><p>$O$ 记号</p><p>$O$ 记号只给出了函数的渐进上界。</p>  $O(g(n))=\left\{f(n): \text { there exist positive constants } c \text { and } n_{0}\text { such that } \right.  \left.0 \leq f(n) \leq c g(n) \text { for all } n \geq n_{0}\right\}$ </li><li><p>$\Omega$ 记号</p><p>$\Omega$ 记号给出了函数的渐进下界。</p>  $\Omega(g(n))=\left\{f(n): \text { there exist positive constants } c \text { and } n_{0}\text { such that } \right. \left.0 \leq c g(n) \leq f(n) \text { for all } n \geq n_{0}\right\}$ <p>符号比较如下图：</p></li></ul><p><a href="https://imgchr.com/i/Nh2if1"><img src="https://s1.ax1x.com/2020/06/29/Nh2if1.md.png" alt="Nh2if1.md.png"></a> </p><p><strong>排序算法运行时间一览</strong> ：</p><table><thead><tr><th>算法</th><th>最坏情况运行时间</th><th>平均情况/期望运行时间</th></tr></thead><tbody><tr><td>插入排序</td><td>$\Theta (n^2)$</td><td>$\Theta(n^2)$</td></tr><tr><td>归并排序</td><td>$\Theta(n\lg{n})$</td><td>$\Theta(n\lg{n})$</td></tr><tr><td>堆排序</td><td>$O(n\lg{n})$</td><td>-</td></tr><tr><td>快速排序</td><td>$\Theta(n^2)$</td><td>$\Theta(n\lg{n})$ (expected)</td></tr><tr><td>计数排序</td><td>$\Theta(k+n)$</td><td>$\Theta(k+n)$</td></tr><tr><td>基数排序</td><td>$\Theta(d(n+k))$</td><td>$\Theta(d(n+k))$</td></tr><tr><td>桶排序</td><td>$\Theta(n^2)$</td><td>$\Theta(n)$ (average-case)</td></tr></tbody></table><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>反复交互相邻未按次序排列的元素。</p><p><strong>BUBBLESORT(A)</strong></p><ul><li>参数：A待排序数组</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to A.lengh<span class="literal">-1</span></span><br><span class="line"><span class="keyword">for</span> j = A.length downto i+<span class="number">1</span> //每次迭代找出A[<span class="type">i..j</span>]中最小的元素放在A[<span class="type">i</span>]位置</span><br><span class="line"><span class="keyword">if</span> A[<span class="type">j</span>] &lt; A[<span class="type">j</span>-<span class="number">1</span>]</span><br><span class="line">exchange A[<span class="type">j</span>] with A[<span class="type">j</span>-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>冒泡排序是原址排序，流行但低效。</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>如下图所示，插入排序就像打牌时排序一手扑克牌。</p><p><a href="https://imgchr.com/i/Nh2m0e"><img src="https://s1.ax1x.com/2020/06/29/Nh2m0e.png" alt="Nh2m0e.png"></a> </p><ol><li>开始时，我们的左手为空，桌子上的牌面向下。</li><li>然后，我们每次从桌子上拿走一张牌，想把它放在左手中的正确位置。</li><li>为了找到这张牌的正确位置，我们从右到左将这张牌和左手里的牌依次比较，放入正确的位置。</li><li>左手都是已排序好的牌。</li></ol><p><strong>INSERTION-SORT(A)</strong> </p><ul><li>A：待排序数组</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> to A.length</span><br><span class="line">key = A[<span class="type">j</span>]</span><br><span class="line">//将key插入到已排序好的A[<span class="number">1</span><span class="type">..j</span>-<span class="number">1</span>]</span><br><span class="line">i = j - <span class="number">1</span> //pointer <span class="keyword">for</span> sorted sequence A[<span class="number">1</span><span class="type">..j</span>-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span> and A[<span class="type">i</span>] &gt; key</span><br><span class="line">A[<span class="type">i</span>+<span class="number">1</span>] = A[<span class="type">i</span>]</span><br><span class="line">i--</span><br><span class="line">A[<span class="type">i</span>+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure><p>插入排序是原址排序，对于少量元素是一个有效的算法。</p><p>最坏情况的运行时间： $\Theta(n^2)$ .</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p><strong>分治</strong>： 将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p><p><strong>分治的步骤</strong>：</p><ol><li>分解：分解原问题为若干规模较小的子问题。</li><li>解决：递归地求解各子问题，规模较小，可直接求解。</li><li>合并：合并这些子问题的解成原问题的解。</li></ol><h2 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h2><p><strong>归并排序中的分治</strong> ：</p><ol><li>分解：分解待排序的n个元素序列成各n/2个元素序列的两个子序列。</li><li>解决：使用归并排序递归地排序两个子序列，当序列长度为1时，递归到达尽头。</li><li>合并：合并两个已经排序好的子序列以产生排序好的原序列。</li></ol><p><strong>核心</strong> ：合并两个已经排序好的子序列——MERGE(A, p, q, r)</p><ul><li>A: 待排序原数组。</li><li>p, q, r: 数组下标，满足 $p\leq q&lt;r$ 。</li><li>假设子数组 A[p..q] 和A[q+1..r]都已经排好序，合并这两个数组代替原来的A[p..r]子数组。</li></ul><hr><p><strong>MERGE算法理解：</strong> </p><ol><li>牌桌上有两堆牌面朝上，每堆都已排好序，最小的牌在顶上。希望将两堆牌合并成排序好的输出牌堆，且牌面朝下。</li><li>比较两堆牌顶顶牌，选取较小的那张，牌面朝下的放在输出牌堆。</li><li>重复步骤2直至某一牌堆为空。</li><li>将剩下的另一堆牌面朝下放在输出堆。</li></ol><p>MERGE合并的过程如下图所示：</p><p><a href="https://imgchr.com/i/Nh2E6K"><img src="https://s1.ax1x.com/2020/06/29/Nh2E6K.md.png" alt="Nh2E6K.md.png"></a> </p><p><strong>MERGE算法分析：</strong> </p><p>在上述过程中，n个元素，我们最多执行n个步骤，所以MERGE合并需要 $\Theta(n)$ 的时间。</p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><strong>MERGE(A, p, q, r)</strong> </p><ul><li>功能：合并已排序好的子数组A[p..q]和A[q+1..r]</li><li>参数：A为待排序数组，p, q, r为数组下标，且满足 $p\leq q&lt;r$ </li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Let S[<span class="type">p..r</span>] be new arrays</span><br><span class="line">k = p //pointer <span class="keyword">for</span> S[]</span><br><span class="line">i = p, j = q+<span class="number">1</span> //pointer <span class="keyword">for</span> subarray</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> k &lt;= r </span><br><span class="line"><span class="keyword">while</span> ( i &lt;= q and j &lt;= r and A[<span class="type">i</span>] &lt;= A[<span class="type">j</span>] ) or j &gt; r  // 取A[<span class="type">p..q</span>]牌堆</span><br><span class="line">S[<span class="type">k</span>++] = A[<span class="type">i</span>++]</span><br><span class="line"><span class="keyword">while</span> ( i &lt;= q and j &lt;= r and A[<span class="type">i</span>] &gt;= A[<span class="type">j</span>] ) or i &gt; q //取A[<span class="type">q</span>+<span class="number">1</span><span class="type">..r</span>]牌堆</span><br><span class="line"></span><br><span class="line">A[<span class="type">p..r</span>] = S[<span class="type">p..r</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>MERGE-SORT(A, p, r)</strong> </p><ul><li>功能：排序子数组A[p..r]</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p &lt; r</span><br><span class="line">q = (p+r)/<span class="number">2</span></span><br><span class="line"><span class="built_in">MERGE-SORT</span>(A, p, q)</span><br><span class="line"><span class="built_in">MERGE-SORT</span>(A, q+<span class="number">1</span>, r)</span><br><span class="line">MERGE(A, p, q, r)</span><br></pre></td></tr></table></figure><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="分治算法运行时间分析"><a href="#分治算法运行时间分析" class="headerlink" title="分治算法运行时间分析"></a>分治算法运行时间分析</h3><p>分治算法运行时间递归式来自三个部分。</p><p>假设 $T(n)$ 是规模为 $n$ 的一个问题的运行时间。若规模问题足够小，则直接求解需要常量时间，将其写作 $\Theta(1)$ 。</p><p>假设把原问题分解成 $a$ 个子问题，每个子问题的规模是原问题的 $1/b$ (在归并排序中， $a$ 和 $b$ 都为2，但很多分治算法中 $a\neq b$ )。为了求解一个规模为 $n/b$ 规模的子问题，需要 $T(n/b)$ 的时间，所以需要 $aT(n/b)$ 的时间求解 $a$ 个子问题。</p><p>如果分解子问题需要 $D(n)$ 时间，合并子问题需要 $C(n)$ 时间。</p><p>递归式：</p>$$T(n)=\left\{\begin{array}{ll}\Theta(1) & \text { if } n \leq c \\ a T(n / b)+D(n)+C(n) & \text { otherwise }\end{array}\right.$$<h3 id="归并排序分析"><a href="#归并排序分析" class="headerlink" title="归并排序分析"></a>归并排序分析</h3><p>前文分析了MERGE(A, p, q, r) 合并两个子数组的时间复杂度是 $\Theta(n)$ ，即 $C(n)=\Theta(n)$ ，且 $D(n)=\Theta(n)$ .</p><p>归并排序的最坏情况运行时间 $T(n)$ :</p>$$T(n)=\left\{\begin{array}{ll}\Theta(1) & \text { if } n=1 \\ 2 T(n / 2)+\Theta(n) & \text { if } n>1\end{array}\right.$$<p>用递归树的思想求解递归式：</p><p><a href="https://imgchr.com/i/Nh2Al6"><img src="https://s1.ax1x.com/2020/06/29/Nh2Al6.md.png" alt="Nh2Al6.md.png"></a> </p><p>即递归树每层的代价为 $\Theta(n)=cn$ ，共有 $\lg{n}+1$ 层，所以归并排序的运行时间结果是 $\Theta(n\lg{n})$  .</p><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>自由树</strong> ：连通的、无环的无向图。</p><p><strong>有根数</strong> ：是一棵自由树，其顶点存在一个与其他顶点不同的顶点，称为树的根。</p><p><strong>度</strong> ：有根树中一个结点 $x$ 孩子的数目称为 $x$ 的度。</p><p><strong>深度</strong> :从根 $r$ 到结点 $x$ 的简单路径。</p><p><strong>二叉树</strong> ：不包括任何结点，或者包括三个不相交的结点集合：一个根结点，一棵称为左子树的二叉树和一棵称为右子树的二叉树。</p><p><strong>完全k叉树</strong> ：所有叶结点深度相同，且所有内部结点度为k的k叉树。</p><hr><p><strong>（二叉）堆</strong> ：是一个数组，它可以被看成一个近似的完全二叉树，树上的每个结点对应数组中的一个元素。除了最底层外，该树被完全填满，并且是从左到右填充。如下图所示。</p><p><a href="https://imgchr.com/i/Nh2Ck9"><img src="https://s1.ax1x.com/2020/06/29/Nh2Ck9.md.png" alt="Nh2Ck9.md.png"></a> </p><p>堆的数组$A$ 有两个属性：</p><ul><li><p>$A.length$ ：数组元素的个数，A[1..A.length]中都存有值。</p></li><li><p>$A.heap-size$ ：有多少个堆元素在数组，A[1..heap-size]中存放的是堆的有效元素。</p><p>（$0\leq A.heap-size\leq A.lengh$ )</p></li></ul><p><strong>堆的性质：</strong> </p><ul><li><p>$A[1]$ :存放的是树的根结点。</p></li><li><p>对于给定的一个结点 $i$ ，很容易计算他的父结点、左孩子和右孩子的下标。</p><ul><li><p><strong>PARENT(i)</strong> </p><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> i/<span class="number">2</span> //i&gt;&gt;&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>LEFT(i)</strong> </p><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">2</span>*i //i&lt;&lt;&lt;<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>RIGHT(i)</strong> </p><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">2</span>*i+<span class="number">1</span> //i&lt;&lt;&lt;<span class="number">1</span> | <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>包含$n$ 个元素的堆的高度为 $\Theta(\lg{n})$ </p></li><li><p>堆结构上的基本操作的运行时间至多和堆的高度成正比，即时间复杂度为 $O(\lg{n})$ .</p></li><li><p>叶子结点：n/2+1 , n/2+2 , … , n</p></li></ul><p><strong>堆的分类：</strong> </p><ul><li><p>最大堆：</p><p>除了根以外的结点 $i$ 都满足 $A[\text{PARENT}(i)]\geq A[i]$ .</p><p>某个结点最多和其父结点一样大。</p><p>堆的最大元素存放在根结点中。</p></li><li><p>最小堆：</p><p>除了根以外的结点 $i$ 都满足 $A[\text{PARENT}(i)]\leq A[i]$ .</p><p>堆的最小元素存放在根结点中。</p></li></ul><p><strong>堆的基本过程</strong> :</p><ul><li>MAX-HEAPIFY：维护最大堆的过程，时间复杂度为 $O(\lg{n})$ </li><li>BUILD-MAX-HEAP：将无序的输入数据数组构造一个最大堆，具有线性时间复杂度 $O(n\lg{n})$ 。</li><li>HEAPSORT：对一个数组进行原址排序，时间复杂度为 $O(n\lg{n})$ </li><li>MAX-HEAP-INSERT、HEAP-EXTRACT-MAX、HEAP-INCREASE-KEY和HEAP-MAXIMUM：利用堆实现一个优先队列，时间复杂度为 $O(\lg{n})$ .</li></ul><h2 id="维护：MAX-HEAPIFY"><a href="#维护：MAX-HEAPIFY" class="headerlink" title="维护：MAX-HEAPIFY"></a>维护：MAX-HEAPIFY</h2><p>调用MAX-HEAPIFY的时候，假定根结点LEFT(i)和RIGHT(i)的二叉树都是最大堆，但A[i]可能小于其左右孩子，因此违背了堆的性质。</p><p>MAX-HEAPIFY通过让 A[i]“逐级下降”，从而使下标为i的根结点的子树满足最大堆的性质。</p><p><strong>MAX-HEAPIFY(A, i)</strong> </p><ul><li>功能：维护下标为i的根结点的子树，使其满足最大堆的性质。</li><li>参数：i 是该子树的根结点，其左子树右子树均满足最大堆的性质。</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l = LEFT(i)</span><br><span class="line">r = RIGHT(i)</span><br><span class="line"><span class="keyword">if</span> l &lt;= A.heap<span class="literal">-size</span> and A[<span class="type">l</span>] &gt; A[<span class="type">i</span>]</span><br><span class="line">largest = l</span><br><span class="line"><span class="keyword">else</span> largest = i</span><br><span class="line"><span class="keyword">if</span> r &lt;= A.heap<span class="literal">-size</span> and A[<span class="type">r</span>] &gt; A[<span class="type">i</span>]</span><br><span class="line">largest = r</span><br><span class="line"><span class="keyword">if</span> largest != i</span><br><span class="line">exchange A[<span class="type">i</span>] with A[<span class="type">largest</span>]</span><br><span class="line">MAX<span class="literal">-HEAPIFY</span>(A, largest)</span><br></pre></td></tr></table></figure><p>下图是执行 MAX-HEAPIFY(A, 2)的执行过程。A.heap-size=10, 图(a)(b)(c)依次体现了值为4的结点依次下降的过程。</p><p><a href="https://imgchr.com/i/Nh2PYR"><img src="https://s1.ax1x.com/2020/06/29/Nh2PYR.md.png" alt="Nh2PYR.md.png"></a> </p><p><strong>时间复杂度分析</strong> ：</p><p>MAX-HEAPIFY的时间复杂度为 $O(lg{n})$.</p><h2 id="建堆：BUILD-MAX-HEAP"><a href="#建堆：BUILD-MAX-HEAP" class="headerlink" title="建堆：BUILD-MAX-HEAP"></a>建堆：BUILD-MAX-HEAP</h2><p>堆的性质：</p><p>子数组A[n/2+1..n]中的元素都是树的叶子结点。因为下标最大的父结点是n/2，所以n/2以后的结点都没有孩子。</p><p><strong>建堆</strong> ：每个叶结点都可以看成只包含一个元素的堆，利用自底向上的方法，对树中其他结点都调用一次MAX-HEAPIFY，把一个大小为n = A.length的数组A[1..n]转换为最大堆。</p><p><strong>BUILD-MAX-HEAP(A)</strong> </p><ul><li>功能：把A[1..n]数组转换为最大堆</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.heap<span class="literal">-size</span> = A.length</span><br><span class="line"><span class="keyword">for</span> i = A.length/<span class="number">2</span> downto <span class="number">1</span></span><br><span class="line">MAX<span class="literal">-HEAPIFY</span>(A, i)</span><br></pre></td></tr></table></figure><p>下图是把A数组构造成最大堆的过程：</p><p><a href="https://imgchr.com/i/Nh2kSx"><img src="https://s1.ax1x.com/2020/06/29/Nh2kSx.md.png" alt="Nh2kSx.md.png"></a> </p><p><strong>时间复杂度分析</strong> ：</p><p>BUILD-MAX-HEAP需要 $O(n)$ 次调用MAX-HEAPIFY，因此构造最大堆的时间复杂度是 $O(n\lg{n})$ .</p><h2 id="排序：HEAPSORT"><a href="#排序：HEAPSORT" class="headerlink" title="排序：HEAPSORT"></a>排序：HEAPSORT</h2><p><strong>算法思路</strong>： </p><ol><li>初始化时，调用BUILD-MAX-HEAP将输入数组A[1..n]建成最大堆，其中 n = A.length。</li><li>调用后，最大的元素在A[1]，将A[1]和A[n]互换，可以把元素放在正确的位置。</li><li>将n结点从堆中去掉(通过减少A.heap-size实现)，剩余结点中，原来根的孩子仍是最大堆，但根结点可能会违背堆的性质，调用MAX-HEAPIFY(A, 1)，从而构造一个新的最大堆。</li><li>重复步骤3，直到堆的大小从n-1降为2.</li></ol><p><strong>HEAPSORT(A)</strong> </p><ul><li>功能：利用堆对数组排序</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BUILD<span class="literal">-MAX</span><span class="literal">-HEAP</span>(A)</span><br><span class="line"><span class="keyword">for</span> i = A.length downto <span class="number">2</span></span><br><span class="line">exchange A[<span class="number">1</span>] with A[<span class="type">i</span>]</span><br><span class="line">A.heap<span class="literal">-size</span> = A.heap<span class="literal">-size</span> - <span class="number">1</span></span><br><span class="line">MAX<span class="literal">-HEAPIFY</span>(A, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>下图为调用HEAPSORT的过程图：</p><p><a href="https://imgchr.com/i/NhgjyT"><img src="https://s1.ax1x.com/2020/06/29/NhgjyT.md.png" alt="NhgjyT.md.png"></a> </p><p><strong>时间复杂度分析</strong> ：</p><p>建堆BUILD-MAX-HEAP的时间复杂度为 $O(n\lg{n})$ ，n-1次调用MAX-HEAPIFY的时间复杂度为 $O(n\lg{n})$ ，所以堆排序的时间复杂度为 $O(n\lg{n})$ .</p><h2 id="堆的应用：优先队列"><a href="#堆的应用：优先队列" class="headerlink" title="堆的应用：优先队列"></a>堆的应用：优先队列</h2><p>这里关注如何用最大堆实现最大优先队列。</p><p><strong>优先队列(priority queue)：</strong> </p><p>一种用来维护由一组元素构成的集合S的数据结构，其中每一个元素都有一个相关的值，称为关键字(key)。</p><p><strong>（最大）优先队列支持的操作</strong> ：</p><ul><li>INSERT(S, x)：把元素 $x$ 插入集合S中，时间复杂度为 $O(\lg{n})$ 。</li><li>MAXIMUM(S)：返回S中具有最大关键字的元素，时间复杂度为 $O(1)$ 。</li><li>EXTRACT-MAX(S)：去掉并返回S中的具有最大关键字的元素，时间复杂度为 $O(\lg{n})$ 。</li><li>INCREASE-KEY(S, x, k)：将元素 $x$ 的关键字值增加到k，这里假设k的大小不小于元素 $x$ 的原关键字值，时间复杂度为 $O(\lg{n})$ 。</li></ul><h3 id="MAXIMUM"><a href="#MAXIMUM" class="headerlink" title="MAXIMUM"></a>MAXIMUM</h3><p>将集合S已建立最大堆的前提下，调用HEAP-MAXIMUM在 $\Theta(1)$ 实现MAXIMUM的操作。</p><p><strong>HEAP-MAXIMUM(A)</strong> </p><ul><li>功能：实现最大优先队列MAXIMUM的操作，即返回集合中最大关键字的元素。</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> A[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析</strong> ：$\Theta(1)$ </p><h3 id="EXTRACT-MAX"><a href="#EXTRACT-MAX" class="headerlink" title="EXTRACT-MAX"></a>EXTRACT-MAX</h3><p>类似于HEAPSORT的过程。</p><ul><li><p>A[1]为最大的元素，A[1]的孩子都是最大堆。</p></li><li><p>将A[1]和A[heap-size]交换，减少堆的大小(heap-size)。</p></li><li><p>此时根结点的孩子满足最大堆，而根不一定满足最大堆性质，维护一下当前堆。</p></li></ul><p><strong>HEAP-EXTRACT-MAX(A)</strong> </p><ul><li>功能：实现最大优先队列EXTRACT-MAX的操作，即去掉并返回集合中最大关键字的元素。</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> A.heap-<span class="keyword">size</span> &lt; <span class="number">1</span></span><br><span class="line"><span class="keyword">error</span> <span class="string">"heap underflow"</span></span><br><span class="line"><span class="keyword">max</span> = A[<span class="number">1</span>]</span><br><span class="line">A[<span class="number">1</span>] = A[A.heap-<span class="keyword">size</span>]</span><br><span class="line">A.heap-<span class="keyword">size</span> = A.heap-<span class="keyword">size</span> - <span class="number">1</span></span><br><span class="line">MAX-HEAPIFY(A, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">max</span></span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析</strong> ：$O(\lg{n})$ .</p><h3 id="INCREASE-KEY"><a href="#INCREASE-KEY" class="headerlink" title="INCREASE-KEY"></a>INCREASE-KEY</h3><p>如果增加A[i]的关键词，可能会违反最大堆的性质，所以实现HEAP-INCREASE-KEY的过程类似插入排序：从当前i结点到根结点的路径上为新增的关键词寻找恰当的插入位置。</p><ol><li><p>当前元素不断和其父结点比较，如果当前元素的关键字更大，则和父结点进行交换。</p></li><li><p>步骤1不断重复，直至当前元素的关键字比父结点小。</p></li></ol><p><strong>HEAP-INCREASE-KEY(A, i, key)</strong> </p><ul><li>功能：实现最大优先队列INCREASE-KEY的功能，即将A[i]的关键字值增加为key.</li><li>参数：i为待增加元素的下标，key为新关键字值。</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key &lt; A[<span class="type">i</span>]</span><br><span class="line">error <span class="string">"new key is smaller than current key"</span></span><br><span class="line">A[<span class="type">i</span>] = key</span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">1</span> and A[<span class="type">PARENT</span>(<span class="type">i</span>)] &lt; A[<span class="type">i</span>]</span><br><span class="line">exchange A[<span class="type">i</span>] with A[<span class="type">PARENT</span>(<span class="type">i</span>)]</span><br><span class="line">i = PARENT(i)</span><br></pre></td></tr></table></figure><p>下图展示了HEAP-INCREASE-KEY的过程：</p><p><a href="https://imgchr.com/i/Nh2Sw4"><img src="https://s1.ax1x.com/2020/06/29/Nh2Sw4.md.png" alt="Nh2Sw4.md.png"></a> </p><p><strong>时间复杂度分析</strong> ：$O(\lg{n})$ </p><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p>如何插入一个元素扩展最大堆？</p><ol><li>先通过增加一个关键字值为 $-\infin$ 的叶子结点扩展最大堆。</li><li>再调用HEAP-INCREASE-KEY过程为新的结点设置对应的关键字值。</li></ol><p><strong>MAX-HEAP-INSERT(A, key)</strong></p><ul><li>功能：实现最大优先队列的INSERT功能，即将关键字值为key的新元素插入到最大堆中。</li><li>参数：key是待插入元素的关键字值。</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.heap<span class="literal">-size</span> = A.heap<span class="literal">-size</span> + <span class="number">1</span></span><br><span class="line">A[<span class="type">A.heap</span>-<span class="type">size</span>] = -∞</span><br><span class="line">HEAP<span class="literal">-INCREASE</span><span class="literal">-KEY</span>(A, A.heap<span class="literal">-size</span>, key)</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析</strong> ：$O(\lg{n})$ .</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>对于包含 $n$个数的输入数组来说，快速排序是一个最坏情况时间复杂度为 $\Theta(n^2)$ 的排序算法。</p><p>虽然最坏情况时间复杂度很差，但是快速排序通常是实际排序应用中最好的选择，因为他的平均性能非常好：他的期望时间复杂度为 $\Theta(n\lg{n})$ ，而且 $\Theta(n\lg{n})$ 中隐含的常数因子非常小。</p><p>另外，它还能进行原址排序。</p><h3 id="分治-1"><a href="#分治-1" class="headerlink" title="分治"></a>分治</h3><p>对A[p..r]子数组进行快速排序的分治过程：</p><ul><li><p>分解：</p><p>数组A[p..r]被划分为两个（可能为空）的子数组A[p..q-1]和A[q+1..r]。</p><p>使得A[p..q-1]中的每个元素都小于等于A[q]，A[q+1..r]中的每个元素都大于等于A[q]。</p><p>其中计算下标q也是分解过程的一部分。</p></li><li><p>解决：通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序。</p></li><li><p>合并：因为子数组都是原址排序的，所以不需要合并操作，A[p..r]已经排好序。</p></li></ul><h3 id="快速排序：QUICKSORT"><a href="#快速排序：QUICKSORT" class="headerlink" title="快速排序：QUICKSORT"></a>快速排序：QUICKSORT</h3><p>按照分治的过程。</p><p><strong>QUICKSORT(A, p, r)</strong> </p><ul><li>功能：快速排序子数组A[p..r]</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p &lt; r</span><br><span class="line">q = PARTITION(A, p, r)</span><br><span class="line">QUICKSORT(A, p, q<span class="literal">-1</span>)</span><br><span class="line">QUICKSORT(A, q+<span class="number">1</span>, r)</span><br></pre></td></tr></table></figure><h3 id="数组的划分：PARTITION"><a href="#数组的划分：PARTITION" class="headerlink" title="数组的划分：PARTITION"></a>数组的划分：PARTITION</h3><p>快速排序的关键部分就在于如何对数组A[p..r]进行划分，即找到位置q。</p><p><strong>PARTITION(A, p, r)</strong> </p><ul><li>功能：对子数组A[p..r] 划分为两个子数组A[p..q-1]和子数组A[q+1..r]，其中A[p..q-1] 小于等于A[q]小于等于A[q+1..r]</li><li>返回：数组的划分下标q</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = A[<span class="type">r</span>]</span><br><span class="line">i = p - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j = p to r - <span class="number">1</span> // j is pointer <span class="keyword">for</span> comparation</span><br><span class="line"><span class="keyword">if</span> A[<span class="type">j</span>] &lt;= x</span><br><span class="line">i = i+<span class="number">1</span></span><br><span class="line">exchange A[<span class="type">i</span>] with A[<span class="type">j</span>]</span><br><span class="line">exchange A[<span class="type">i</span>+<span class="number">1</span>] with A[<span class="type">r</span>]</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>PARTITION总是选择一个 $x=A[r]$ 作为主元(pivot element)，并围绕它来划分子数组A[p..r]。</p><p>在循环中，数组被划分为下图四个（可能为空的）区域：</p><p><a href="https://imgchr.com/i/NhgvOU"><img src="https://s1.ax1x.com/2020/06/29/NhgvOU.md.png" alt="NhgvOU.md.png"></a> </p><ol><li>$p\leq k\leq i$ ，则 $A[k]\leq x$ .</li><li>$i+1\leq k \leq j-1$ ，则 $A[k]&gt;x$.</li><li>$k = r$ ，则 $A[k]=x$ .</li><li>$j\leq k\leq r-1$ ，则 $A[k]$ 与 $x$ 无关。</li></ol><p>下图是将样例数组PARTITION的过程：</p><p><a href="https://imgchr.com/i/Nh2pTJ"><img src="https://s1.ax1x.com/2020/06/29/Nh2pTJ.md.png" alt="Nh2pTJ.md.png"></a> </p><h3 id="快速排序的性能"><a href="#快速排序的性能" class="headerlink" title="快速排序的性能"></a>快速排序的性能</h3><p>[*]待补充</p><h3 id="快速排序的随机化版本"><a href="#快速排序的随机化版本" class="headerlink" title="快速排序的随机化版本"></a>快速排序的随机化版本</h3><p>与始终采用 $A[r]$ 作为主元的方法不同，随机抽样是从子数组A[p..r]随机选择一个元素作为主元。</p><p>加入随机抽样，在平均情况下，对子数组A[p..r]的划分是比较均匀的。</p><p><strong>RANDOMIZED-PEARTITION(A, p, r)</strong> </p><ul><li>功能：数组划分PARTITION的随机化主元版本</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = RANDOM(p, r)</span><br><span class="line">exchange A[<span class="type">r</span>] with A[<span class="type">i</span>]</span><br><span class="line"><span class="keyword">return</span> PARTITION(A, p, r)</span><br></pre></td></tr></table></figure><p><strong>RANDOMIZED-QUICKSORT(A, p, r)</strong> </p><ul><li>功能：使用随机化主元的快速排序</li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> p &lt; r</span><br><span class="line">q = RANDOMIZED<span class="literal">-PARTITION</span>(A, p, r)</span><br><span class="line">RANDOMIZED<span class="literal">-QUICKSORT</span>(A, p, q<span class="literal">-1</span>)</span><br><span class="line">RANDOMIZED<span class="literal">-QUICKSORT</span>(A, q+<span class="number">1</span>, r)</span><br></pre></td></tr></table></figure><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p><strong>计数排序</strong> ：</p><p>假设 $n$ 个输入元素中的每一个都是在 0到 $k$ 区间内到一个整数，其中 $k$ 为某个整数。当 $k = O(n)$ 时，排序的运行时间为 $\Theta(n)$ .</p><p><strong>计数排序的思想</strong> ：</p><p>对每一个输入元素 $x$，确定小于 $x$ 的元素个数。利用这个信息，就可以直接把 $x$ 放在输出数组正确的位置了。</p><p><strong>COUNTING-SORT(A, B, k)</strong> </p><ul><li>功能：计数排序</li><li>参数：<ul><li>A[1..n]输入的待排序数组，A.length = n</li><li>B[1..n] 存放排序后的输出数组；</li><li>临时存储空间 C[0..k] ，A[1..n]中的元素大小不大于k.</li></ul></li></ul><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let C[<span class="number">0</span><span class="type">..k</span>] be a new array</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span> to k</span><br><span class="line">C[<span class="type">i</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j = <span class="number">1</span> to A.length</span><br><span class="line">C[<span class="type">A</span>[<span class="type">j</span>]] = C[<span class="type">A</span>[<span class="type">j</span>]] + <span class="number">1</span></span><br><span class="line">//C[<span class="type">i</span>] now contains the number of elements equal to i.</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to k</span><br><span class="line">C[<span class="type">i</span>] = C[<span class="type">i</span>] + C[<span class="type">i</span>-<span class="number">1</span>]</span><br><span class="line">//C[<span class="type">i</span>] now contains the number of elements less than or equal to i.</span><br><span class="line"><span class="keyword">for</span> j = A.length downto <span class="number">1</span></span><br><span class="line">B[<span class="type">C</span>[<span class="type">A</span>[<span class="type">j</span>]]] = A[<span class="type">j</span>]</span><br><span class="line">C[<span class="type">A</span>[<span class="type">j</span>]] = C[<span class="type">A</span>[<span class="type">j</span>]] - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>下图是计数排序的过程：</p><p><a href="https://imgchr.com/i/NhgzmF"><img src="https://s1.ax1x.com/2020/06/29/NhgzmF.md.png" alt="NhgzmF.md.png"></a> </p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>Introduction to Algorithms.</li><li>算法导论</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章review了算法中的排序算法，包括冒泡排序、插入排序、归并排序、堆排序（以及用堆实现优先队列）、快速排序和计数排序。&lt;/p&gt;
&lt;p&gt;分别从算法思路、算法伪代码实现、算法流程、算法时间复杂度四个方面阐述每个算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法导论" scheme="https://f7ed.com/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="Algorithms" scheme="https://f7ed.com/tags/Algorithms/"/>
    
      <category term="Intro-to-Algorithms" scheme="https://f7ed.com/tags/Intro-to-Algorithms/"/>
    
      <category term="Sort" scheme="https://f7ed.com/tags/Sort/"/>
    
  </entry>
  
</feed>
